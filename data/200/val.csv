title,body,analysis,probability_distribution,machine_learning,from_scratch,tensorflow,statistics,deep_learning,linear_algebra
Revisiting Basel with Fourier,"While there are many ways to solve this problem—Euler’s method, in particular, is one of the countless examples through which one can witness his amazing intuition and heuristic—but we will be using Fourier expansion to solve this problem, as it also provides a nice segue into the Dirichlet Eta function. We explored the topic of Fourier expansion in this previous post. To recap, from a very high level, Fourier expansion is a way of expressing some function in terms of trigonometric functions. If Taylor expansion used polynomials as the building block, Fourier expansion uses sines and cosines. A generic formula for the Fourier transform can be expressed as follows: With some integration, it can be shown that where  refers to the domain of integration. For instance, if we are integrating from  to , . A classic interval that is most commonly used is , and this is no coincidence: notice that, when , the Taylor series shown in (2) simplifies into the following: And indeed this is the format and the interval we will be using when constructing a Fourier series to tackle the Basel problem.",1,0,0,0,0,0,0,0
InceptionNet in PyTorch,"I won’t get into the details here, as the number of parameters are simply from the original paper. As you can see, there are auxiliary classifiers here and there. If the model is training, we get three outputs in total: , , and . When the model is in , however, we only get , as that’s all we need as the final logits to be passed through a softmax function. Let’s see the gigantic beauty of this model. Great. To be honest, I don’t think the output of the print statement is that helpful; all we know is that the model is huge, and that there is a lot of room for error. So let’s conduct a quick sanity check with a dummy input to see if the model works properly. Great! We’ve passed to the model a batch containing two RGB images of size 224-by-224, which is the standard input assumed by the InceptionNet model. We get in return a tensor of shape , which means we got two predictions, as expected.",0,0,0,0,0,0,1,0
The Magic of Euler’s Identity,"This can simply be shown by starting from Euler’s identity and taking the natural log on both sides. In fact, because  is a periodic function around the unit circle, any odd multiple of  will give us the same result. While it is true that logarithmic functions are undefined for negative numbers, this proposition is only true in the context of real numbers. Once we move onto the complex plane, what may appear as unintuitive and mind-boggling operations suddenly make mathematical sense. This is precisely the magic of Euler’s identity: the marriage of different numbers throughout the number system, blending them together in such a way that seems so simple, yet so incomprehensibly complex and profound.",1,0,0,0,0,0,0,0
"Newton-Raphson, Secant, and More","Notice that subtracting these two expression results in a lot of term cancellations. Dividing both sides by  yields From this result, we now know why the central divided difference method provides more accurate approximations of the derivative than do forward and backward divided difference. This is somewhat related to what we will be doing in the next section, so it’s a good intuition to have throughout when reading the rest of this article. Now that we have these tools for differential calculus, now comes the exciting part: solving non-linear equations. Specifically, we will be taking a look at two numerical methods: the Newton-Raphson method and the secant method. It’s time to put the methods we developed in the preceding sections to use for solving non-linear equations. Specifically, we’ll begin by taking look at a classic algorithm, the Newton-Raphson method. The Newton-Raphson method is one of the many ways of solving non-linear equations. The intuition behind the Newton-Raphson method is pretty straightforward: we can use tangent lines to approximate the x-intercept, which is effectively the root of the equation . Specifically, we begin on some point on the graph, then obtain the tangent line on that point.",1,0,0,0,0,0,0,0
Logistic Regression Model from Scratch,"Now that we know the basic maths behind logistic regression using the sigmoid function, it’s time to implement it via code. Welcome to the next part of the tutorial, where we start building the actual model from scratch. As always, it’s a good idea to have some dummy data ready for disposal so that we can develop some basic intuition about dimensionality of our data when handling inputs and outputs of our functions. Here is the data we used in the last post on k-nearest neighbors algorithm, slightly modified for the purposes of this post. Let’s start by translating equation (2) into executable code. The idea is that we want to get a dot product of the weight vector and the data vector, then plug the resulting value into the sigmoid function to get some value between 0 and 1. The  function shown below exactly performs this task, with the added caveat that it returns a label prediction when the boolean argument  is set to ; a raw sigmoid output when the same is set to . Let’s perform a quick sanity check by using some dummy weight vector.",0,0,1,1,0,0,0,0
A Simple Autocomplete Model,"Let’s run this for 50 epochs, just to give our model enough time to explore the loss function and settle on a good minimum. As I was training this model on Google Colab, I noticed that training even this simple model took a lot of time. Therefore, I decided that it is a good idea to probably save the trained model—in the worst case scenario that poor network connection suddenly caused the Jupyter kernel to die, saving a saved model file would be of huge help since I can continue training again from there. Saving the model on Google Colab requires us to import a simple module, . The process is very simple. To load the model, we can simply call the command below. Let’s take a look at the loss curve of the model. We can simply look at the value of the loss function as printed throughout the training scheme, but why not visualize it if we can?  As expected, the loss decreases throughout each epoch. The reason I was not paticularly worried about overfitting was that we had so much data to work with, especially in comparison with the relatively constrained memory capacity of our one-layered model.",0,0,0,0,1,0,1,0
The Exponential Family,"One such variant that I prefer and find more intuitive uses a simple fractional approach for normalization instead of adding complications to the exponential term. For notational convenience, I will follow the fractional normalization approach shown below throughout this post. Before we proceed any further, it is probably a good idea to clarify the setup of the equations above. First,  denotes a -dimensional random variable of interest; , a -dimensional parameter that defines the probability distribution.  is known as the sufficient statistic function. Below is a brief summary concerning the mappings of these different functions. You will notice that I used  and  instead of  and  as shown in equation (3). This is because (3) assumes vectorization of these functions as follows. We could have expressed (3) without vectorization, but doing so would be rather verbose. So we instead adhere to the vectorized convention in (3) throughout this post. As I hinted earlier, the exponential family covers a wide range of probability distributions, most PDFs and PMFs. In fact, most probability distributions that force themselves onto the page of statistics textbooks belong to this powerful family. Below is a non-comprehensive list of distributions that belong to the exponential family.",0,1,0,0,0,1,0,0
Traveling Salesman Problem with Genetic Algorithms,"Then, we slice a portion of the chromosome of one parent, and fill the rest of the slots with that of the other parent. When filling the rest of the slots, we need to make sure that there are no duplicates in the chromosome. Let’s take a look at an example. Imagine one parent has  and the other has . Let’s also say that slicing a random portion of the first parent gave us . Then, we fill up the rest of the empty indices with the other parent, paying attention to the order in which elements occur. In this case, we would end up with . Let’s see how this works. Now, we wrap the swap and crossover mutation into one nice function to call so that we perform each mutation according to some specified threshold. Let’s test it on . When we call , we end up with the population bag for the next generation, as expected. Now it’s finally time to put it all together. For convenience, I’ve added some additional parameters such as  or , but for the most part, a lot of what is being done here should be familiar and straightforward.",0,0,0,1,0,0,0,0
"Beta, Bayes, and Multi-armed Bandits","Instead of using the approach outlined in the blog I’ve linked to, I decided to use objects to model bandits. The rationale is that this approach seems to make a little bit more intuitive sense to me. Also, working with Django these days has made me feel more affinity with Python classes. At any rate, let’s go ahead. Now, we can initialize a bandit with some predetermined parameter, . Of course, our goal would be to determine the true value of this parameter through sampling and Bayesian magic. In this case, we have created a fair bandit with a  of 0.5. We can also simulate level pulls by repeatedly calling on . Note that this will accumulate the result of each Bernoulli trial in the  list object. Notice that we also have . This is an a list object that c Now that we have performed all the basic sanity checks we need, let’s quickly go ahead and create three bandit objects for demonstration purposes. Now we get into the details of how to perform the Bayesian update.",0,1,0,0,0,1,0,0
A Brief Introduction to Recurrent Neural Networks,"Notice that in calculating , the output of the current sequence, the output of the previous sequence,  is used. By using the output of the previous sequence, the recurrent neural network is able to “remember” some of the information that was produced by the previous input. Granted, this is not exactly what memory is or how it works in the strictest sense, but we can see how some information from the previous input is trickling down to affect the computation of the current sequence of input data. Note that I used  for the example, but we can just about use any other activation function. Here is one way we might implement this in Python. Although not necessary, I decided to opt for a class-based implementation to make things look tight and nicer. Let’s create a  class object to see that everything works properly. There is really not much point in seeing the output because the calculations are going to be based off of randomly generated data and randomly created weights, but perhaps there is something to be learned from the dimensionality of input and output data. First, note that our model accepts input of size .",0,0,0,0,1,0,1,0
A Brief Introduction to Recurrent Neural Networks,"Recurrent neural networks are one of the hottest topics in the contemporary deep learning academia because it presents numerous possibilities for applications. Hopefully this post gave you a better understanding of what all the hype is about, why RNNs are effective at what they do, and how they can be used in the context of basic natural language processing. In the next post, we will take a look at another interesting natural language processing task. Peace! My deepest condolences to those affected by the Wuhan corona virus, as well as the families and fans of Kobe Bryant.",0,0,0,0,1,0,1,0
On Expectations and Integrals,"Consider a constant random variable (I know it sounds oxymoronic, but the idea is that the random variable takes only one value and that value only). In this case, we can imagine the probability density function as a literal spike in the sense that the PDF will peak at  and be zero otherwise. The cumulative density function will thus exhibit a discontinuous jump from zero to 1 at . And by the same line of logic, it is easy to see that the expected value of this random variable is , as expected. Although this is a rather boring example in that the expectation of a constant is of course the constant itself, it nonetheless demonstrates the potential applications of Riemann-Stieltjes. I hope you enjoyed reading this post. Lately, I have been busy working on some interesting projects. There is a lot of blogging and catching up to do, so stay posted for exciting updates to come!.",0,0,0,0,0,1,0,0
"Linear Regression, in Two Ways","The intuition behind this approach is simple: if we can derive a formula that expresses the error between actual values of  and those predicted by regression, denoted as  above, we can use calculus to derive that expression and ultimately locate the global minimum. And that’s exactly what we’re going to do. But before we jump into it, let’s briefly go over some basics of matrix calculus, which is the variant of calculus we will be using throughout. Much like we can derive a function by a variable, say  or , loosely speaking, we can derive a function by a matrix. More strictly speaking, this so-called derivative of a matrix is more formally known as the gradient. The reason why we introduced the gradient as a derivative by a matrix is that, in many ways, the gradient in matrix calculus resembles a lot of what we saw with derivatives in single variable calculus. For the most part, this intuition is constructive and helpful, and the few caveats where this intuition breaks down are beyond the purposes of this post. For now, let’s stick to that intuition as we venture into the topic of gradient.",0,0,0,0,0,0,0,1
A PyTorch Primer,"Nonetheless, in this section, we will take a look at both ways of building models. Let’s start with the function-based method. The function-based method reminds me a lot of Keras’s sequential method. Let’s remind ourselves of Kera’s basic sequential model API: Now let’s compare this method with PyTorch’s way of declaring sequential models: This model declaration is in fact exactly identical to the simple model we have declared above. You can easily see how similar this code snippet is to the Keras example. The only difference is that the activation function is declared independently of the layer itself in PyTorch, whereas Keras combines them into one via  argument. Of course, you don’t have to specify this argument, and we can import the ReLU function from TensorFlow to make it explicit like the PyTorch example. The point, however, is that the sequential model API for both libraries are pretty similar. Another way to build models is by subclassing . The  submodule in PyTorch is the one that deals with neural networks; hence the . This subclassing might look as follows: This model is no different from the  we defined earlier.",0,0,0,0,0,0,1,0
Convex Combinations and MAP,"The fancier the name, the more desire to learn—it is a natural human instinct indeed. I hope you enjoyed reading this article. In the next post, we will continue our discussion by exploring the concept of conjugate priors, which is something that we have always assumed as true and glossed over, yet is arguably what remains at the very core of Bayesian analysis.",0,0,0,0,0,1,0,0
Word2vec from Scratch,"So here comes the crux of word2vec: we loop through each word (or token) in the sentence. In each loop, we look at words to the left and right of the input word, as shown below. This illustration was taken from this article by Ramzi Karam.  In the particular example as shown above, we would generate the following input and prediction pairs part of the training data. Note that the window size is two, which is why we look up to two words to the left and right of the input word. So in a way, we can understand this as forcing the model to understand a rough sense of context—the ability to see which words tend to stick together. In our own example, for instance, we would see a lot of , meaning that the model should be able to capture the close contextual affinity between these two words. Below is the code that generates training data using the algorithm described above. We basically iterate over the tokenized data and generate pairs.",0,0,0,1,0,0,1,0
Logistic Regression Model from Scratch,"In mathematical notation, we might express this process as follows: If we were to perform this in vectorized format, where  represents a vector containing the weight coefficients of the logistic regression model: The  notation is used to denote gradients, an important operation in matrix calculus which we explored in when deriving the normal equation solution to linear regression on this blog. The  denotes a hyperparameter known as the learning rate, which essentially determines how big of a step the gradient descent model takes with each iteration. The main takeaway here is the the gradient descent method allows us to find the local minimum of any convex function, no matter how multidimensional or complex. This is an incredibly powerful statement, and it is one that lies at the core of many machine learning algorithms. To implement gradient descent with code, we have to figure out what the gradient descent equation is in the case of logistic regression. To do this, we need a bit of calculus work using the chain rule. Recall that our goal is to compute since we want to calculate the slope of the cross entropy function with respect to the weights vector.",0,0,1,1,0,0,0,0
A Step Up with  Variational Autoencoders,"This was included because training a VAE can take some time, and we don’t want to waste computing resources seeing only submarginal increments to the model performance. Training begins! After 14 epochs, training has stopped, meaning that no meaningful improvements were being made. Let’s visualize the representation of the latent space learned by the VAE. Visualizing this representation is easy in this case because we defined the latent space to be two-dimensional; in other words, all points can be plotted on a Cartesian plane. Let’s take a look:  This plot shows us how each numbers are distributed across the latent space. Notice that numbers that belong to the same class seem to be generally clustered around each other, although there is a messy region in the middle. This is a reasonable result: while we would expect ones to be fairly easy to distinguish from, say, eights, numbers like zeros and sixes might look very similar, and hence appear mixed as a lump in the fuzzy region in the middle. One cool thing about VAEs is that we can use their learned representation to see how numbers slowly morph and vary across a specified domain.",0,0,0,0,1,0,1,0
A sneak peek at Bayesian Inference,"So far on this blog, we have looked the mathematics behind distributions, most notably binomial, Poisson, and Gamma, with a little bit of exponential. These distributions are interesting in and of themselves, but their true beauty shines through when we analyze them under the light of Bayesian inference. In today’s post, we first develop an intuition for conditional probabilities to derive Bayes’ theorem. From there, we  motivate the method of Bayesian inference as a means of understanding probability. Suppose a man believes he may have been affected with a flu after days of fever and coughing. At the nearest hospital, he is offered to undergo a clinical examination that is known to have an accuracy of 90 percent, i.e. it will return positive results to positive cases 90 percent of the time. However, it is also known that the test produces false positives 50 percent of the time. In other words, a healthy, unaffected individual will test positive with a probability of 50 percent. In cases like these, conditional probability is a great way to package and represent information. Conditional probability refers to a measure of the probability of an event occurring, given that another event has occurred.",0,1,0,0,0,1,0,0
Gaussian Process Regression,"However, once we add in Gaussian noise as we saw above with  where , then we need to make adjustments to the kerne to account for added variations. With some thinking, we can persuade ourselves that the only modification that is needed pertains to the diagonal entries of the covariance matrix. This is because  only affects variance that exists within the univariate Gaussian for each point on the -axis without affecting the non-diagonal entries, which otherwise pertain to covariance between two points. In other words, the new kernel matrix now becomes This can be seen as a minor correction to the kernel matrix to account for added Gaussian noise. Before we jump straight into code implementation, it’s necessary to discuss the Cholesky decomposition to get some technicality out of the way. The Cholesky decomposition is a specialization of the LDU decomposition, applied to symmetric matrices. The idea is that we can factor a symmetric matrix  as Let’s begin by considering the LDU decomposition of the  matrix. We know that for symmetric matrices, .",0,0,1,1,0,0,0,0
The Math Behind GANs,"In (6), we framed the function as a loss function to be minimized, whereas the original formulation presents it as a maximization problem, with the sign obviously flipped. Then, Goodfellow proceeds by framing (8) as a min-max game, where the discriminator seeks to maximize the given quantity whereas the generator seeks to achieve the reverse. In other words, The min-max formulation is a concise one-liner that intuitively demonstrates the adversarial nature of thecompetition between the generator and the discriminator. However, in practice, we define separate loss functions for the generator and the discriminator as we have done above.  This is because the gradient of the function  is steeper near  than that of the function , meaning that trying to maximize , or equivalently, minimizing  is going to lead to quicker, more substantial improvements to the performance of the generator than trying to minimize . Now that we have defined the loss functions for the generator and the discriminator, it’s time to leverage some math to solve the optimization problem, i.e. finding the parameters for the generator and the discriminator such that the loss functions are optimized. This corresponds to training the model in practical terms.",0,0,0,0,0,1,1,0
A Brief Introduction to Recurrent Neural Networks,"Firstly, what does this looping operation involve? Secondly, what is the purpose of having this loop in the first place? Let’s try to answer both questions in the following subsections. One of the most salient features of a recurrent neural network is that it is capable of emulating some primitive form of memory. Why might we want to do this? Well, take the example of reading a text. When we read, we don’t process a given text at once in its totality; instead, we break them down into pieces, such as a word or a bag of words, and build our understanding based on information obtained from the previous sequence of text. In other words, processing information through reading is at best understood as a process of continuously receiving new information while retaining information obtained from the previous sequence. This is why recurrent neural network models are frequently employed in the context of natural language processing. But the applications of RNNs extends beyond the domain of NLP. For example, say we are given a dataset of temperature recording of a city district. Obviously, the structural integrity of that dataset is very important, i.e.",0,0,0,0,1,0,1,0
A Simple Autocomplete Model,"Note that these unique characters not only include alphabets but also and other miscellaneous white spacing characters and punctuations. Let’s now design our model. Because there is obviously going to be sequential, temporal structure underlying the training data, we will use an LSTM layer, a type of advanced recurrent neural network we saw in the previous post. In fact, this is all we need, unless we want to create a deep neural network spanning multiple layers. However, training such a model would cost a lot of time and computational resource. For the sake of simplicity, we will build a simple model with a single LSTM layer. The output layer is going to be a dense layer with  number of neurons, activated with a softmax function. We can thus interpret the index of the biggest value of the final array to correspond to the most likely character. Below is a full plot of the model that shows the dimensions of the input and output tensors of all layers.  Now, all we have to do is to train the model with the data.",0,0,0,0,1,0,1,0
Convex Combinations and MAP,"In other words, Let’s assume that the random variable is normally distributed according to some parameter . We will assume that the standard deviation of the random variable is given as . We could have considered standard deviation to be a parameter, but since the goal of this demonstration is to conduct MAP estimation on the mean of the univariate Gaussian, we assume that the standard deviation is known. Next, we have to define a prior distribution for the parameter. Let’s say that  is also normally distributed around some mean  with a standard deviation of 1, as shown below. Recall that the goal of MAP is, as the same suggests, to maximize the posterior distribution. To derive the posterior, we need two ingredients: a prior and a likelihood function. We already have the first ingredient, the prior, as we have just defined it above. The last piece of the puzzle, then, is the likelihood function. Since we have assumed our data to be independently distributed, we can easily calculate the likelihood as follows: All that is left is to compute the posterior according to Baye’s formula for Bayesian inference. We can thus calculate the MAP estimate of  as shown below.",0,0,0,0,0,1,0,0
My First GAN,"Then, the connection between the generator and the discriminator is effectively established by the statement . All this is saying is that GAN’s output is the evaluation of the generator’s fake image by the discriminator. If the generator does well, it will fool the discriminator and thus output 1; 0 vice versa. Let’s take a look at the code implementation of this logic.  Now it’s time to train our model. Let’s first load our dataset. For this, we will be using the  images. The dataset contains low resolutions images, so our output is also going to be very rough, but it is a good starting point nonetheless. One hacky thing we do is concatenating the training and testing data. This is because for a GAN, we don’t need to differentiate the two: on the contrary, the more data we have for training, the better. One might suggest that testing data is necessary for the discriminator, which is a valid point, but the end goal here is to build a high performing generator, not the discriminator, so we will gloss over that point for now. For this tutorial, we will be using images of ships, which are labeled as 8.",0,0,0,0,1,0,1,0
Introduction to tf-idf,"Here is an easy contrived example we can do in our heads: And now we’re done! If let’s print the tf-idf vectors for each of the four documents in the dummy example. It seems about right, as all the vectors appear normalized and are of the desired dimensions. However, to really verify the result, it’s probably a good idea to pit our algorithm against scikit-learn’s implementation. In scikit-learn, the  does all the job. To transform the data to tf-idf vectors, we need to create an instance of the  and call its method, . And here are the results: There are several observations to be made about this result. First, note that the default return type of  is a sparse matrix. Sparse matrices are a great choice since many of the entries of the matrix will be zero—there is probably no document that contains every word in the corpus. Therefore, sparse representations can save a lot of space and compute time. This is why we had to call  on the result. Second, you might be wondering why the order of elements are different.",0,0,0,1,0,0,0,0
"PyTorch, From Data to Modeling","As you can see above, we basically call on the layers we’ve declared in the initialization function via  and pass in any parameters we want. Since this is a very simple CNN, you will see that there is nothing exciting going on; we are simply getting the output of the previous layer and passing that as input into the next. After going through some convolutions and fully connected layers, we can return the result. There are one caveats worth mentioning here, which is the use of . There is a  that I could have easily used, and indeed there is an entire discussion on the PyTorch forum on the difference between the two. The bottom line is that they are pretty similar for our purposes. The most salient difference between the two is that the functional approach cannot be used when declaring a sequential model. However, since we are defining a custom forward function, this limitation does not apply. Personally, I prefer the functional because it means that there is one less layer to declare in the initialization function. However, it’s probably better to err on the side of the  if you’re not totally sure.",0,0,0,0,0,0,1,0
Wonders of Monte Carlo,"I have been putting off with blog postsings lately, largely because I was preoccupied with learning new languages I decided to pick up out of whim. Although I’m still learning the basics of these languages, namely HTML, CSS, and Javascript, I’m enjoying the process. I still have no idea where this spontaneous journey will take me, but hopefully I can make use of it in one way or another. The topic for today’s post is Monte Carlo methods, something that I have been very interested in for a long time, admittedly because of its eye-catching name. Contrary to my original expectation, Monte Carlo is not named after an eponymous mathematician, but a gambling hot spot in Monaco. The logic behind this nomenclature is that the simulation of random outcomes, such as in the context of an unpredictable gambling game, is what Monte Carlo methods are best suited for. To present a more formal definition, Monte Carlo methods refer to a broad category of  algorithms that use repeated random sampling to make estimations of unknown parameters. Basically, MC methods work by cleverly sampling from a distribution to estimate a variable of interest.",0,0,0,0,0,1,0,0
InceptionNet in PyTorch,"The standard, go-to kernel size is three-by-three, but we never know if a five-by-five might be better or worse. Instead of engaging in time-consuming hyperparameter tuning, we let the model decide what the optimal kernel size is. Specifically, we throw the model three options: one-by-one, three-by-three, and five-by-five kernels, and we let the model figure out how to weigh and process information from these kernels. In the  below, you will see that there are indeed various branches, and that the output from these branches are concatenated to produce a final output in the  function. Researchers who conceived the InceptionNet architecture decided to add auxiliary classifiers to intermediary layers of the model to ensure that the model actually learns something useful. This was included in InceptionV1; as far as I’m aware, future versions of InceptionNet do not include auxiliary classifiers. Nonetheless, I’ve added it here, just for the fun of it. Now we finally have all the ingredients needed to flesh out the entire model. This is going to a huge model, but the code isn’t too long because we’ve abstracted out many of the building blocks of the model as  or .",0,0,0,0,0,0,1,0
An Introduction to Markov Chain Monte Carlo,"Finally, here is the post that was promised ages ago: an introduction to Monte Carolo Markov Chains, or MCMC for short. It took a while for me to understand how MCMC models work, not to mention the task of representing and visualizing it via code. To add a bit more to the excuse, I did dabble in some other topics recently, such as machine learning models or information theory, which is also partially why this post was delayed quite a bit. Nevertheless, it’s finally here and ready to go. In this post, we will take a look at the Metropolis-Hastings algorithm, the simplest variant among the family of MCMC models. Let’s see what the Bayesian hype is all about. It’s been a while since we last discussed Bayesian inference, so it’s probably a good idea to start with a brief recap. Bayesian statistics commences from Bayes’ theorem, a seminal statement in probability theory that can be expressed as follows Alternatively, Bayes’ theorem can be stated more generally in the context of some partitioned sample space, For simplicity, I omit the equation for the case involving continuous random variables.",0,0,0,1,0,0,0,0
Markov Chain and Chutes and Ladders,"For example if , there are only three probabilities: , , and , each of values , , and  respectively. The  statements are additional corrective mechanisms to account for this irregularity. So now we’re done with the stochastic matrix! … or not quite. Things get a bit more complicated once we throw the chutes and ladders into the mix. To achieve this, we first build a dictionary containing information on the jump from one cell to another. In this dictionary, the keys correspond to the original position; the values, the index of the cell after the jump, either through a chute or a ladder. For example,  represents the first ladder on the game board, which moves the player from the first cell to the thirty eighth cell. To integrate this new piece of information into our code, we need to build a permutation matrix that essentially “shuffles up” the entries of the stochastic matrix  in such a way that the probabilities can be assigned to the appropriate entries.",0,0,0,0,0,0,0,1
"Newton-Raphson, Secant, and More","Another interesting observation is that the secant method seems to take slightly longer than the Newton-Raphson method. This is probably due to the fact that the secant method uses backward divided difference, and also the fact that it requires two previous at each iteration instead of one. The reason why the first update seems rather ineffective is that the two initial guesses that we fed into the model was probably not such a good starting point. The topic of today’s post was somewhat different from what we had previously dealt with in this blog, but it was an interesting topic for me nonetheless. I had encountered the Newton-Raphson method previously when going down my typical Wikipedia rabbit holes, but it is only today that I feel like I’ve finally got a grasp of the concept. I consider this post to be a start of many more posts on numerical methods to come. I hope you’ve enjoyed reading this post. See you in the next one.",1,0,0,0,0,0,0,0
Convex Combinations and MAP,"Simply put, a convex combination is a linear combination of different points or quantities in which the coefficients of the linear combinations add up to one. More concretely, We can also imagine that  and  are each -dimensional vectors, and that a convex combination is simply a dot product of these two vectors given that the elements of  sum up to one. Why did I suddenly bring up convex combinations out of no where? Well, it turns out that the result in (9) in fact an instance of a convex combination of two points satisfying the form Indeed, it is not difficult to see that the coefficient of  and  add up to 1, which is precisely the condition for a linear combination to be considered convex. Now here is the important part: the implication of this observation is that we can consider the MAP estimate of parameter  as an interpolation, or more simply, some weighted average between  and . This interpretation also aligns with the whole notion of Bayesian inference: our knowledge of the parameter is partially defined by the prior, but updated as more data is introduced.",0,0,0,0,0,1,0,0
Natural Gradient and Fisher,"In this case, however, we’re simply using KL divergence as a means of measuring distance between two parameters in defined within a distribution space. As nicely stated in layman’s term in this Medium article, … instead of “I’ll follow my current gradient, subject to keeping the parameter vector within epsilon distance of the current vector,” you’d instead say “I’ll follow my current gradient, subject to keeping the distribution my model is predicting within epsilon distance of the distribution it was previously predicting” I see this as an intuitive way of nicely summarizing why we’re using KL divergence in searching the distribution space, as opposed to using Euclidean distance in searching the parameter space. Now it’s time for us to connect the dots between KL divergence and Fisher’s matrix. Before we diving right into computations, let’s think about how or why these two concepts might be related at all. One somewhat obvious link is that both quantities deal with likelihood, or to be more precise, log likelihood.",0,0,1,0,0,1,0,0
Demystifying Entropy (And More),"This is an important distinction to make, because entropy is essentially a probabilistically weighted average of all the random events that a random variable can take. In other words, entropy is defined as the weighted average of information given by each random event: For the continuous case, we would use an integral instead. Say  denotes the random variable of interest in a fair coin toss. Then, we are most interested in how much bits, on average, we would need to encode information generated from the distribution of this random variable. Using (3), we can easily answer this question by calculating the follows: This tells us that the entropy involved in a fair coin toss is 1 bit, i.e, on average, we only need a single digit of binary number to encode information given by a fair coin toss. But how might this number change for a biased coin? We would not expect the entropy of the random variable given by the result of a biased coin to be 1. For example, consider a coin that always lands on heads.",0,0,0,0,0,1,0,0
A Simple Autocomplete Model,"3: is a woman–what then? is there not ground
 for suspecting that the experience and present strange of the soul is also as the stand of the most profound that the present the art and possible to the present spore as a man and the morality and present self instinct, and the subject that the presence of the surcessize, and also it is an action which the philosophers and the spirit has the consider the action to the philosopher and possess and the spirit is not be who can something the predicess of the constinate the same and self-interpatence, the disconsises what is not to be more profound, as if it is a man as a distance of the same art and ther strict to the presing to the result the problem of the present the spirit what is the consequences and the development of the same art of philosophers and security and spirit and for the subjective in the disturce, as in the contrary and present stronger and present could not be an inclination and desires of the same and distinguished that is the discoverty in such a person itself influence and ethers as Generated text at temperature 0.",0,0,0,0,1,0,1,0
Gaussian Process Regression,"For the sake of simplicity, however, we will only take a look at one such kernel that relates to smoothness: the squared exponential kernel, often referred to as the RBF kernel. The distance function of the squared exponential kernel looks as follows: We can apply distortions to the RBF function by adding things like coefficients, but for simplicity sake we omit them here. The key takeaway is that the RBF kernel function functions as a distance metric between two points. As an extreme example, let’s consider the case when , the diagonal entries of the covariance matrix, which is effectively the variance along those components. Then, Conversely, when  and  are extremely different points, We can thus deduce that the distance function returns a value between 0 and 1 that indicates the similarity or closeness between two points. This is exactly the sort of behavior we want for the covariance matrix. In short, the multivariate Gaussian that we will be using for GP regression can simply be summarized as where covariance  denotes the kernel matrix. In the RBF kernel function above, we were assuming a function without any noise, namely that .",0,0,1,1,0,0,0,0
Moments in Statistics,"As you can see, the common theme is that the moment contains information about the defining features of a distribution, which is why it is such a convenient way to present information about a distribution. As the name suggests, MGF is a function that generates the moments of a distribution. More specifically, we can calculate the th moment of a distribution simply by taking the th derivative of a moment generating function, then plugging in 0 for parameter . We will see what  is in a moment when we look at the default formula for MGF. This sounds good and all, but why do we want an MGF in the first place, one might ask. Well, given that moments convey defining properties of a distribution, a moment generating function is basically an all-in-one package that contains every bit of information about the distribution in question. Enough of the abstract, let’s get more specific by taking a look at the mathematical formula for an MGF. If  is a continuous random variable, we would take an integral instead. Now, you might be wondering how taking the th derivative of  gives us the th moment of the distribution for the random variable .",0,1,0,0,0,1,0,0
"PyTorch, From Data to Modeling","Now that we’ve designed and implemented a model, it’s time to train it. This is the part where people might argue that TensorFlow 2 or Keras is superior to PyTorch. In Keras, you can simply call  to train the model. However, in PyTorch, this is not necessarily the case, unless you really want to imitate the Keras API and define a  function yourself. PyTorch is more low-level in that you need to define a custom training loop manually. However, I actually prefer this low-levelness because it requires me to really think through what is happening in each iteration, namely what the dimension of each batch is, what the model expects to receive as input in the forward computation, and what loss function is appropriate given the output and label. Let’s see what all of this means. First, we begin by actually initializing an instance of the model, a loss function named , and an , which is Adam in this case. A quick note of caution: if you dig into the PyTorch documentation or look at other example classifiers, you will realize, like me, there are two loss functions you can typically use:  and , or negative log likelihood loss.",0,0,0,0,0,0,1,0
Building Neural Network From Scratch,"With all the complex math behind, here is the code implementation of back propagation. Finally, our model is ready to be trained! Here is a simple function which we can use to train and test our model. Because each iteration can yield a different accuracy, we repeat the experiment multiple times—or specifically,  times—to obtain the mean accuracy of our model. We also get a standard deviation of the mean accuracy estimate to see whether or not the performance of the model is reliable and consistent. Let’s test our model with the  and  data, with batch size set to 10. The mean accuracy of our model is around 95 percent, which isn’t bad for a simple neural network with just two layers. The standard deviation is also reasonably low, indicating that the performance of our model is consistent with little variations. I was almost about to stop here, but then decided that I wanted to express the neural network model as a Python class. After all, that is how actual machine learning and deep learning libraries are implemented. I also decided that it can’t hurt for me to practice object-oriented thinking.",0,0,0,1,0,0,1,1
Word2vec from Scratch,"After all, the dimension of the gradient must equal to the dimension of the original matrix. With that in mind, let’s implement the backpropagation function. To keep a log of the value of the error throughout the backpropagation process, I decided to make the final return value of  to be the cross entropy loss between the prediction and the target labels. The cross entropy loss function can easily be implemented as follows. Now we’re ready to train and test the model! As we only have a small number of training data—coupled with the fact that the backpropagation algorithm is simple batch gradient descent—let’s just iterate for 50 epochs. While training, we will be caching the value of the cross entropy error function in a  list. We can then plot this result to get a better sense of whether the training worked properly.  And indeed it seems like we did well! We can thus say with some degree of confidence that the embedding layer has been trained as well. An obvious sanity check we can perform is to see which token our model predicts given the word “learning.",0,0,0,1,0,0,1,0
The Magic of Euler’s Identity,"Let’s plug  into the Taylor polynomial for : Notice that we can separate the terrms with and without : In short, ! With this generalized equation in hand, we can plug in  into  to see Euler’s identity: The classic proof, although fairly straightforward, is not my favorite mode of proving Euler’s identity because it does not reveal any properties about the exponentiation of an imaginary number, or an irrational number for that matter. Instead, I found geometric interpretations of Euler’s formula to be more intuitive and thought-provoking. Below is a version of a proof for Euler’s identity. Let’s start by considering the complex plane. There are two ways of expressing complex numbers on the Argand diagram: points and vectors. One advantage of the vector approach over point representation is that we can borrow some simple concepts from physics to visualize  through the former: namely, a trajectory of a point moving along the complex plane with respect to some time parameter . Notice that introducing this new parameter does not alter the fundamental shape or path of the vector ; it merely specifies the speed at which the particle is traversing the complex plane.",1,0,0,0,0,0,0,0
PyTorch Tensor Basics,"Not only do the two functions look similar, they also practically do the same thing. Upon more observation, however, I realized that there were some differences, the most notable of which was the .  seemed to be unable to infer the data type from the input given. On the other hand,  was sable to infer the data type from the given input, which was a list of integers. Sure enough,  is generally non-configurable, especially when it comes to data types. can accept  as a valid argument. The conclusion of this analysis is clear: use  instead of . Indeed, this SO post also confirms the fact that  should generally be used, as  is more of a super class from which other classes inherit. As it is an abstract super class, using it directly does not seem to make much sense. In PyTorch, there are two ways of checking the dimension of a tensor:  and . Note that the former is a function call, whereas the later is a property. Despite this difference, they essentially achieve the same functionality. To access one of the  elements, we need appropriate indexing.",0,0,0,0,0,0,1,0
So What are Autoencoders?,"Now that the training is over, what can we do with this autoencoder? Well, let’s see if the autoencoder is now capable of removing noise from tainted image files. But before we jump right into that, let’s first build a simple function that displays images for our convenience. Using the  function, we can now display 25 test images that we will feed into the autoencoder.  Let’s add noise to the data.  Finally, the time has come! The autoencoder will try to “denoise” the contaminated images. Let’s see if it does a good job.  Lo and behold, the autoencoder produces pristine images, almost reverting them back to their original state! I find autoencoders interesting for two reasons. First, they can be used to compress images into lower dimensions. Our original image was of size 28-by-28, summing up to a total of 784 pixels. Somehow, the autoencoder finds ways to decompress this image into vectors living in the predefined 128 dimensions. This is interesting in and of itself, since it presents ways that we might be able to compress large files with minimal loss of information.",0,0,0,0,1,0,1,0
Natural Gradient and Fisher,"In a previous post, we took a look at Fisher’s information matrix. Today, we will be taking a break from the R frenzy and continue our exploration of this topic, meshing together related ideas such as gradient descent, KL divergence, Hessian, and more. The typical formula for batch gradient descent looks something like this: This is the familiar gradient descent algorithm that we know of. While this approach works and certainly makes sense, there are definite limitations; hence the introduction of other more efficient algorithms such as SGD, Adam, and et cetera. However, these algorithms all have one thing in common: they adjust the parameter in the parameter space according to Euclidean distance. In other words, gradient descent essentially looks at regions that are some Euclidean distance away from the current parameter and chooses the direction of steepest descent.",0,0,1,0,0,1,0,0
How lucky was I on my shift?,"If we divide our time frame of interest into infinite segments, smaller even than microseconds, we can theoretically model multiple successful events, which is something that the binomial distribution could not account for. Intuitively speaking, this approach is akin to modeling a continuous function as infinitely many stepwise functions such that two “adjacent” dots on the graph could be considered as identical points—or, in probabilistic terms, a simultaneous event. And because we have infinitely many trials and only a fixed number of success, this necessarily means that  would approach 0. Although this value may seem odd, the argument that the probability of receiving a call at this very instant is 0, since “instant” as a unit of time is infinitely short to have a clearly defined probability. From an algebraic standpoint,  is necessary to ensure that , the expected number of success, converges to a real value. Now let’s derive the Poisson formula by tweaking the PMF for a binomial distribution. We commence from this expression: We can substitute  for  from the definition: Using the definition of combinatorics, Recall that  can alternately be defined as .",0,1,0,0,0,1,0,0
k-Nearest Neighbors Algorithm from Scratch,"But this is a rather tedious job, and things would get quickly out of control if we were to deal with much larger data sets where the value of  can be set to much larger numbers. Instead, let’s create a visualization to see how accuracy changes with respect to .  The plot shows that accuracy is maximized for many values of , not just 1. Also, we can learn that accuracy does not go beyond the 97 percent we saw earlier, which is a bit of sad news. An interesting insight we can glean, however, is that accuracy seems to drop past some certain thresholds, most notably around 80. One reasonable explanation might be that the model is looking at too many neighbors that it cannot produce a reliable estimate. At any rate, this visualization shows that hyperparameter tuning is an important job of a machine learning engineer—even if the model is great, if the wrong  value is used, the model will only demonstrate lackluster performance. This was perhaps the first post where we dealt with a machine learning algorithm. ML is sometimes treated as a black box, where some magic beneath the hood produces desirable results.",0,0,1,1,0,0,0,0
A PyTorch Primer,"We will also need some input and output tensors to be fed into the model for trainining and optimization. Next, here are the weight matrices we will use. For now, we assume a simple two layered dense feed forward network. Last but not least, let’s define a simple squared error loss function to use during the training step. With this entire setup, we can now hash out what the entire training iteration is going to look like. Wrapped in a loop, we perform one forward pass, then perform backpropagation to adjust the weights. Great! We see that the loss drops as more epochs elapse. While there is no problem with this approach, things can get a lot more unwieldy once we start building out more complicated models. In these cases, we will want to use the auto differentiation functionality we reviewed earlier. Let’s see this in action. Also, let’s make this more PyTorch-y by making use of classes. We will revisit why class-based implementations are important in the next section. Notice we didn’t have to explicitly specify the backpropagation formula with matrix derivatives: by simply calling  properties for each of the weights matrices, we were able to perform gradient descent.",0,0,0,0,0,0,1,0
Traveling Salesman Problem with Genetic Algorithms,"Specifically, we can have things like  to represent the full population,  to represent th chosen, selected superior few,  to store the score of the best chromosome in the population,  to store the best chromosome itself, and , the adjacency matrix that we will be using to calculate the distance in the context of TSP. Here is a little snippet of code that we will be using to randomly generate the first generation of population. Let’s see if this everything works as expected by generating a dummy population. Now we need some function that will determine the fitness of a chromosome. In the context of TSP, fitness is defined in very simple terms: the shorter the total distance, the fitter and more superior the chromosome. Recall that all the distance information we need is nicely stored in . We can calculate the sum of all the distances between two adjacent cities in the chromosome sequence. Next, we evaluate the population.",0,0,0,1,0,0,0,0
A sneak peek at Bayesian Inference,"It is also worth noting that the Beta function, which serves as a coefficient in the equation for the Beta PDF, serves as a normalization constant to ensure that integrating the function over the domain  would yield 1 as per the definition of a PDF. To see this, one needs to prove This is left as an exercise for the keen reader. We will revisit this problem in a separate post. Another reason why the Beta distribution is an excellent choice for our prior representation is that it is a conjugate prior to the binomial distribution. Simply put, this means that using the Beta distribution as our prior, combined with a binomial likelihood function, will produce a posterior  that also follows a Beta distribution. This fact is crucial for Bayesian analysis. Recall that the beauty of Bayesian inference originates from repeated applicability: a posterior we obtain after a single round of calculation can be used as a prior to perform the next iteration of inference. In order to ensure the ease of this procedure, intuitively it is necessary for the prior and the posterior to take the same form of distribution.",0,1,0,0,0,1,0,0
"0.5!: Gamma Function, Distribution, and More","We are almost done! Now that we have the expression for the harmonic series, we can plug it back into the original equation on  to finish off this derivation. Integrate both sides by  to obtain the following: Exponentiate both sides by  to remove the logarithm, and we finally get the alternative representation of the Gamma function: So we see that there are many other alternate modes of expressing the same function, . But the truth that remains unchanged is that the Gamma function is essentially a more expansive definition of the factorial that allows for operations on any real numbers. There are many concepts and theories surrounding the Gamma function, such as the Euler-Mascheroni constant, Mellin transformation, and countless many more, but these might be tabled for another discussion as they each deserve a separate post. The Gamma distribution is, just like the binomial and Poisson distribution we saw earlier, ways of modeling the distribution of some random variable . Deriving the probability density function of the Gamma distribution is fairly simple. We start with two parameters,  and , using which we can construct a Gamma function.",0,1,0,0,0,1,0,0
"Beta, Bayes, and Multi-armed Bandits","It is of course in this learning process that the greedy algorithm or Bayesian analysis with Thompson sampling comes into play. The amount that we have theoretically lost—or, in other words, the extent to which we are far away from the maximum amount we could have earned—is denoted as regret. Thus, to maximize reward is to minimize regret, and vice versa. Now let’s simulate a hundred pulls on the lever using Bayesian analysis using the Beta-Binomial model and Thompson sampling. Nothing much fancy here, all we’re doing is Thompson sampling from the Beta distribution via , then obtaining the index of the bandit with the highest parameter, then pulling the machine that corresponds to that index. We will also keep cumulative track of our results to reproduce the regret diagram shown above. And we’re done with the hundred round of simulations! Hopefully our simulator gambler has made some good choices by following Bayesian update principles, with the Beta-Binomial model and Thompson sampling under their belt. Let’s take a look at the posterior distribution for each bandit. We can easily plot them using , as shown below. Notice that I have also included the uniform prior for reference purposes.",0,1,0,0,0,1,0,0
The Magic of Euler’s Identity,"At a glance, Euler’s identity is a confusing, mind-boggling mishmash of numbers that somehow miraculously package themselves into a neat, simple form: I remember staring at this identity in high school, trying to wrap my head around the seemingly discordant numbers floating around the equation. Today, I want to share some ideas I have learned since and demonstrate the magic that Euler’s identity can play for us. The classic proof for Euler’s identity flows from the famous Taylor series, a method of expressing any given function in terms of an infinite series of polynomials. I like to understand Taylor series as an approximation of a function through means of differentiation. Recall that a first-order derivative gives the slope of the tangent line at any given point of a function. The second-order derivative provides information regarding the convexity of the function. Through induction, we can convince ourselves that higher order derivatives will convey information about the curvature of the function throughout coordinate system, which is precisely the underlying mechanism behind Taylor’s series. In a more concise notation, we have Notice that  is the starting point of our approximation.",1,0,0,0,0,0,0,0
The Gibbs Sampler,"The result is what we would expect: a bivariate Gaussian.  And this is what we end up with if we sample directly from the bivariate Gaussian instead of using the Gibbs sampler. Note that we can do this only because we chose a deliberately simple example; in many other contexts, this would certainly not be the case (if we could sample from a distribution directly, why use the Gibbs sampler in the first place?). Notice the similarity between the result achieved by sampling from the Gibbs sampler and the result produced from direct sampling as shown below.  So at this point, we have now empirically checked that Gibbs sampling indeed works: even if we can’t directly sample from the distribution, if we have access to conditional distributions, we can still achieve an asymptotically similar result. Now comes the mathematics portion of deriving the conditional distribution of a multivariate Gaussian, as promised earlier. In this section, we will derive an expression for the conditional distribution of the multivariate Gaussian. This isn’t really relevant to the Gibbs sampling algorithm itself, since the sampler can be used in non-Gaussian contexts as long as we have access to conditional distributions.",0,0,0,0,0,1,0,1
k-Nearest Neighbors Algorithm from Scratch,"For the most part, it seems like our predicted result is quite similar to the actual labels. But there are some samples that our KNN algorithm missed, such as the 27th data point: although its actual label is 2, our model predicted it to be 1. We can mathematically calculate the accuracy of our model by using the following function. The job of this function is quite simple: it goes through the two lists, element by element, and checks if the two values are identical. See the implementation below. The accuracy of our prediction turns out to be about 97 percent. But can we do better? Recall that we arbitrarily chose  to be 10 when we initialized the KNN algorithm. Would accuracy increase if we set the parameter to another number? Let’s try to answer this question by generating a list of accuracy scores for each value of  ranging from 1 to 100. We can achieve this by building a function as shown below. Passing 100 to the  argument results in a list of accuracy scores. We can go through this list and try to see for which value of  accuracy is maximized.",0,0,1,1,0,0,0,0
Naive Bayes Model From Scratch,"The true power of naive Bayes is not limited to the task of classificaiton, however. In fact, it is used in many fields, most notably natural language processing. Perhaps we might look into the possible applications of naive Bayes in the context of NLP in a future post. But for now, this level of modeling will do. Thanks for reading. See you in the next post!.",0,0,1,1,0,0,0,0
Complex Fibonacci,"With this in mind, let’s go ahead and try to plot the interpolation of the fibonacci sequence on the complex plane. First, we import the modules we will need. Then, we simply specify the domain on the real number line and generate the fibonacci numbers, separating out the real and imaginary components. Note that  is not going to be used for plotting; instead, we use  as the -axis, and this is where the loss of temporal information comes in, as mentioned earlier. Now, let’s go ahead and plot it out!  And there it is, the full fibonacci sequence, interpolated across the real numbers. When I first saw this pattern in Matt Parker’s video, I was simply in awe, a loss of words. There’s something inexplicably beautiful and wonderful at this pattern, almost as if it was some part of God’s plan. Okay, maybe I’m being too melodramatic about a graph, but there is no denying that this pattern is geometrically interesting and pleasing to the eye. Everything looks so intentional and deliberate. The comments on the aesthetics of the snail shell aside, one point that deserves our attention is what appears to be a straight line.",1,0,0,0,0,0,0,0
Logistic Regression Model from Scratch,"As we saw earlier with the application of the model to the task of bank notes authentication, the logistic regression model can, when tweaked with the appropriate parameters, make surprisingly accurate predictions given sufficient amount of training data. Of course, the processing of training and tweaking is not always easy because we have to determine some hyperparameters, most notably the learning rate of the gradient descent algorithm, but the fact that logistic regression is a robust model is unchanged nonetheless. Hopefully this post gave you some idea of what happens behind the scene in a regression-based machine learning model. Thanks for reading. See you in the next post, and happy new year!.",0,0,1,1,0,0,0,0
A Brief Introduction to Recurrent Neural Networks,"Neural networks are powerful models that can be used to identify complex hidden patterns in data. There are many types of neural networks, two of which we have seen already on this blog: the vanilla, feed-forward neural network and convolutional neural networks, often abbreviated as convnets. Today, we will add a third kind to this exciting mix: recurrent neural networks, or RNNs. Let’s take a brief conceptual look at how recurrent neural networks work, then implement a toy RNN to see how it compares to other models on the IMDB movie reviews dataset. I heavily borrowed my examples from Deep Learning with Python by François Chollet and the tutorial on text classification available from the official TensorFlow documentation. Recurrent neural networks, as the name implies, refer to neural network models that contain some sort of internal looping structure that simulates a flow of information. A good way to conceptualize this loop is to think of something like  loops, where a certain operation is performed repeatedly for a specified number of cycles. Given these pieces of information, we might ask ourselves two questions.",0,0,0,0,1,0,1,0
k-Nearest Neighbors Algorithm from Scratch,"If among the 10 neighbors observed, 8 of them have the label 0 and 2 of them are labeled 1, the KNN algorithm will conclude that the label of the provided data is most likely also going to be 0. As we can see, the KNN algorithm is extremely simple, but if we have enough data to feed it, it can produce some highly accurate predictions. There are still missing pieces to this puzzle, such as how to find the nearest neighbors, but we will explore the specifics of the algorithm on the go as we build the model from scratch. For now, just remember the big picture. Let’s get into the nuts and bolts of the KNN model. Below are the dependencies we will need for this demonstration. One problem we need to start thinking about is how to measure distance between two data points. After all, the implementation of KNN requires that we define some metric to measure the proximity between different points, rank them in order, and sort the list to find  nearest neighbors.",0,0,1,1,0,0,0,0
A sneak peek at Bayesian Inference,"In this situation, the parameter that is of interest to us can be expressed as In other words, given a positive test result, what is the probability that the man is actually sick? However, we have no means as of yet to directly answer this question; the two pieces of information we have are that , and that . To calculate the value of , we need Bayes’s theorem to do its trick. Let’s quickly derive Bayes’ theorem using the definition of conditional probabilities delineated earlier. Recall that Multiply  and  on both sides of (1) and (2) respectively to obtain the following result: Notice that the two equations describe the same quantity, namely . We can use equivalence to put these two equations together in the following form. Equation (3) can be manipulated in the following manner to finally produce a simple form of Bayes’ theorem: We can motivate a more intricate version this rule by modifying the denominator. Given that  and  are discrete events, we can break down  as a union of intersections between  and , where  represents subsets within event .",0,1,0,0,0,1,0,0
The Exponential Family,"Normal, binomial, exponential, gamma, beta, poisson… These are just some of the many probability distributions that show up on just about any statistics textbook. Until now, I knew that there existed some connections between these distributions, such as the fact that a binomial distribution simulates multiple Bernoulli trials, or that the continuous random variable equivalent of the geometric distribution is the exponential. However, reading about the concept of the exponential family of distributions has lent me new insight, and I wish to share that renewed understanding on probability distributions through this post. In this section, we will take a look at what the exponential family of distributions is all about. We will begin by laying out a few mathematical definitions, then proceed to see examples of probability distributions that belong to the exponential family. To cut to the chase, the exponential family simply denotes a  group of probability distributions that satisfy a certain condition, namely that they can be factorized and parametrized into a  specific form, as show below: Here,  is a log noramlizing constant that ensures that the probability distribution integrates to 1. There are other alternative forms that express the same factorization.",0,1,0,0,0,1,0,0
"Newton-Raphson, Secant, and More","Then, we obtain the -intercept of that tangent line, and repeat the process we’ve just completed by starting on a point on the graph whose -value is equal to that -intercept. The following image from Wikipedia illustrates this process quite well. (A digression: It’s interesting to see how “function” and “tangent” are written in German—in case you are wondering, I don’t know a word of German.)  Mathematically, the Newton-Raphson method can be expressed recursively as follows: Deriving this formula is quite simple. Say we start at a point on the graph, . The tangent line from that point will have a slope of . Therefore, the equation of the tangent line can be expressed as Then, the -intercept can simpy be obtained by finding an  value that which makes . Let  denote that point. Then, we arrive at the following update rule. Since we will be using  as the value for the next iteration, , and now we have the update rule as delineated in (4). Below is an implementation of the Newton-Raphson method in Python. I’ve added some parameters to the function for functionality and customization.",1,0,0,0,0,0,0,0
BLEU from scratch,"For instance, BLEU is able to account for situations in which meaningless words are repeated throughout the machine translation to simply increase BOW hits. It can also penalize translations that are too short. By combining this BOW precision-based approach with some penalization terms, BLEU provides a robust means of evaluating machine translations. With this high-level overview in mind, let’s start implementing BLEU from scratch. First, let’s begin by defining some simple preprocessing and helper functions that we will be using throughout this tutorial. The first on the list is , which converts a given sentence into lowercase and splits it into tokens, which are, in this case, English words. We could make this more robust using regular expressions to remove punctuations, but for the purposes of this demonstration, let’s make this simpler. I decided to use anonymous functions for the sake of simplicity and code readability. Next, let’s write a function that creates n-grams from a given sentence. This involves tokenizing the given sentence using , then looping through the tokens to create a bag of words. And here is a quick sanity check of what we’ve done so far.",0,0,0,1,0,0,1,0
Gaussian Mixture Models,"Quite simply, the probability that a data point belongs to the th cluster is represented by . The last step to data generation, as outlined in the bullet points above, is sampling a point from the corresponding Gaussian. where  and  are the mean and covariance matrices that parameterize the th Gaussian in the mixture model. Now that we have an idea of how GMMs can serve as a generative model that describes the underlying data generation process, let’s think about the marginal probability—that is, the probability that some point  in the sample space was generated by the GMM. After all, what we observe is the final output, not the latent variables. Therefore, it would be convenient to be able to come up with some expression for the marginal distribution. We can come up with a simple expression using the law of total probability and marginalization. where  can take values between 1 and . Notice that we can thus simplify , as this is simply the categorical distribution for the mixing coefficients. In other words, We can also simplify the condition probability expression, since we already know that it follows a normal distribution.",0,0,1,0,0,1,0,0
Dissecting the Gaussian Distribution,"We established some rough intuition by associating various matrix calculus operations and their single-variable calculus analogues. Let’s try to use this intuition as a pivot point to extend the univariate Gaussian model to the multivariate Gaussian. For readability sake, here is the univariate model we have derived earlier. Examining (7), the first observation we might make is that  is no longer a coherent expression in the multivariable context. The fix to this is extremely simple: recall that in vector world. Therefore, we can reexpress (7) as This is the result of simply changing the squared term. Continuing, the next subject of our interest would be , as the variance is only strictly defined for one variable, as expressed by its definition below: where  is a random variable, which takes a scalar value. This necessarily begs the question: what is the multivariable equivalent of variance? To answer this question, we need to understand covariance and the covariance matrix. To jump right into the answer, the multivariable analogue of variance is covariance, which is defined as Notice that  equals variance, which is why we stated earlier that covariance is the multivariate equivalent of variance for univariate quantities.",0,1,0,0,0,1,0,0
VGG PyTorch Implementation,"Of course, there still is a constraint, which is that the  and  parameters must be multiples of 32. Let’s roll out the model architecture by taking a look at VGG19, which is the deepest architecture within the VGG family. If we print the model, we can see the deep structure of convolutions, batch norms, and max pool layers. We can clearly see the two submodules of the network: the convolutional portion and the fully connected portion. Now let’s see if all the dimensions and tensor sizes match up. This quick sanity check can be done by passing in a dummy input. This input represents a 3-channel 224-by-224 image. Passing in this dummy input and checking its shape, we can verify that forward propagation works as intended. And indeed, we get a batched output of size , which is expected given that the input was a batch containing two images. Just for the fun of it, let’s define  and see if it is capable of processing rectangular images. Again, we can pass in a dummy input. This time, each image is of size .",0,0,0,0,0,0,1,0
Demystifying Entropy (And More),"What actually happened beneath the hood? If we recall the definition of cross entropy, we can easily see that, among the 10 terms, 9 of them were eliminated since  given the setup of the distribution . In the end, the only term that mattered was the third term, which was given by Why does this quantity make sense as an error term defining a loss function? In other words, why is cross entropy used as a loss function in classification tasks? To see this, let’s assume that our neural network was perfect in its prediction, or more realistically, trained to excessively overfit given data, i.e,  equals . Then, cross entropy would have been calculated as Indeed, we can use our function to verify the coherency of this statement. In other words, when our predicted distribution equals the true distribution we are trying to model, cross entropy becomes 0, as a desirable cost function would behave. This is why crosss entropy is often used in classification models where we have a one-hot encoded vector that represents a true distribution, as exemplified by , and a prediction that models this distribution, denoted as  in our example.",0,0,0,0,0,1,0,0
Dissecting LSTMs,"This is a lot simpler: These gradients, of course, will be passed onto the next iteration of backpropagation, just like we had assumed that the values of  and  were given from the previous sequence of backpropagation. Because DL libraries make it extremely easy to declare and train LSTM networks, it’s often easy to gloss over what actually happens under the hood. However, there is certainly merit to dissecting and trying to understand the inner-working of DL models like LSTM cells, which offer a fascinating way of understanding the notion of memory. This is also important since RNNs are the basis of other more complicated models such as attention-based models or transformers, which is arguably the hottest topic these days in the field of NLP with the introduction of GPT-3 by OpenAI. I hope you have enjoyed reading this post. Catch you up in the next one!.",0,0,0,0,0,0,1,0
Introduction to tf-idf,"Although I’ve been able to automate some portion of the blog workflow, there’s always been a challenging part that I wanted to further automate myself using deep learning: automatic tagging and categorization. Every post requires some form of YAML front matter, containing information such as the title, tag, and category of the blog post to be uploaded. Although I sometimes create new tags or categories if existing ones seem unfit, I only deal with a limited number of topics on this blog, which is why I’ve always thought that some form of supervised learning be able to automate the process by at least generating some possible tags for me. I’m currently in the process of preparing the data (my previous blog posts) and building a simple NLP document classification model for the job. However, NLP is a field that I’m admittedly not well-acquainted with, not to mention the fact that I’ve not bee posting a lot about deep learning implementations for a while now. So in today’s short post, I decided to write about tf-idf vectorization, which is a very simple yet powerful technique that is often used in routine tasks like document classification, where SOTA models aren’t really required.",0,0,0,1,0,0,0,0
Dissecting the Gaussian Distribution,"The intuition we can develop from looking at the equation is that covariance measures how far our random variables are from the mean in the  and  directions. More concretely, covariance is expresses the degree of association between two variables. Simply put, if there is a positive relationship between two variables, i.e. an increase in one variable results in a corresponding increase in the other, the variance will be positive; conversely, if an increase in one variable results in a decrease in the other, covariance will be negative. A covariance of zero signifies that there is no linear relationship between the two variables. At a glance, the concept of covariance bears strong resemblance to the notion of correlation, which also explains the relationship between two variables. Indeed, covariance and correlation are related: in fact, correlation is a function of covariance. The biggest difference between correlation and covariance is that correlation is bounded between -1 and 1, whereas covariance is unbounded. The bottom line is that both correlation and covariance measure the strength of linearity between two variables, with correlation being a normalized version of covariance.",0,1,0,0,0,1,0,0
My First GAN,"As Ian Goodfellow described in the paper where he first put out the notion of a GAN, generators are best understood as counterfeiters of currency, whereas the discriminator is the police trying to distinguish the fake from the true. In other words, a GAN is a two-component model that involves an internal tug-of-war between two adversarial parties, each trying their best to accomplish their mission. As this competition progresses, the generator becomes increasingly better at creating fake images; the discriminator also starts to excel at determining the veracity of a presented image. Enough of theoretical dwellings, let’s begin by defining the generator model. The  is a function that returns a generator model according to some set parameters. Let’s take a look at the structure of this network in more detail.  Notice that the output of the generator is a batch image of dimensions . This is exactly the same as the , , and  information we defined earlier, and that is no coincidence: in order to fool the discriminator, the generator has to generate images that are of the same dimensions as the training images from ImageNet.",0,0,0,0,1,0,1,0
Understanding the  Leibniz Rule,"But fear not, let’s apply the same approach to answer this question. This may appear to be a lot of computation, but all we’ve done is just separating out the integrals while paying attention to the domains of integration. Let’s continue by doing the same for the remaining terms. The first two terms in the limit go away since  goes to zero. While the same applies to the fractional terms, one difference is that they are also divided by , which is why they remain. We have simplified quite a bit, but we still have two terms in the limit expression that we’d like to remove. We can do this by applying the definition of the integral. And we’re done! There are other ways of seeing the Leibniz rule, such as by interpreting it as a corollary of the Fundamental Theorem of Calculus and the Chain rule, as outlined in here (by a Professor at Yale!), but I find the geometrically motivated interpretation presented in this article to be the most intuitive. I hope you enjoyed reading this post. Catch you up in the next one!.",1,0,0,0,0,0,0,0
Building Neural Network From Scratch,"As you can see, the generated points belong to either one of two classes, and together, each class of points seem to form some sort of moon-like shape. Our goal will be to build a neural network that is capable of determining whether a given point belongs to class 0 or class 1. In other words, this is a classic example of a binary classification problem. It is standard practice in any classification problem to convert class labels into one-hot encodeded vectors. The reason why this preprocessing is necessary is that the class number is merely a label that does not carry any meaning. Assume a simple classification problem with 3 labels: 0, 1, and 2. In that context, a class label of 2 is not at all related to adding two data points belonging to class 1, or any arithmatic operation of that kind. To prevent our model from making such arbitrary, unhelpful connections, we convert class labels to one-hot encoded vectors. We could use external libraries such as  to invoke the  function, but instead let’s just build a function ourselves since this is a relatively simple task. Let’s test the  function on the training data.",0,0,0,1,0,0,1,1
Naive Bayes Model From Scratch,"The variant that we will implement today is called the Gaussian naive Bayes classifer, because we assume that the distribution of the feature variables, denoted as , is normal. For a corresponding explanation of this model on , refer to this documentation. Let’s jump right into it. As per convention, we start by importing necessary modules for this tutorial. For reproducability, we specify a . The  magic commands are for the configuration of this Jupyter Notebook. Let’s begin by building some toy data. To make things simple, we will recycle the toy data set we used in the previous post on logistic regression and k-nearest neighbors. The advantage of using this data set is that we can easily visualize our data since all instances live in . In other words, we only have two axes:  and . For convenience, we preprocess our toy data set and labels into  arrays. The first step is to separate the data set by class values, since our goal is to find the distributions for each class that best describe the given data through MAP.",0,0,1,1,0,0,0,0
PyTorch RNN from Scratch,"Put more simply, we want to be able to tell where a particular name is from. We will be using some labeled data from the PyTorch tutorial. We can download it simply by typing This command will download and unzip the files into the current directory, under the folder name of . Now that we have downloaded the data we need, let’s take a look at the data in more detail. First, here are the dependencies we will need. We first specify a directory, then try to print out all the labels there are. We can then construct a dictionary that maps a language to a numerical label. We see that there are a total of 18 languages. I wrapped each label as a tensor so that we can use them directly during training. Let’s store the number of languages in some variable so that we can use it later in our model declaration, specifically when we specify the size of the final output layer. Now, let’s preprocess the names. We first want to use  to standardize all names and remove any acute symbols or the likes.",0,0,0,1,0,0,1,0
MLE and KL Divergence,"After all, it’s been a while since I’ve written the linked posts, and for a fruitful, substantive discussion on this topic, it’s necessary to make sure that we have a solid grasp of what MLE and KL divergence are. MLE is a technique used to find the optimal parameter of a distribution that best describes a set of data. To cut to the chase, this statement can be expressed as follows: From here, we can start making assumptions, such as that observations in  are i.i.d, which is the assumption that we make to build models such as naïve Bayes, and so on. For now, it suffices to clarify that the goal of maximum likelihood estimation is to find the optimal parameter of a distribution that best captures some given data. KL divergence is a concept that arises from the field of information theory that is also heavily applied in statistics and machine learning. KL divergence is particularly useful because it can be used to measure the dissimilarity between to probability distributions.",0,0,0,0,0,1,0,0
A Brief Introduction to Recurrent Neural Networks,"One immediate pattern we see is that the model seems to be overfitting right away, since the testing accuracy decreases with each epoch while the training accuracy increases. This is certainly not a good sign; in the best case scenario, we want to see that training and testing labels moving in the same direction. Perhaps this is the biggest indication that a simple feed forward network is a suboptimal model choice in the context of this problem.  The graphs for the  model seems a lot better. At the very least, we see the training and test labels moving in unison: the accuracy increases with each epoch, while the loss slowly decreases. However, we do see some overfitting happening at the last two epochs or so. Specifically, note that cross entropy loss for the testing data seems to pick up an incrementing pattern past the seventh epoch. This observation suggests that we need to configure the model differently, presumably by decreasing the number of tunable parameters.  Next comes the winner of the day, the LSTM network.",0,0,0,0,1,0,1,0
Maximum A Posteriori Estimation,"Given the nature of the derived MAP formula in (5), constants can safely be ignored as it will not contribute to argument maximization in any way. Concretely, Therefore, in the case of a uniform prior, we see that MAP essentially boils down to MLE! This is an informative result that tells us that, at their core, MLE and MAP seek to perform the same operation. However, MAP, being a Bayesian approach, takes a specified prior into account, whereas the frequenting MLE simply seeks to dabble in data only, as probabilities are considered objective results of repeated infinite trials instead of subjective beliefs as a Bayesian statistician would purport. I hope you enjoyed reading this post. See you in the next one!.",0,0,0,0,0,1,0,0
So What are Autoencoders?,"In today’s post, we will take yet another look at an interesting application of a neural network: autoencoders. There are many types of autoencoders, but the one we will be looking at today is the simplest variant, the vanilla autoencoder. Despite its simplicity, however, there is a lot of insight to glean from this example—in fact, it is precisely the simplicity that allows us to better understand how autoencoders work, and potentially extend that understanding to to analyze other flavors of autoencoders, such as variational autoencoder networks which we might see in a future post. Without further ado, let’s get started. We begin by importing all modules and configurations necessary for this tutorial. How do autoencoders work? There are entire books dedicated to this topic, and this post in no way claims to introduce and explore all the fascinating complexities of this model. However, one intuitive way to understand autoencoders is to consider them as, lo and behold, encoders that map complex data points into vectors living in some latent dimension. For example, a 28-by-28 pixel RGB channel image might be compressed into a five-dimensional latent vector.",0,0,0,0,1,0,1,0
