title,body,from_scratch,statistics,pytorch,machine_learning,linear_algebra,probability_distribution,deep_learning,analysis
Moments in Statistics,"The word “moment” has many meanings. Most commonly, it connotes a slice of time. In the realm of physics, moment refers to the rotational tendency of some object, similar to how torque measures the change in an object’s angular momentum. As statisticians, however, what we are interested in is what moment means in math and statistics. In this post, we will attempt to shed new light on the topic of probability distributions through moment generating functions, or MGF for short. The mathematical definition of moments is actually quite simple. And of course, we can imagine how the list would continue: the th moment of a random variable would be . It is worth noting that the first moment corresponds to the mean of the distribution, . The second moment is related to variance, as . The third moment relates to the symmetry of the distribution, or the lack thereof, a quality which goes by the name of skewness. The fourth moment relates to kurtosis, which is a measure of how heavy the tail of a distribution is. Higher kurtosis corresponds to many outliers, while the converse would signify that the distribution contains little deviations. As you can see, the common theme is that the moment contains information about the defining features of a distribution, which is why it is such a convenient way to present information about a distribution. As the name suggests, MGF is a function that generates the moments of a distribution. More specifically, we can calculate the th moment of a distribution simply by taking the th derivative of a moment generating function, then plugging in 0 for parameter . We will see what  is in a moment when we look at the default formula for MGF. This sounds good and all, but why do we want an MGF in the first place, one might ask. Well, given that moments convey defining properties of a distribution, a moment generating function is basically an all-in-one package that contains every bit of information about the distribution in question. Enough of the abstract, let’s get more specific by taking a look at the mathematical formula for an MGF. If  is a continuous random variable, we would take an integral instead. Now, you might be wondering how taking the th derivative of  gives us the th moment of the distribution for the random variable . To convince ourselves of this statement, we need to start by looking at the Taylor polynomial for the exponential. It’s not difficult to see the coherency of this expression by taking its derivative—the derivative of the polynomial is equal to itself, as we would expect for . From here, we can sufficiently deduce that The coherency of (3) can simply be seen by making the substitution . To continue, now that we have an expression for , we can now calculate , which we might recall is the definition of a moment generating function. where the second equality stands due to linearity of expectation. All the magic happens when we derive this function with respect to . At , all terms in (5) except for the very first one go to zero, leaving us with In other words, deriving the MGF once and plugging in 0 to  leaves us with the first moment, as expected. If we derive the function again and do the same, And by induction, we can see how the th derivative of the MGF at  would give us the th moment of the distribution, . The easiest way to demonstrate the usefulness of MGF is with an example. For fun, let’s revisit a distribution we examined a long time ago on this blog: the Poisson distribution. To briefly recap, the Poisson distribution can be considered as an variation of the binomial distribution where the number of trials, , diverges to infinity, with rate of success defined as . This is why the Poisson distribution is frequently used to model how many random events are likely in a given time frame. Here is the probability distribution of the Poisson distribution. Note that  denotes the number of occurrences of the random event in question. The task here is to obtain the mean of the distribution, i.e. to calculate the first moment, . The traditional, no-brainer way of doing this would be to refer to the definition of expected values to compute the sum Computing this sum is not difficult, but it requires some clever manipulations and substitutions. Let’s start by simplifying the factorial in the denominator, and pulling out some expressions out of the sigma. where the third equality stands due to the variant of the Taylor series for the exponential function we looked at earlier: Therefore, we have confirmed that the mean of a Poisson distribution is equal to , which aligns with what we know about the distribution. Another way we can calculate the first moment of the Poisson is by deriving its MGF. This might sound a lot more complicated than just computing the expected value the familiar way demonstrated above, but in fact, MGFs are surprisingly easy to calculate, sometimes even easier than using the definition expectation. Let’s begin by presenting a statement of the MGF. Let’s factor out terms that contain lambda, which is not affected by the summation. Again, we refer to equation (9) to realize that the sigma expression simplifies into an exponential. In other words, From this observation, we can simplify equation (10) as follows: And there is the MGF of the Poisson distribution! All we have to do to obtain the first moment of the Poisson distribution, then, is to derive the MGF once and set  to 0. Using the chain rule, At , So we have confirmed again that the mean of a Poisson distribution is equal to . Let’s take another distribution as an example, this time the exponential distribution. We have not looked specifically at the exponential distribution in depth previously, but it is a distribution closely related to the , which we derived in this post. Specifically, when parameter  in a Gamma distribution, it is in effect an exponential distribution. Perhaps we will explore these relationships, along with the Erlang distribution, in a future post. For now, all we have to know is the probability density function of the exponential distribution, which is This time, the task is to obtain the third moment of the distribution, i.e. . But the fundamental approach remains identical: we can either use the definition of expected values to calculate the third moment, or compute the MGF and derive it three times. At a glance, the latter seems a lot more complicated. However, it won’t take long for us to see that sometimes, calculating the MGF is sometimes as easy as, if not easier than, taking the expected values approach. Let’s twist up the order and try the MGF method first. We can pull out the lambda and combine the exponential terms to get This is an easy integral. Let’s proceed with the integration and evaluation sequence: Now, all we have to do is to derive the result in (12) three time and plug in . Although calculating the third order derivative may sound intimidating, it may seem easier in comparison to evaluating the integral which would require us to use integration by parts. In the end, both (12) and (13) are pointing at the same quantity, namely the third moment of the exponential distribution. Perhaps the complexity of calculating either quantity is similar, and the question might just boil down to a matter of preference. However, this example shows that the MGF is a robust method of calculating moments of a distribution, and even more, potentially less computationally expensive than using the brute force method to directly calculate expected values. This was a short post on moments and moment generating functions. Moments was one of these terms that I had come across on Wikipedia or math stackexchange posts, but never had a chance to figure out. Hopefully, this post gave you some intuition behind the notion of moments, as well as how moment generating functions can be used to compute useful properties that explain a distribution. In the next post, we will take a brief break from the world of distributions and discuss some topics in information theory that I personally found interesting. If you would like to dwell on the question like “how do we quantify randomness,” don’t hesitate to tune in again in a few days!",0,1,0,0,0,1,0,0
The Math Behind GANs,"Generative Adversarial Networks refer to a family of generative models that seek to discover the underlying distribution behind a certain data generating process. This distribution is discovered through an adversarial competition between a generator and a discriminator. As we saw in an earlier introductory post on GANs, the two models are trained such that the discriminator strives to distinguish between generated and true examples, while the generator seeks to confuse the discriminator by producing data that are as realistic and compelling as possible. In this post, we’ll take a deep dive into the math behind GANs. My primary source of reference is Generative Adversarial Nets by Ian Goodfellow, et al. It is in this paper that Goodfellow first outlined the concept of a GAN, which is why it only makes sense that we commence from the analysis of this paper. Let’s begin! GAN can be seen as an interplay between two different models: the generator and the discriminator. Therefore, each model will have its own loss function. In this section, let’s try to motivate an intuitive understanding of the loss function for each. To minimize confusion, let’s define some notation that we will be using throughout this post. The goal of the discriminator is to correctly label generated images as false and empirical data points as true. Therefore, we might consider the following to be the loss function of the discriminator: Here, we are using a very generic, unspecific notation for  to refer to some function that tells us the distance or the difference between the two functional parameters. (If this reminded you of something like cross entropy or Kullback-Leibler divergence, you are definitely on the right track.) We can go ahead and do the same for the generator. The goal of the generator is to confuse the discriminator as much as possible such that it mislabels generated images as being true. The key here is to remember that a loss function is something that we wish to minimize. In the case of the generator, it should strive to minimize the difference between 1, the label for true data, and the discriminator’s evaluation of the generated fake data. A common loss function that is used in binary classification problems is binary cross entropy. As a quick review, let’s remind ourselves of what the formula for cross entropy looks like: In classification tasks, the random variable is discrete. Hence, the expectation can be expressed as a summation. We can simplify this expression even further in the case of binary cross entropy, since there are only two labels: zero and one. This is the  function that we have been loosely using in the sections above. Binary cross entropy fulfills our objective in that it measures how different two distributions are in the context of binary classification of determining whether an input data point is true or false. Applying this to the loss functions in (1), We can do the same for (2): Now we have two loss functions with which to train the generator and the discriminator! Note that, for the loss function of the generator, the loss is small if  is close to 1, since . This is exactly the sort of behavior we want from a loss function for the generator. It isn’t difficult to see the cogency of (6) with a similar approach. The original paper by Goodfellow presents a slightly different version of the two loss functions derived above. Essentially, the difference between (6) and (8) is the difference in sign, and whether we want to minimize or maximize a given quantity. In (6), we framed the function as a loss function to be minimized, whereas the original formulation presents it as a maximization problem, with the sign obviously flipped. Then, Goodfellow proceeds by framing (8) as a min-max game, where the discriminator seeks to maximize the given quantity whereas the generator seeks to achieve the reverse. In other words, The min-max formulation is a concise one-liner that intuitively demonstrates the adversarial nature of thecompetition between the generator and the discriminator. However, in practice, we define separate loss functions for the generator and the discriminator as we have done above.  This is because the gradient of the function  is steeper near  than that of the function , meaning that trying to maximize , or equivalently, minimizing  is going to lead to quicker, more substantial improvements to the performance of the generator than trying to minimize . Now that we have defined the loss functions for the generator and the discriminator, it’s time to leverage some math to solve the optimization problem, i.e. finding the parameters for the generator and the discriminator such that the loss functions are optimized. This corresponds to training the model in practical terms. When training a GAN, we typically train one model at a time. In other words, when training the discriminator, the generator is assumed as fixed. We saw this in action in the previous post on how to build a basic GAN. Let’s return back to the min-max game. The quantity of interest can be defined as a function of  and . Let’s call this the value function: In reality, we are more interested in the distribution modeled by the generator than . Therefore, let’s create a new variable, , and use this substitution to rewrite the value function: The goal of the discriminator is to maximize this value function. Through a partial derivative of  with respect to , we see that the optimal discriminator, denoted as , occurs when Rearranging (12), we get And this is the condition for the optimal discriminator! Note that the formula makes intuitive sense: if some sample  is highly genuine, we would expect  to be close to one and  to be converge to zero, in which case the optimal discriminator would assign 1 to that sample. On the other hand, for a generated sample , we expect the optimal discriminator to assign a label of zero, since  should be close to zero. To train the generator, we assume the discriminator to be fixed and proceed with the analysis of the value function. Let’s first plug in the result we found above, namely (12), into the value function to see what turns out. To proceed from here, we need a little bit of inspiration. Little clever tricks like these are always a joy to look at. If you are confused, don’t worry, you aren’t the only one. Basically, what is happening is that we are exploiting the properties of logarithms to pull out a  that previously did not exist. In pulling out this number, we inevitably apply changes to the terms in the expectation, specifically by dividing the denominator by two. Why was this necessary? The magic here is that we can now interpret the expectations as Kullback-Leibler divergence: And it is here that we reencounter the Jensen-Shannon divergence, which is defined as where . This means that the expression in (15) can be expressed as a JS divergence: The conclusion of this analysis is simple: the goal of training the generator, which is to minimize the value function , we want the JS divergence between the distribution of the data and the distribution of generated examples to be as small as possible. This conclusion certainly aligns with our intuition: we want the generator to be able to learn the underlying distribution of the data from sampled training examples. In other words,  and  should be as close to each other as possible. The optimal generator  is thus one that which is able to mimic  to model a compelling model distribution . In this post, we took a brief tour of the math behind general adversarial networks. Since the publication of Goodfellow’s work, more GAN models have been introduced and studied by different scholars, such as the Wasserstein GAN or CycleGAN to name just a few. The underlying mathematics for these models are obviously going to be different from what we have seen today, but this is a good starting point nonetheless. I hope you enjoyed reading this post. In the next post, I plan to explore the concept of Fisher information and the Fisher matrix. It is going to be another math-heavy ride with gradients and Hessians, so keep you belts fastened!",0,1,0,0,0,0,1,0
Building Neural Network From Scratch,"Welcome back to another episode of “From Scratch” series on this blog, where we explore various machine learning algorithms by hand-coding them from scratch. So far , we have looked at various machine learning models, such as kNN, logistic regression, and naive Bayes. Now is time for an exciting addition to this mix: neural networks. Around last year December, I bought my first book on deep learning, titled Deep Learning from Scratch,  by Saito Goki. It was a Korean translation of a book originally published in Japanese by O’Reilly Japan. Many bloggers recommended the book as the go-to introductory textbook on deep learning, some even going as far as to say that it is a must-have. After reading a few pages in, I could see why: as the title claimed, the author used only  to essentially recreate deep learning models, ranging from simple vanilla neural networks to convolutional neural networks. As someone who had just started to learn Python, following the book was a lot harder than expected, but it was a worthwhile read indeed. Inspired by that book, and in part in an attempt to test the knowledge I gained from having read that bok, I decided to implement my own rendition of a simple neural network supported by minibatch gradient descent. Let’s jump right into it. The default setup of my Jupyter Notebook, as always: Before we start building our model, we should first prepare some data. Instead of using hand-made dummy data as I had done in some previous posts, I decided to use the  library to generate random data points. This approach makes a lot more sense given that neural networks require a lot more input data than do machine learning models. In this particular instance, we will use the  function to accomplish this task. Let’s take a look at what our data looks like. As expected, the dataset contains the  and  coordinates of the points generated by the  function. If you haven’t heard about this function before, you might be wondering what all the moons deal is about. Well, if we plot the data points, it will become a lot more obvious.  As you can see, the generated points belong to either one of two classes, and together, each class of points seem to form some sort of moon-like shape. Our goal will be to build a neural network that is capable of determining whether a given point belongs to class 0 or class 1. In other words, this is a classic example of a binary classification problem. It is standard practice in any classification problem to convert class labels into one-hot encodeded vectors. The reason why this preprocessing is necessary is that the class number is merely a label that does not carry any meaning. Assume a simple classification problem with 3 labels: 0, 1, and 2. In that context, a class label of 2 is not at all related to adding two data points belonging to class 1, or any arithmatic operation of that kind. To prevent our model from making such arbitrary, unhelpful connections, we convert class labels to one-hot encoded vectors. We could use external libraries such as  to invoke the  function, but instead let’s just build a function ourselves since this is a relatively simple task. Let’s test the  function on the training data. We don’t need the entire data to see that it works, so let’s slice the  array to see its first five elements. When we apply  to the data, we see that the returned result is a two-dimensional array containing one-hot encoded vectors, as intended. That’s all the data and the preprocessing we will need for now. Activation functions are important aspects of neural networks. In fact, it is what allows neural networks to model nonlinearities in data. As we will see in the next section, a neural network is essentially composed of layers and weights that can be expressed as matrix multiplications. No matter how complex a matrix may be, matrix multiplication is a linear operation, which means that is impossible to model nonlinearities. This is where activation functions kick in: by applying nonlinear transformation to layer outputs, we can make neural networks capable of modeling nonlinearities. This is why deep learning is such a powerful tool: it can be trained to detect nonlinear, complex patterns in data that a human might otherwise be unable to identify. Our vanilla neural network will make use of two activation functions: softmax and ReLU. If you have read my previous post on the Keras functional API, you might recall that we used softmax and ReLU for certain dense layers. Back then, we considered them to be a blackbox without necessarily taking a look at what they do. Let’s explore the details and get our hands dirty today. Mathematically speaking, the softmax function is a function that takes a vector as input and outputs a vector of equal length. Concretely, where Although the formula may appear complex, the softmax function is a lot simpler than it seems. First, note that all  entries of the returned vector  add up to 1. From here, it is possible to see that the softmax function is useful for ascribing the probability that a sample belongs to one of  classes: the -th element of  would indicate the probability of the sample belonging to the -th class. Put another way, the index of the largest entry in  is the class label number that is most probable. Implementing the softmax function is extremely easy thanks to the vectorized computation made possible through . Presented below is one possible implementation of the softmax function in Python. This particular implementation, however, poses two problems. First, it is susceptible to arithematic overflow. Because computing the softmax function require exponentiation, it is likely for the computer to end up with very large numerical quantities, making calculations unstable. One way to solve this problem is by subtracting values from the exponent. As the calculation shows, adding or subtracting the same value from the exponent of both the numerator and the denominator creates no difference for the output of the softmax function. Therefore, we can prevent numbers from getting too large by subtracting some value from the exponent, thus yielding accurate results from stable computation. We can further improve the softmax function for the purposes of this tutorial by supporting batch computation. By batch, I simply mean multiple inputs in the form of arrays. The function shown above is only able to account for a single vector, presumably given as a list or a one-dimensional numpy array. The implementation below uses a loop to calculate the softmax output of each instance in a matrix input, then returns the result. Note that it also prevents arithematic overflow by subtracting the  value of the input array. Let’s test the improved softmax function with a two-dimensional array containing two instances. As expected, the softmax function returns the softmax output applied to each individual instance in the list. Note that the elements of each output instance add up to one, as expected. Another crucial activation function is ReLU, or the rectified linear unit. ReLU is a piece-wise function, and hence introduces nonlinearity, which is one of the purposes of having an activation function in a neural network. The formula for ReLU is extremely simple. If the input value  i s greater or equal to zero, the ReLU function outputs the value without modification. However, if  is smaller than zero, the returned value is also zero. There are other ways of expressing the ReLU function. One version that is commonly used and thus deserves our attention is written below. Although this appears different from (3), both formulas express the same operation at their core. We can get a better sense of what the function with the help of Python. Assuming that the input is a  vector, we can use vectorization to change only the elements in the input vector that are negative to zero, as shown below. Let’s see what the ReLU function looks like by plotting it on the plane.  The visualization makes clear the point that ReLU is a piece-wise function that flattens out negative values while leaving positive values unchanged. Now that we have all the ingredients ready, it’s time to build the neural network. Earlier, I said that a neural network can be reduced to matrix multiplication. This is obviously an oversimplification, but there is a degree of truth to that statement. Recall that a single neuron of a neural network can be expressed as a dot product of two vectors, as shown below. Following conventional notation,  represents weights; , input data; , bias. Visually, we can imagine the neuron being lit up when the value  is large.  This is similar to how the human brain works, except that biological neurons are binary in that they either fires on or off; artifical neurons in a network typically take a range of values. If we expand the vector operation in (5), it becomes quickly obvious that we can represent an entire layer of neurons as a product of two matrices. Our simple neural network model can thus be expressed as follows: The equations above represent our simple neural network model composed of two affine layers. The output of the first affine layer, , is modified by a ReLU unit. Then, the output is passed onto the second affine layer, , the output of which is passed onto a softmax unit. The output of the softmax function is the final output of our model. Note that ReLU and softmax are denoted as max and sigma, respectively. The code below is a function that intializes our network. Because our  data only has two classes, with each data point containing two entries corresponding to the  and  coordinates of that point, we set both  and  arguments to 2 by default. The number of neurons in the affine layers, denoted as , is arbitrarily set to 64. The  returns a dictionary that contains all the weights of the model. Note that we need to pay close attention to the dimensionality of our data to ensure that matrix multiplication is possible. We don’t have to worry about the dimensionality of the bias since  supports broadcasting by default. Presented below is a visualization of our neural network, created using NN-SVG. Instead of cluttering the diagram by attempting to visualize all 64 neurons, I decided to simplify the picture by assuming that we have 16 neurons in each of the affine layers. But with the power of imagination, I’m sure it’s not so much difficult to see how the picture would change with 64 neurons.  Hopefully the visualization gave you a better understanding of what our model looks like. Now that we have a function that creates our model, we are ready to run the model! At this point, our neural network model is only a dictionary that contains matrices of specified sizes, each containing randomly genereated numbers. You might be wondering how a dictionary can be considered a model—after all, a dictionary is merely a data structure, and so is incapable of performing any operations. To make our model to work, therefore, we need a function that performs matrix multiplications and applies activation functions based on the dictionary. The  function is precisely such a function that uses the weights stored in our model to return both the intermediary and final outputs, denoted as  and  respectively.  Note that we apply activation functions, such as  and  when appropriate. This process of deriving an output from an input using a neural network is known as forward propagation. Forward propagation is great and all, but without appropriately trained weights, our model is obviously going to spit out meaningless predictions. The way to go about this is to use the gradient descent algorithm with back propagation. We will discuss more about back propagation in the next subsection, as it is a meaty topic that deserves space of its own. We deal primarily with the former in this section. This is not the first time that we have come across gradient descent on this blog. In fact, we used gradient descent to optimizse our logistic regression model in this post. Recall that the gradient descent algorithm can be summarized as where  represents the parameters, or weights,  represents the learning rate, and  represents the loss function. This is the vanilla gradient descent algorithm, which is also referred to as batch gradient descent. Minibatch gradient descent is similar to gradient descent. The only point of difference is that it calculates the gradient for each minibatch instead of doing so for the entire dataset as does batch gradient descent. The advantage of using a minibatch is that it is computationally lighter and less expensive. Minibatch gradient descent can be considered a happy point of compromise between stochastic and batch gradient descent, which lie on the polar opposite ends of the spectrum. Let’s first take a look at the  function, which divides the  and  into  and  given a . Internally, the  function calls the  gradient descent algorithm to update the weights and finally returns the  which contains updated parameters based on the training data. As mentioned above, each  and  are minibatches that will be feeded into our  gradient descent function. Note that the  function is simply an implementation of equation (7). At the core of the  function is the  function, which is our implementation of back propagation. This provides a nice point of transition to the next section. Back propagation is a smart way of calculating gradients. There are obviously many ways one might go about gradient calculation. We can simply imagine there being a loss function that is a function of all the thousands of weights and biases making up our neural network, and calculate partial derivatives for each parameter. However, this naive aproach is problematic because it is so computationally expensive. Moreover, if you think about it for a second, you might realize that doing so would result in duplicate computations due to the chain rule. Take the simple example below. If we were to calculate the gradient of the loss function with respect to  and , all we need to compute is the gradient of , since that of  will naturally be obtained along the way. In other words, computing the gradient simply requires that we start from the very end of the neural network and propagate the gradient values backwards to compute the partial derivatives according to the chain rule. This is what is at the heart of back propagation: in one huge swoop, we can obtain the gradient for all weights and parameters at once instead of having to calculate them individually. For a more detailed explanation of  this mechanism, I strongly recommend that you take a look at this excellent blog post written by Christopher Olah. How do we go about back propagation in the case of our model? First, it is necessary to define a loss function. The most commonly used loss function in the context of classification problems is cross entropy, which we explored in this post previously on this blog. For a brief recap, presented below is the formula for calculating cross entropy given a true distribution  and a predicted distribution : Our goal is to train our neural network so that is output distribution  is as close to  as possible. In the case of binary classification, we might alter equation (9) to the following form: The reformulation as shown in equation (10) is the formula for what is known as binary cross entropy. This is the equation that we will be using in the context of our problem, since the dataset we have only contains two class labels of 0 and 1. Now that we have an idea of what the loss function looks like, it’s time to calculate the gradient. Since we are going to be back propagating the gradient, it makes sense to start from the very back of the neural network. Recall that our neural network is structured as follows: The last layer is a softmax unit that receives input  to produce output . Our goal, then, is to compute the gradient where  and  each represent the values taken by the th and th neuron in layers  and , respectively. One point of caution is that it is important to consider whether  and  are equal, as this produces differences in the calculation of the gradient. First consider the case when : When : We see that the gradient is different in the two cases! This is certainly going to important for us when calculating the gradient of , the cross entropy loss function, with respect to . Specifically, we have to consider the two cases separately by dividing up the summation expression into two parts, as shown below: That was a long ride, but in the end, we end up with a very nice expression! This tells us that the gradient of the cross entropy loss function with respect to the second affine layer is simply the size of the error term. In other words, if we expand the result in (13) to apply to the entire matrix of layers, we get This provides a great place for us to start. We can commence from here to find the gradient of the loss function with respect to other layers more further down the neural network. For example, we can calculate the gradient with respect to the weights of the second affine layer as follows: We won’t get into much mathematical details here, but a useful intuition we can use to derive equation (15) is to pay close attention to the dimensionality of data. Note that the dimension of the gradient as a matrix should equal to that of the layer itself. In other words, , so on and so forth. This is because the purpose of gradient computation is to update the matrix of parameters: to perform an element-by-element update with the gradient, it must necessarily be true that the dimensionality of the gradient equals that of the original matrix. Using this observation, it is possible to navigate through the confusion of transposes and left, right matrix multiplication that one might otherwise encounter if they were to approach it without any intuition or heuristics. To expedite this post, I’ll present the result of the gradient calculations for all parameters below. Note that the indicator function, denoted as , is a simple gate function that calculates the gradient of the ReLU unit: It isn’t difficult to see that the indicator function is simply a derivative of the ReLU function as shown in equation (3). Now, it is time to translate our findings into Python. Because our neural network model is represented as a dictionary, I decided to adopt the same data structure for the gradient. Indeed, that is how we designed the  function above. The  function below is an implementation of back propagation that encapsulates equations (14) through (17). There is a subtlety that I did not discuss previously, which has to do with the bias terms. It may appear as if the gradient of the bias term does not match that of the bias term itself. Indeed, that is a valid observation according to equation (16). The way we go about this is that we add up the elements of the matrix according to columns. This is exactly what we do with the  command invoked when computing  and , which represent the gradient of the bias terms. With all the complex math behind, here is the code implementation of back propagation. Finally, our model is ready to be trained! Here is a simple function which we can use to train and test our model. Because each iteration can yield a different accuracy, we repeat the experiment multiple times—or specifically,  times—to obtain the mean accuracy of our model. We also get a standard deviation of the mean accuracy estimate to see whether or not the performance of the model is reliable and consistent. Let’s test our model with the  and  data, with batch size set to 10. The mean accuracy of our model is around 95 percent, which isn’t bad for a simple neural network with just two layers. The standard deviation is also reasonably low, indicating that the performance of our model is consistent with little variations. I was almost about to stop here, but then decided that I wanted to express the neural network model as a Python class. After all, that is how actual machine learning and deep learning libraries are implemented. I also decided that it can’t hurt for me to practice object-oriented thinking. So presented in the next section is a nicer, cleaner implementation of a neural network model based off of the functions we designed above. A simple neural network model in just 56 lines of code, ready to be initialized, trained, deployed, and tested! You will see that much of the code is literally just copy and pasted from the original functions we designed above. But just to make sure that everything works fine, let’s try creating a neural network object and use the  function to see how well our model performs. I chose 99 as the number of neurons in the affine layers for no reason. In this instance, the accuracy of this model is 95 percent, similar to what we had above. At this point, one question that popped up in my mind was the relationship between the number of neurons and the performance of the neural network model. Intuitively, the more neurons there are, the higher the memory capacity of that model, and thus better the performance. Of course, the larger the number of neurons, the larger the risk of overfitting our model, which can also negatively impact the performance of the neural network. This is conventional wisdom in the land of deep learning. Let’s create a function to plot the performance of a neural network and the number of its neurons. Below is a  function that achieves this task. The function receives , , and  as arguments. The first two arguments specify the range for the number of neurons that we are interested in. For example, if we set them to 3 and 40, respectively, that means we want to see the accuracy of models with number of neurons ranging from 3 to 40 in a single layer. The  argument specifies the number of experiments we want to conduct. This way, we can calculate the mean accuracy, just as we did previously. Let’s call the function to create a plot.  The result shows that the performance of the neural network generally increases as the number of neurons increase. We don’t see signs of overfitting, but we know it happens: recall that our neural network model with 99 and 64 hidden neurons hit an accuracy of about 95 percent, whereas the model with only 30 to 40 neurons seem to be outperforming this metric by an accuracy hovering around 98 percent. After having realized this, I considered re-running the  function with a different range, but eventuially decided to stop the experiment  because running the  function took a lot more time than I had expected, even on Google Colab. Creating and training the model takes a long time, especially if we are repeating this process  times. For now, the simple observation that the performance seems to increase with more neurons, then fall at one point once overfitting starts to happen, will suffice to satisfy our curiosity. In this post, we built a neural network only using  and math. This was a lot more difficult than building other machine learning models from scratch particularly because of the heavy mathematics involved. However, it was definitely worth the challenge becasue completing and writing up this tutorial made me think a lot more about the clockwork of a neural network model. It is easy to think of neural networks as a black box, especially given the sheer ease of creating it. With just , one can build a simple neural network like this one in no time. Indeed, the main reason why I love the Keras functional API so much is that it is so easy to code and deploy a neural network model. However, when we write such models by depending on preexisting libraries, we sometimes grow oblivious to the intricacies the take place under the hood. It is my hope that reading and following along this post gave you a renewed sense of respect for the writers of such libraries, as well as the beauty of neural network models themselves. I hope you enjoyed reading this post. Catch you up in the next one!",1,0,0,0,1,0,1,0
How lucky was I on my shift?,"At the Yongsan Provost Marshall Office, I receive a wide variety of calls during my shift. Some of them are part of routine communications, such as gate checks or facility operation checks. Others are more spontaneous; fire alarm reports come in from time to time, along with calls from the Korean National Police about intoxicated soldiers who get involved in mutual assault or misdemeanors of the likes. Once, I got a call from the American Red Cross about a suicidal attempt of a soldier off post. All combined, I typically find myself answering about ten to fifteen calls per shift. But yesterday was a special day, a good one indeed, because I received only five calls in total. This not only meant that USAG-Yongsan was safe and sound, but also that I had a relatively light workload. On other days when lawlessness prevails over order, the PMO quickly descends into chaos—patrols get dispatched, the desk sergeant files mountains of paperwork, and I find myself responding to countless phone calls while relaying relevant information to senior officials, first sergeants, and the Korean National Police. So yesterday got me thinking: what is the probability that I get only five calls within a time frame of eight hours, given some estimate of the average number of calls received by the PMO, say 12? How lucky was I? One way we might represent this situation is through a binomial distribution. Simply put, a binomial distribution simulates multiple Bernoulli trials, which are experiments with only two discrete results, such as heads and tails, or more generally, successes and failures. A binomial random variable  can be defined as the number of success in  repeated trials with probability of success . For example, if we perform ten tosses of a fair coin, the random variable would be the number of heads;  would be , and  would be . Mathematically, the probability distribution function of a binomial distribution can be written as follows: We can derive this equation by running a simple thought experiment. Let’s say we are tossing a coin ten times. How can we obtain the probability of getting one head and nine tails? To begin with, here is the list of all possible arrangements: Notice that all we had to do was to choose one number  that specifies the index of the trial in which a coin toss produced a head. Because there are ten ways of choosing a number from integers  to , we got ten different arrangements of the situation satisfying the condition . You might recall that this combinatoric condition can be expressed as , which is the coefficient of the binomial distribution equation. Now that we know that there are ten different cases, we have to evaluate the probability that each of these cases occur, since the total probability , where . Calculating this probability is simple: take the first case,  as an example. Assuming independence on each coin toss, we can use multiplication to calculate this probability: Notice that  because we assumed the coin was fair. Had it not been fair, we would have different probabilities for  and , explained by the relationship that . This is what the binomial PMF is implying: calculating the probability that we get  successes in  trials requires that we multiply the probability of success  by  times and the probability of failure  by  times, because those are the numbers of successful and unsuccessful trials respectively. Now that we have reviewed the concept of binomial distribution, it is time to apply it to our example of phone calls at the Yongsan PMO. Although I do not have an  data sheet on me, let’s assume for the sake of convenience that, on average, 12 calls come to the PMO per shift, which is eight hours. Given this information, how can we simulate the situation as a binomial distribution? First, we have to define what constitutes a success in this situation. While there might be other ways to go about this agenda, the most straightforward approach would be to define a phone call as a success. This brings us to the next question: how many trials do we have? Here is where things get a bit more complicated—we don’t really have trials! Notice that this situation is somewhat distinct from coin tosses, as we do not have a clearly defined “trial” or an experiment. Nonetheless, we can approximate the distribution of this random variable by considering each ten-minute blocks as a unit for a single trial, i.e. if a call is received by the PMO between 22:00 and 22:10, then the trial is a success; if not, a failure. Blocking eight hours by ten minutes gives us a total of 48 trials. Because we assumed the average number of phone calls on a single shift to be 12, the probability of success . Let’s simulate this experiment  times. We can model this binomial distribution as follows: This code block produces the following output: Under this assumption, we can also calculate how lucky I was yesterday when I only received five calls by plugging in the appropriate values into the binomial PMF function: From a frequentist’s point of view, I would have lazy days like these only 7 times for every thousand days, which is nearly three years! Given that my military service will last only 1.5 years from now, I won’t every have such a lucky day again, at least according to the binomial distribution. But a few glaring problem exists with this mode of analysis. For one, we operated under a rather shaky definition of a trial by arbitrarily segmenting eight hours into ten-minute blocks. If we modify this definition, say, by saying that a single minute comprises an experiment, hence a total of 480 trials, we get a different values for  and , which would clearly impact our calculation of . In fact, some weird things happen if we block time into large units, such as an hour—notice how the value of  becomes , which is a probabilistic impossibility as  should always take values between . Another issue with this model is that a Bernoulli trial does not allow for simultaneous successes. Say, for instance, that within one ten-minute block, we got two calls. However, because the result of a Bernoulli trial is binary, i.e. either a success or a failure, it cannot contain more than one success in unit time. Therefore, binary distribution cannot encode higher dimensions of information, such as two or three simultaneous successes in one trial. These set of complications motivate a new way of modeling phone calls. In the next section, we look at an alternate approach to the problem: the Poisson distribution. Here is some food for thought: what if we divide up unit time into infinitesimally small segments instead of the original ten, such that ? This idea is precisely the motivation behind the Poisson distribution. If we divide our time frame of interest into infinite segments, smaller even than microseconds, we can theoretically model multiple successful events, which is something that the binomial distribution could not account for. Intuitively speaking, this approach is akin to modeling a continuous function as infinitely many stepwise functions such that two “adjacent” dots on the graph could be considered as identical points—or, in probabilistic terms, a simultaneous event. And because we have infinitely many trials and only a fixed number of success, this necessarily means that  would approach 0. Although this value may seem odd, the argument that the probability of receiving a call at this very instant is 0, since “instant” as a unit of time is infinitely short to have a clearly defined probability. From an algebraic standpoint,  is necessary to ensure that , the expected number of success, converges to a real value. Now let’s derive the Poisson formula by tweaking the PMF for a binomial distribution. We commence from this expression: We can substitute  for  from the definition: Using the definition of combinatorics, Recall that  can alternately be defined as . From this definition, it flows that: But then the last term converges to 1 as  goes to : We can further simplify the rest of the terms in the limit expression as well. Specifically,  collapses to . These terms can be coupled with  in the denominator as follows: Putting this all together yields: And we have derived the PMF for the Poisson distribution! We can perform a crude sanity check on this function by graphing it and checking that its maximum occurs at . In this example, we use the numbers we assumed in the PMO phone call example, in which . The code produces the following graph. As expected, the graph peaks at . At a glance, this distribution resembles the binomial distribution we looked at earlier, and indeed that is no coincidence: the Poisson distribution is essentially a special case of binomial distributions whereby the number of trials is literally pushed to the limit. As stated earlier, the binomial distribution can be considered as a very rough approximation of the Poisson distribution, and the accuracy of approximation would be expected to increase as  increases. So let me ask the question again: how lucky was I yesterday? The probability distribution function of the Poisson distribution tells us that  can be calculated through the following equation: The result given by the Poisson distribution is somewhat larger than that derived from the binomial distribution, which was . This discrepancy notwithstanding, the fact that I had a very lucky day yesterday does not change: I would have days like these once every 100 days, and those days surely don’t come often. But to really calculate how lucky I get for the next 18 months of my life in the military, we need to do a bit more: we need to also take into account the fact that receiving lesser than 5 calls on a shift also constitutes a lucky day. In other words, we need to calculate , as shown below: This calculation can be done rather straightforwardly by plugging in numbers into the Poisson distribution function as demonstrated above. Of course, this is not the most elegant way to solve the problem. We could, for instance, tweak the Poisson distribution function and perform integration. The following is a code block that produces a visualization of what this integral would look like on a graph. Here is the figure produced by executing the code block above. You might notice from the code block that the integrand is not quite the Poisson distribution—instead of a factorial, we have an unfamiliar face, the  function. Why was this modification necessary? Recall that integrations can only be performed over smooth and continuous functions, hence the classic example of the absolute value as a non-integrable function. Factorials, unfortunately, also fall into this category of non-integrable functions, because the factorial operation is only defined for integers, not all real numbers. To remedy this deficiency of the factorial, we resort to the gamma function, which is essentially a continuous version of the factorial. Mathematically speaking, the gamma function satisfies the recursive definition of the factorial: Using the gamma distribution function, we can then calculate the area of the shaded region on the figure above. Although I do not present the full calculation process here, the value is approximately equal to that we obtained above, . So to answer the title of this post: about 2 in every 100 days, I will have a chill shift where I get lesser than five calls in eight hours. But all of this aside, I should make it abundantly clear in this concluding section that I like my job, and that I love answering calls on the phone. I can assure you that no sarcasm is involved. If you insist on calculating this integral by hand, I leave that for a mental exercise for the keen reader. Or even better, you can tune back into this blog a few days later to check out my post on the gamma function, where we explore the world of distributions beyond the binomial and the Poisson.",0,1,0,0,0,1,0,0
Better seq2seq,"In the previous post, we took a look at how to implement a basic sequence-to-sequence model in PyTorch. Today, we will be implementing a small improvement to the previous model. These improvements were suggested in Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation, by Cho, et. al. To cut to the chase, the image below, taken from Ben Trevett’s tutorial, encapsulates the enhancement we will be implementing today.  In the previous model, the hidden state of the model was a bottleneck: all the information from the encoder was supposed to be compressed into the hidden state, and even that encoder hidden state would have undergone changes as the decoder was unrolled with subsequent target sequences. To reduce this bottleneck and lessen the compression burden on the encoder hidden state, the improved architecture will allow the decoder to gain access to the encoder hidden state at each time step. Moreover, the final classifier output layer in decoder will have access to the original embedding of the target language token as well as the last hidden state of the encoder, represented as  in the diagram above. This can be considered a residual connection, since the embedding skips the RNN and directly gets fed into the fully connected layer. Now that we have some idea of what we want to achieve, let’s start coding. Since the setup for this tutorial is identical to that of the previous post, I’ll skip much of the explanation and sanity checks. In the code block below, we load the  dataset, then create bucket iterators for each train, validation, and test split. Let’s start with the encoder. The encoder here is actually almost identical to the one we implemented in the previous model. In fact, it is arguably simpler, as we are now using a single GRU layer instead of a two-layered LSTM. The decoder is where all the enhancements are going to take place. Recall the changes we want to make to the previous seq2seq architecture.  As you can see, we need to make sure that The first change means that the decoder’s forward method needs to be able to take in the encoder’s hidden states as input. For sake of notational clarity, let’s call those hidden states as “context.” The way we allow the decoder to use its own hidden state as well as the context for computation is that we concatenate the context with its input embeddings. Effectively, we could think of this as creating a new embedding vectors, where the first half comes from actual embeddings of English tokens and the later half comes from the context vector. Another implementation detail not mentioned earlier is the dimension of the last fully connected classifier layer. Since we now concatenate the embedding vector with the hidden state from the GRU, context vector from the encoding, as well as the original embedding vectors, the classifier’s input dimensions are much larger than they were in the previous decoder model. Now it’s time to implement the sequence-to-sequence model. Most of the enhancements were already baked into the decoder, and the fundamental logic through which predictions are generated remain unchanged. Thus, only minimal changes have to be made to the seq2seq model: namely, we need to handle the context vector and pass it to the decoder at every time step. And from here on, the details are exactly identical; the same  and  functions can be used in the previous post. Since I intended this post to be a simple little exercise as opposed to a fully blown out tutorial, we’ll stop here, but by all means, feel free to experiment more with it. Below are the configurations Ben Trevett used in his tutorial. When I was writing this notebook, I realized that I enjoy thinking about the dimensional details of each tensor being passed around here and there. It is difficult, and sometimes it required me to use dirty print statements to actually log what was happening to each variable, but all in all, I think attention to dimensional detail is definitely something that one should practice and think about when modeling. I hope you enjoyed reading this post. In a future post, we will explore what attention is and how to bake it into a seq2seq model to take it to the next level. Also, happy holidays!",0,0,1,0,0,0,1,0
Principal Component Analysis,"Principal component analysis is one of those techniques that I’ve always heard about somewhere, but didn’t have a chance to really dive into. PCA would come up in papers on GANs, tutorials on unsupervised machine learning, and of course, math textbooks, whether it be on statistics or linear algebra. I decided that it’s about time that I devote a post to this topic, especially since I promised one after writing about  on this blog some time ago. So here it goes. What do we need principal component analysis for? Or more importantly, what is a principal component to begin with? Well, to cut to the chase, PCA is a way of implementing dimensionality reduction, often referred to as lossy compression. This simply means that we want to transform some data living in high dimensional space into lower dimensions. Imagine having a data with hundreds of thousands of feature columns. It would take a lot of computing power to apply a machine learning model to fit the data and generate predictions. This is when PCA comes in: with PCA, we can figure out which dimensions are the most important and apply a transformation to compress that data into lower dimensions, making it a lot more tractable and easier to work with. And in case you’re still wondering, principal components refer to those new extracted dimensions used to newly represent data! Let’s derive PCA with some good old linear algebra tricks. I used Ian Goodfellow’s Deep Learning and a lecture slide from Columbia references for this post. The setup of a classic PCA problem might be summarized as follows. Suppose we have a dataset of  points, each living in -dimensional space. In other words, 
where Our goal is to find a way to compress the data into lower dimensional space  where . We might imagine this as a transformation, i.e. the objective is to find a transformation So that applying  will yield a new vector  living in lower dimensional space. We can also imagine there being a reverse transformation or a decoding function  that achieves Because PCA is in essence a linear transformation, it is most natural to express and understand it as a matrix. Let’s define this transformation as , and the matrix corresponding to the decoding . In other words, PCA makes a number of assumptions to simplify this problem. The most important assumption is that each column of  is orthogonal to each other. As we will see later in an alternate derivation with statistics, this has to do with the notion of covariance. Another restriction is that the columns of  must have a Euclidean norm of one. This constraint is necessary for us to find a unique matrix  that achieves compression—otherwise, we could have any multiples, leading to an infinite number of such matrices. We make one more convenient assumption about the given data points, . That is,  is assumed to have a mean of zero, i.e. . If this is not the case, we can easily perform standardization by subtracting the mean from the data. With this setup in mind, let’s finally start the derivation. As said earlier, the goal of PCA is to compress data (and be able to uncompress it) with as little loss of information as possible. We don’t want to compress data in a haphazard fashion; instead, we want the compression scheme to be able to preserve the structure of the data as much as possible in its lower dimensional representation. From this, we can come up with the following equation: In other words, the goal is to find  that which minimizes the difference between the original data and the reconstructed data. Note that finding this optimal  amounts to finding  that most effectively compresses given data. Instead of the L2 norm, let’s consider the squared L2 norm for convenience purposes. Note that minimizing the L2 norm is equal to minimizing the squared L2 norm, so there is no semantic difference. By definition of vector transpose, we can now express the squared L2 norm versions of (3) as follows: where the second to last equality is due to the fact that  and  are both constants that denote the same value. Also,  the argument of the minimum is with respect to , we can omit the first term, which is purely in terms of . It’s time to take derivatives. But in order to do so, we need to unpack  , since we have no idea how to take its derivative. Using (2), we can reorganize (4) as follows: The last equality is due to the fact that we constrained the columns of  to be unit vectors that are orthogonal to each other. Now we can take a derivative of the argument with respect to  and set it equal to zero to find the minimum. This tells us that the optimal way of compressing  is simply by multiplying it by the transpose of the decoding matrix. In other words, we have found the transformation  in (2). For those of you who are confused about how gradients and matrix calculus work, here is a very short explanation. First, notice that  is just a scalar, since  is a column vector. Taking a gradient with respect to this quantity would mean that we get another column vector of equal dimensions with  with the following elements: And we know how to go from there. The same line of thinking can be applied to think about the second term, . We know that  is a row vector since its dot product with  should be possible dimensionally speaking. Then, we know that the gradient with respect to  should give each of the elements of , but in column vector format—hence the need for a transpose. In general, the rule of thumb is that the gradient of a scalar with respect to a vector or a matrix should return a vector or matrix of the same dimension. Recall from (1) that reconstruction can be achieved by applying compression followed by a decoding operation: Since we know that  is just  and  is  by definition, we can express (1) in a different way. In retrospect, this is somewhat intuitive since  can roughly be thought of as a pseudo-orthonormal matrix—pseudo since there is no guarantee that it is a square matrix. Now, all that is left is to find the matrix . The way to go about this is to reconsider (3), the notion of minimizing data loss, given our findings in (6). In other words, Instead of considering a single observation, here we consider the design matrix in its entirety. Note that  is a design matrix whose rows correspond to a single observation. And because we are dealing with matrices, the Euclidean norm was replaced with its matrix equivalent, the Frobenius norm. Observe that the first term  can safely be removed from the argument since it is a constant with respect to ; let’s also change the argument of the minimum to the maximum given the negative sign. The Frobenius norm of a real matrix can be calculated as Therefore, The last equality is due to a useful property of trace, which is that we can cycle the order of matrices without changing its value. Let’s consider a single column in , denoted as . You might also imagine this as a situation where  is one-dimensional, meaning we want to compress data into a single scalar value. It is not difficult to see that the trace of , which is a scalar in the one-dimensional case, is maximized when  is an eigenvector of  with the largest eigenvalue. Generalizing this result back to , we see that  is a matrix whose columns correspond to the eigenvectors of  in descending order. If you had prior exposure to PCA, you might know that the standard way of obtaining principal components is by calculating the covariance matrix of the data and finding its eigenvectors. Here, I attempt to present an explanation of how and why the procedure outlined in the preceding section is essentially achieving the same tasks, albeit through a different frame of thought. The unbiased sample covariance matrix is given by Of course, this is operating under the assumption that  has already been standardized such that the mean of the data is zero. You might be thinking that the formulation in (14) looks different from the one introduced previously on this post on SVD. In that particular post, I stated that covariance could be calculated as (14) and (15) certainly look different. However, under the hood, they express the same quantity. So in a nutshell, the conclusion we arrived at in the preceding section with the minimization of residual sums ultimately amounts to finding the covariance matrix and its eigenvectors. I found this to be the more dominant interpretation of PCA, since indeed it is highly intuitive: the goal of PCA is to find the axes—or the principal components—that which maximize the variance seen in the data. setosa.io has some excellent visualizations on the notion of covariance and how it relates to PCA, so I highly recommend that you go check it out. If were to derive PCA from the gecko with the covariance approach, we would be using an iterative approach to find a single principal component at a time. Specifically, our goal would be to find  that which maximizes Hence the problem is now framed as a constrained optimization problem. We use Lagrangians to solve constrained optimization. The intuition for the Lagrangian method is that the gradient of the constraint and the argument should be parallel to each other at the point of optimization. We go about this by taking the gradient of the argument with respect to : Since 2 is just a constant, we can absorb it into  to form a more concise expression. Also, since the covariance matrix is by definition symmetric, we can simplify things further to end up with And once again, we have shown that the principal components are the eigenvectors of the covariance matrix. But the procedure outlined above can be used to find only one principal component, that is the eigenvector with the largest eigenvalue. How do we go about searching for multiple eigenvectors? This can be done, once again, with Lagrangians, with the added caveat that we will have more trailing terms in the end. Let’s elaborate on this point further. Here, we assume that we have already obtained the first component, , and our goal is to find the next component, . With induction, we can easily see how this analysis would apply to finding . Simply put, the goal is to maximize  under the constraint that  is orthogonal to  while also satisfying the constraint that it is a unit vector. (In reality, the orthogonality constraint is automatically satisfied since the covariance matrix is symmetric, but we demonstrate this nonetheless.) Therefore, Using Lagrangians, In the last equality, we make a trivial substitution to simplify and get rid of the constant. We also use the fact that the covariance matrix is symmetric. If we left multiply (18) by , But since , the first two terms go to zero. Also, the last term reduces to  since . This necessarily means that . If we plug this result back into (18), we end up with the definition of the eigenvector again, but this time for . Essentially, we iterate this process to find a specified number of principal components, which amounts to finding   number of eigenvectors of the sample covariance matrix. A while back, we discussed both eigendecomposition as well as singular value decomposition, both of which are useful ways of decomposing matrices into discrete factors. In this section, we will see how PCA is essentially a way of performing and applying these decomposition techniques under the hood. Recall that eigendecomposition is a method of decomposing matrices as follows: where  is a diagonal matrix of eigenvalues and  is a matrix of eigenvectors. PCA is closely related to eigendecomposition, and this should come as no surprise. Essentially, by finding the eigenvalues and eigenvectors of , we are performing an eigendecomposition on the covariance matrix: Notice that  is a matrix of principal components. Of course, in this case,  is a square matrix of full rank; to apply dimension compression, we need to slice the first  entries of . At any rate, it is clear that PCA involves eigendecomposition of the covariance matrix. Eigendecomposition can only be applied to matrices of full rank. However, there is a more generalized method for non-square matrices, which is singular value decomposition. Here is a blueprint of SVD: Where  is a matrix containing the roots of the eigenvalues, with appropriate dimensional configurations to accommodate the shape of the original matrix. We cannot perform eigendecomposition on , which has no guarantee that it is square; however, SVD is definitely an option. Assume that  can be decomposed into , , and . Then the covariance matrix becomes And we end up in the same place as we did in (25). This is no surprise given that the derivation of SVD involves eigendecomposition. In this post, we took a deep dive into the mathematics behind principal component analysis. PCA is a very useful technique used in many areas of machine learning. One of the most common applications is to apply PCA to a high-dimensional dataset before applying a clustering algorithm. This makes it easier for the ML model to cluster data, since the data is now aligned in such a way that it shows the most variance. Upon some more research, I also found an interesting paper that shows that there is a solid mathematical relationship between K-means clustering and PCA. I haven’t read the paper from top to bottom, but instead glossed over a summary of the paper on this thread on stack overflow. It’s certainly a lot of information to take in, and I have no intent of covering this topic in this already rather lengthy post on PCA. So perhaps this discussion will be tabled for a later time, as interesting as it seems. I hope you enjoyed reading this post. Amidst the chaos of the COVID19 pandemic, let’s try to stay strong and find peace ruminating over some matrices and formulas. Trust me, it works better than you might think.",0,1,0,0,1,0,0,0
Fisher Score and Information,"Fisher’s information is an interesting concept that connects many of the dots that we have explored so far: maximum likelihood estimation, gradient, Jacobian, and the Hessian, to name just a few. When I first came across Fisher’s matrix a few months ago, I lacked the mathematical foundation to fully comprehend what it was. I’m still far from reaching that level of knowledge, but I thought I’d take a jab at it nonetheless. After all, I realized that sitting down to write a blog post about some concept forces me to study more, so it is a positive, self-reinforcing cycle. Let’s begin. Fisher’s score function is deeply related to maximum likelihood estimation. In fact, it’s something that we already know–we just haven’t defined it explicitly as Fisher’s score before. First, we begin with the definition of the likelihood function. Assume some dataset  where each observation is identically and independently distributed according to a true underlying distribution parametrized by . Given this probability density function , we can write the likelihood function as follows: While it is sometimes the convention that the likelihood function be denoted as , we opt for an alternative notation to reserve  for the loss function. To continue, we know that the maximum likelihood estimate of the distribution’s parameter is given by This is the standard drill we already know. The next step, as we all know, is to take the derivative of the term in the argument maxima, set it equal to zero, and voila! We have found the maximum likelihood estimate of the parameter. A quick aside that may become later is the fact that maximizing the likelihood amounts to minimizing the loss function. Now here comes the definition of Fisher’s score function, which really is nothing more than what we’ve done above: it’s just the gradient of the log likelihood function. In other words, we have already been implicitly using Fisher’s score to find the maximum of the likelihood function all along, just without explicitly using the term. Fisher’s score is simply the gradient or the derivative of the log likelihood function, which means that setting the score equal to zero gives us the maximum likelihood estimate of the parameter. An important characteristic to note about Fisher’s score is the fact that the score evaluated the true value of the parameter equals zero. Concretely, this means that given a true parameter , This might seem deceptively obvious: after all, the whole point of Fisher’s score and maximum likelihood estimation is to find a parameter value that would set the gradient equal to zero. This is exactly what I had thought, but there are subtle intricacies taking place here that deserves our attention. So let’s hash out exactly why the expectation of the score with respect to the true underlying distribution is zero. To begin, let’s write out the full expression of the expectation in integral form. If we evaluate this integral at the true parameter, i.e. when , The key part of this derivation is the use of the Leibniz rule, or sometimes known as Feynman’s technique or differentiation under the integral sign. I am most definitely going to write a post detailing in intuitive explanation behind why this operation makes sense in the future, but to prevent unnecessary divergence, for now it suffices to use that rule to show that the expected value of Fisher’s score is zero at the true parameter. Things start to get a little more interesting (and more complicated) as we move onto the discussion of Fisher’s Information Matrix.  There are two sides of the coin that we will consider in this discussion: Fisher’s information as understood as the covariance matrix of the score function, and Fisher’s information as understood as a Hessian of the negative log likelihood. The gist of it is that there are two different ways of understanding the same concept, and that they provide intriguing complementary views on the information matrix. Before jumping into anything else, perhaps it’s instructive to review variance, covariance, and the covariance matrix. Here is a little cheat sheet to help you out (and my future self, who will most likely be reviewing this later as well). An intuitive way to think about variance is to consider it as a measure of how far samples are from the mean. We square that quantity to prevent negative values from canceling out positive ones. Covariance is just an extension of this concept applied to a comparison of two random variables instead of one. Here, we consider how two variables move in tandem. And the variance-covariance matrix is simply a matrix that contains information on the covariance of multiple random variables in a neat, compact matrix form. A closed-form expression for the covariance matrix  given a random vector , which follows immediately from aforementioned definitions and some linear algebra, looks as follows: Enough of the prologue and review, now we’re ready to start talking about Fisher. The information matrix is defined as the covariance matrix of the score function as a random vector. Concretely, Note that the 0’s follow straight from the earlier observation that . Intuitively, Fisher’s information gives us an estimate of how certain we are about the estimate of the parameter . This can be seen by recognizing the apparent similarity between the definition of the covariance matrix we have defined above and the definition of Fisher’s information. In fact, the variance of the parameter  is explained by the inverse of Fisher’s information matrix, and this concept is known as the Cramer-Rao Lower Bound. For the purposes of this post, I won’t get deep into what CRLB is, but there are interesting connections we can make between Fisher’s information, CRLB, and the likelihood, which we will get into later. Because Fisher’s information requires computing the expectation given some probability distribution, it is often intractable. Therefore, given some dataset, often times we use the empirical Fisher as a drop-in substitute for Fisher’s information. The empirical Fisher is defined quite simply as follows: In other words, it is simply an unweighted average of the covariance of the score function for each observed data point. Although this is a subtlety, it helps to clarify nonetheless. Something that may not be immediately apparent yet nonetheless true and very important about Fisher’s information is the fact that it is the negative expected value of the second derivative of the log likelihood. In our multivariate context where  is a vector, the second derivative is effectively the Hessian. In other words, You might be wondering how the information matrix can be defined in two says, the covariance and the Hessian. Indeed, this threw me off quite a bit as well, and I struggled to find and understand a good resource that explained why this was the case. Thankfully, Mark Reid’s blog and an MIT lecture contained some very helpful pointers that got me a long way. The derivation is not the easiest, but I’ll try to provide a concise version based on my admittedly limited understanding of this topic. Let’s start from some trivially obvious statements. First, from the definition of a PDF and the derivative operation, we know that Therefore, both the first and second derivative of this function are going to be zero. In multivariate speak, both the gradient and the Hessian are zero vectors and matrices, respectively. Using the Leibniz rule we saw earlier, we can interchange the derivative and come up with the following expressions. Granted, these expressions somewhat muffle the shape of the quantity we are dealing with, namely vectors and matrices, but it is concise and intuitive enough for our purposes. With these statements in mind, let’s now begin the derivation by first taking a look at the Hessian of the score function. From the chain rule, we know that This does not look good at all. However, let’s not fall into despair, since our goal is not to calculate the second derivative or the Hessian itself, but rather its negative expected value. In calculating the expected value, we will be using integrals, which is where the seemingly trivial statements we established earlier come in handy. By linearity of expectation, we can split this expectation up into two pieces. Let’s use integrals to express the first expectation. The good news is that now we see terms canceling out each other. Moreover, from the Leibniz rule and the interchanging of the integral and the derivative, we have shown that the integral in fact evaluates to zero. This ultimately leaves us with Therefore we have established that And we’re done! In this post, we took a look at Fisher’s score and the information matrix. There are a lot of concepts that we can build on from here, such as Cramer Rao’s Lower Bound or natural gradient descent, both of which are interesting concepts at the intersection of machine learning and statistics. Although the derivation is by no means mathematically robust, it nonetheless vindicates a notion that is not necessary apparently obvious, yet makes a lot of intuitive sense in hindsight. I personally found this video by Ben Lambert to be particularly helpful in understanding the connection between likelihood and information. The gist of it is simple: if we consider the Hessian or the second derivative to be indicative of the curvature of the likelihood function, the variance of our estimate of the optimal parameter  would be larger if the curvature was smaller, and vice versa. In a sense, the larger the value of the information matrix, the more certain we are about the estimate, and thus the more information we know about the parameter. I hope you enjoyed reading this post. Catch you up on another post, most likely on the Leibniz rule, then natural gradient descent!",0,1,0,0,0,0,0,0
Revisiting Basel with Fourier,"In the last post, we revisited the Riemann Zeta function, which we had briefly introduced in another previous post on Euler’s take on the famous Basel problem. It seems like math is my jam nowadays, so I decided to write another post on this topic—but this time, with some slightly different takes. In this post, we will explore an alternative way of solving the Basel problem using Fourier series expansion, and also discuss a alternative representations of the Basel problem in integral form. For the integral representations, I’m directly referencing Flammable Maths, a YouTube channel that I found both entertaining and informative. Let’s get started. First, let’s recall what the Basel problem is. The problem is quite simple: the goal is to obtain the value of an infinite series, namely This seems like an innocuous, straightforward problem. One can easily prove, for instance, the fact that this series converges using integral approximation. However, to obtain the value of this series is a lot more difficult than it appears—it is no coincidence that this problem remained unsolved for years until Euler came along. While there are many ways to solve this problem—Euler’s method, in particular, is one of the countless examples through which one can witness his amazing intuition and heuristic—but we will be using Fourier expansion to solve this problem, as it also provides a nice segue into the Dirichlet Eta function. We explored the topic of Fourier expansion in this previous post. To recap, from a very high level, Fourier expansion is a way of expressing some function in terms of trigonometric functions. If Taylor expansion used polynomials as the building block, Fourier expansion uses sines and cosines. A generic formula for the Fourier transform can be expressed as follows: With some integration, it can be shown that where  refers to the domain of integration. For instance, if we are integrating from  to , . A classic interval that is most commonly used is , and this is no coincidence: notice that, when , the Taylor series shown in (2) simplifies into the following: And indeed this is the format and the interval we will be using when constructing a Fourier series to tackle the Basel problem. To continue, we can derive a very similar expression for , given the specified interval from . Now that we have reviewed what Fourier series is and how we can construct it, let’s jump into the Basel problem. Just like the Taylor series, we can use Fourier expansion to represent any function continuous function. For our purposes, let’s try to expand a simple polynomial function, , using Fourier. We can begin with . Let’s continue with finding the even coefficients corresponding to the cosines. With some integration by parts, we can all agree that where the  terms appear because we end up plugging  into , a periodic function. And we can do the same for sine. Or, even better, with the key insight that  is an even function, we might intelligently deduce that there will be no sine terms at all, since sine functions are by nature odd. In other words, all . This can of course be shown through derivation as we have done above for the cosine coefficients. Therefore, putting everything together, we end up with If we consider the case when , we have Do you smell the basel problem in the air? The summation on the right hand side is a great sign that we are almost done in our derivation. Moving the fractional term to the left hand side, we get: Diding both sides by 4, And there you have it, the answer to the Basel problem, solved using Fourier series! We can also derive a convergence value of the Dirichelt Eta function from this Fourier series as well. Recall that the Eta function looks as follows: Now how can we get a Dirichelt Eta function out of the fourier series of ? Well, let’s get back to (8) and think our way through. One noteworthy observation is that we already have  in the summation, which looks awfully similar to the Dirichlet Eta function. Since we want to get rid of the cosine term, we can simply set —this will make all cosine terms evaluate to 1, effectively eliminating them from the expression. Then, we get With a very small bit of algebra, we end up with And there we have it, the value of ! It’s interesting to see how all this came out of the fourier series of . In this section, we will be taking a look at some interesting representations of the Basel problem, mysteriously packaged in integrals. At a glance, it’s somewhat unintuitive to think that an infinite summation problem can be stated as an integral in exact terms; however, the translation from summation to integrals are not out of the blue. Using things like Taylor series, it is in fact possible to show that the Basel problem can be stated as an integral. For instance, consider this integral One thing I am starting to realize these past few days is that some of these integrals are extremely difficult despite being deceptively simple in their looks. This is a good example. To get started, we might consider making a quick change of variables, namely . This will effectively get rid of the rather messy-looking denominator sitting in the fraction. To make further progress, at this point let’s consider the Taylor series expansion of . We can derive this by considering the following integral: since this integral evaluates to . One way to look at (10) would be to consider it as a sum of some geometric series whose first term begins with 1 and has a constant ratio of . In other words, Here is where a bit of complication comes in. Turns out that under certain conditions, we can exchange the summation and the integral (or, more strictly speaking, the limit and the integral), using things like the dominating convergence theorem of Fubini’s theorem. However, these are topics for another post. For now, we will assume that this trick is legal and continue on. Now we have Now that we have a summation representation of , let’s move onto (11). We use the same trick we used earlier to interchange the summation and the integral. This gives us Since we have to terms with negative ones with the same exponent, we can safely remove both of them: And notice that we now have the Basel problem! If you plug in  and increment  from there, it is immediately apparent that this is the case. So there we have it, the integral representation of the Basel problem! Let’s look at another example, this time using a double integral representation. The motivation behind this approach is simple. This is a useful result, since it means that we can express the Basel problem as an integral of two different variables. Now, all we need is a summation expression before the integration. And now we are basically back to the Basel problem. Note that we can also use the interchange of integral and summation technique again to reexpress (19) as shown below. Notice that now we have a geometric series, which means that now we can also express this integral as Like this, there are countless ways of using integrals to express the Basel problem. This representation, in particular, could be understood as an integral over a unit square in the cartesian coordinate over a bivariate function, . In this post, we took a look at a new way of approaching the Basel problem using Fourier expansion. We also looked at some interesting integral representations of the Basel problem. While a lot of this is just simple calculus and algebra, I nonetheless find it fascinating how the Basel problem can be approached from so many different angles—hence my renewed respect for Euler and other mathematicians who wrestled with this problem hundreds of years ago. As simple as it appears, there are so many different techniques and modes of analysis we can use to approach the problem. It was nice exercise and review of some calculus techniques. I’ve been digging more into the curious interchange of integral and summation recently, and when this operation is allowed, if at all. Turns out that this problem is slightly more complicated than it appears and requires some understanding of measure theory, which I had tried getting into a few months ago without much fruition. Hopefully this time, I’ll be able to figure something out, or at the very least gain some intuition on this operation. I hope you’ve enjoyed reading this post. Catch you up in the next one.",0,0,0,0,0,0,0,1
Markov Chain and Chutes and Ladders,"In a previous post, we briefly explored the notion of Markov chains and their application to Google’s PageRank algorithm. Today, we will attempt to understand the Markov process from a more mathematical standpoint by meshing it together the concept of eigenvectors. This post was inspired and in part adapted from this source. In linear algebra, an eigenvector of a linear transformation is roughly defined as follows: a nonzero vector that is mapped by a given linear transformation onto a vector that is the scalar multiple of itself This definition, while seemingly abstract and cryptic, distills down into a simple equation when written in matrix form: Here,  denotes the matrix representing a linear transformation; , the eignevector; , the scalar value that is multiplied onto the eigenvector. Simply put, an eigenvector  of a linear transformation is one that is—allow me to use this term in the loosest sense to encompass positive, negative, and even imaginary scalar values—“stretched” by some factor  when the transformation is applied, i.e. multiplied by the matrix  which maps the given linear transformation. The easiest example I like to employ to demonstrate this concept is the identity matrix . For the purpose of demonstration, let  be an arbritrary vector  and  the three-by-three identity matrix. Multiplying  by  produces the following result: The result is unsurprising, but it reveals an interesting way of understanding : identity matrices are a special case of diagonalizable matrices whose eigenvalues are 1. Because the multiplying any arbitrary vector by the identity matrix returns the vector itself, all vectors in the dimensional space can be considered an eigenvector to the matrix , with  = 1. A formal way to calculate eigenvectors and eigenvalues can be derived from the equation above. Since  is assumed as a nonzero vector, we can deduce that the matrix  is a singular matrix with a nontrivial null space. In fact, the vectors in this null space are precisely the eigenvectors that we are looking for. Here, it is useful to recall that the a way to determine the singularity of a matrix is by calculating its determinant. Using these set of observations, we can modify the equation above to the following form: By calculating the determinant of , we can derive the characteristic polynomial, from which we can obtain the set of eigenvectors for  representing some linear transformation . Now that we have reviewed some underlying concepts, perhaps it is time to apply our knowledge to a concrete example. Before we move on, I recommend that you check out this post I have written on the Markov process, just so that you are comfortable with the material to be presented in this section. In this post, we turn our attention to the game of Chutes and Ladders, which is an example of a Markov process which demonstrates the property of “memorylessness.” This simply means that the progress of the game depends only on the players’ current positions, not where they were or how they got there. A player might have ended up where they are by taking a ladder or by performing a series of regular dice rolls. In the end, however, all that matters is that the players eventually hit the hundredth cell. To perform a Markov chain analysis on the Chutes and Ladders game, it is first necessary to convert the information presented on the board as a stochastic matrix. How would we go about this process? Let’s assume that we start the game at the th cell by rolling a dice. There are six possible events, each with probability of . More specifically, we can end up at the index numbers 38, 2, 3, 14, 5, or 6. In other words, at position 0, where  and  denote the current and next position of the player on the game board, respectively. We can make the same deductions for other cases where . We are thus able to construct a 101-by-101 matrix representing the transition probabilities of our Chutes and Ladders system, where each column represents the system at a different state, i.e. the th entry of the th column vector represents the probabilities of moving from cell  to cell . To make this more concrete, let’s consider a program that constructs the stochastic matrix , without regards to the chutes and ladders for now. The indexing is key here: for each column, th rows were assigned the probability of . Let’s say that a player is in the th cell. Assuming no chutes or ladders, a single roll of a dice will place him at one of the cells from  to ; hence the indexing as presented above. However, this algorithm has to be modified for  bigger or equal to 95. For example if , there are only three probabilities: , , and , each of values , , and  respectively. The  statements are additional corrective mechanisms to account for this irregularity. So now we’re done with the stochastic matrix! … or not quite. Things get a bit more complicated once we throw the chutes and ladders into the mix. To achieve this, we first build a dictionary containing information on the jump from one cell to another. In this dictionary, the keys correspond to the original position; the values, the index of the cell after the jump, either through a chute or a ladder. For example,  represents the first ladder on the game board, which moves the player from the first cell to the thirty eighth cell. To integrate this new piece of information into our code, we need to build a permutation matrix that essentially “shuffles up” the entries of the stochastic matrix  in such a way that the probabilities can be assigned to the appropriate entries. For example,  does not reflect the fact that getting a 1 on a roll of the dice will move the player up to the thirty eighth cell; it supposes that the player would stay on the first cell. The new permutation matrix  would adjust for this error by reordering . For an informative read on the mechanics of permutation, refer to this explanation from Wolfram Alpha. Let’s perform a quick sanity check to verify that  contains the right information on the first ladder, namely the entry  in the  dictionary. Notice the  in the th entry hidden among a haystack of 100 s! This result tells us that  is indeed a permutation matrix whose multiplication with  will produce the final stochastic vector that correctly enumerates the probabilities encoded into the Chutes and Ladders game board. Here is our final product: We can visualize the stochastic matrix  using the  package. This produces a visualization of our stochastic matrix. So there is our stochastic matrix! Now that we have a concrete matrix to work with, let’s start by identifying its eigenvectors. This step is key to understanding Markov processes since the eigenvector of the stochastic matrix whose eigenvalue is 1 is the stationary distribution vector, which describes the Markov chain in a state of equilibrium. For an intuitive explanation of this concept, refer to this previous post. Let’s begin by using the  package to identify the eigenvalues and eigenvectors of the stochastic matrix. This code block produces the following output: The first entry of this array, which is the value , deserves our attention, as it is the eigenvalue which corresponds to the stationary distribution eigenvector. Since the index of this value is , we can identify its eigenvector as follows: Notice that this eigenvector is a representation of a situation in which the player is in the th cell of the game board! In other words, it is telling us that once the user reaches the th cell, they will stay on that cell even after more dice rolls—hence the stationary distribution. On one hand, this information is impractical given that a player who reaches the end goal will not continue the game to go beyond the th cell. On the other hand, it is interesting to see that the eigenvector reveals information about the structure of the Markov chain in this example. Markov chains like these are referred to as absorbing Markov chains because the stationary equilibrium always involves a non-escapable state that “absorbs” all other states. One might visualize this system as having a loop on a network graph, where it is impossible to move onto a different state because of the circular nature of the edge on the node of the absorbing state. At this point, let’s remind ourselves of the end goal. Since we have successfully built a stochastic matrix, all we have to do is to set some initial starting vector  and perform iterative matrix calculations. In recursive form, this statement can be expressed as follows: The math-inclined thinkers in this room might consider the possibility of conducting an eigendecomposition on the stochastic matrix to simply the calculation of matrix powers. There is merit to considering this proposition, although later on we will see that this approach is inapplicable to the current case. Eigendecomposition refers to a specific method of factorizing a matrix in terms of its eigenvalues and eigenvectors. Let’s begin the derivation: let  be the matrix of interest,  a matrix whose columns are eigenvectors of , and , a matrix whose diagonal entries are the corresponding eigenvalues of . Let’s consider the result of multiplying  and . If we view multiplication as a repetition of matrix-times-vector operations, we yield the following result. But recall that  are eigenvectors of , which necessarily implies that Therefore, the result of  can be rearranged and unpacked in terms of : 
 In short, Therefore, we have , which is the formula for eigendecomposition of a matrix. One of the beauties of eigendecomposition is that it allows us to compute matrix powers very easily. Concretely, Because  and  nicely cross out, all we have to compute boils down to ! This is certainly good news for us, since our end goal is to compute powers of the stochastic matrix to simulate the Markov chain. However, an important assumption behind eigendecomposition is that it can only be performed on nonsingular matrices. Although we won’t go into the formal proofs here, having a full span of independent eigenvectors implies full rank, which is why we must check if the stochastic matrix is singular before jumping into eigendecomposition. Unfortunately, the stochastic matrix is singular because , the number of columns or rows. This implies that our matrix is degenerate, and that the best alternative to eigendecomposition is the singular value decomposition. But for the sake of simplicity, let’s resort to the brute force calculation method instead and jump straight into some statistical analysis. We first write a simple function that simulates the Chutes and Ladders game given a starting position vector . Because a game starts at the th cell by default, the function includes a default argument on  as shown below: Calling this function will give us , which is a 101-by-1 vector whose th entry represents the probability of the player being on the th cell after a single turn. Now, we can plot the probability distribution of the random variable , which represents the number of turns necessary for a player to end the game. This analysis can be performed by looking at the values of  since the last entry of this vector encodes the probability of the player being at the th cell, i.e. successfully completing the game after  rounds. This block produces the following figure: I doubt that anyone would play Chutes and Ladders for this long, but after about 150 rolls of the dice, we can expect with a fair amount of certainty that the game will come to an end. The graph above presents information on cumulative fractions, but we can also look at the graph for marginal probabilities by examining its derivative: And the result: From the looks of it, the maximum of the graph seems to exist somewhere around . To be exact, . This result tells us that we will finish the game in 19 rolls of the dice more often than any other number of turns. We can also use this information to calculate the expected value of the game length. Recall that Or if the probability density function is continuous, In this case, we have a discrete random variable, so we adopt the first formula for our analysis. The formula can be achieved in Python as follows: This result tells us that the typical length of a Chutes and Ladders game is approximately 36 turns. But an issue with using expected value as a metric of analysis is that long games with infinitesimal probabilities are weighted equally to short games of substantial probability of occurrence. This mistreatment can be corrected for by other ways of understanding the distribution, such as median: This function tries to find the point in the cumulative distribution where the value is closest to , i.e. the median of the distribution. The result tells us that about fifty percent of the games end after 29 turns. Notice that this number is smaller than  because it discredits more of the long games with small probabilities. The Markov chain represents an in interesting way to analyze systems that are memoryless, such as the one in today’s post, the Chutes and Ladders game. Although it is a simple game, it is fascinating to see just how much information and data can be derived from a simple image of the game board. In a future post, we present another way to approach similar systems, known as Monte Carlo simulations. But that’s for another time. Peace!",0,0,0,0,1,0,0,0
Neural Style Transfer,"In today’s post, we will take a look at neural style transfer, or NMT for short. NMT is something that I first came across about a year ago when reading Francois Chollet’s Deep Learning with Python book. At that time, I was just getting my feet wet in deep learning with Keras, and I specifically remember myself skipping the chapter on NMT, feeling unprepared and intimidated by the implementation. After a full year, I feel ready to face the challenge, but this time with PyTorch. Let’s get started! Before we get into any specific implementation details, it’s probably helpful to provide some context on how NMT works. Note that, among the many variations of the NMT algorithm, we are going to be discussing the original one first introduced by Gatys et. al. The goal of NMT is simple: given a content image and a style image, transform the content image to have the look and feel of the style image. Below is an example taken from Yunjey’s PyTorch tutorial, which has been an amazing resource so far in my PyTorch journey.  One peculiarity in the original NMT algorithm is that, unlike in typical scenarios in which we update the model’s parameters training, in NMT we update the pixel values of the clone of the content image itself to gradually stylize it. There is no “NMT model” that transforms some image; rather, we merely calculate a loss that is the combination of the content loss and style loss, then optimize the image with respect to this combined loss. Given some style image , content image , and a resulting generated image , we can write the expression for the total loss as where  is a weight parameter that determines the degree with which we want to prioritize style over content. Intuitively, the more stylized an image, the higher the content loss; the smaller the content loss, the higher the style loss. In a way, these two quantities are somewhat mutually exclusive, which is why we want to use a weight constant to ascribe some level of importance to one over the other. Some variations to this formula include those that include weights for both the style and content terms, such as At the end of the day, both formulations are identical, only scaled by some scalar value. (2) is a special case of (1) where . Thus, we can always go from (1) to (2) simply by multiplying by some constant. For simplicity reasons, we will assume (1) throughout this tutorial. A natural question to ask, then, is how we calculate each of these loss terms. Somehow, these loss terms should be able to capture how different two images are, content-wise or style-wise. This is where feature extractors come into play. Pretrained models, such as the VGG network, have filters that are capable of extracting features from an image. It is known that low level convolutional filters that are closer to the input can extract low-level features such as lines or curves, whereas deeper layers are trained to have activation maps that respond to specific shapes or patterns. Notice that this is in line with what the content loss should be able to encode: the general lines and curves of the image should remain similar, as well as the location or presence of general objects like eyes, nose, or hands, to give some concrete examples. Thus, the content loss is simply the L2 norm of the features extracted from each target layer of some pretrained model . Do not let the notation confuse you. All this means is that we sum over each layers of the pretrained model . For each of these layers, we calculate matrix element-wise L2 norm of the content and generated image features extracted by the th layer of the model. If we sum all of them up, we obtain the value of the content loss. Intuitively, we can think of this as comparing both high level and low level features between the two images. The style loss is somewhat trickier, but not too much. The authors of the original NMT paper used what is called the Gram matrix, sometimes also referred to as the Gramian matrix. The Gram matrix, despite its fancy name, is something that you’ve already seen at some point in your study of linear algebra. Given some matrix , the Gram matrix can be calculated as More strictly speaking, given a set of vectors , a Gram matrix can be calculated such that So how does the Gram matrix encode the stylistic similarities or differences between two images? Before I attempt at an explanation in words, I recommend that you check out this Medium article, which has helped me wrapped my own head around the different dimensions involved in the style loss term. This Medium article has also helped me gain more intuition on why the style loss is the way it is. The motivating idea is that, given an image and a layer in the feature extractor model, the activations each encode information coming from a filter. The resulting feature maps, therefore, contain information about some feature the model has learned, such as the presence of some pattern, shape, or object. By flattening each feature map and constructing a matrix of activations , where  is the number of filters and  is the width times height of each activation, we can now construct the Gram matrix. Effectively, the Gram matrix is a dot product of each rows of ; thus, if some th and th features tend to co-occur,  will have a large value. The key here is that the Gram matrix is largely location agnostic; all the information related to locations or positions in the image is lost in the calculation. This is expected, and in some ways desirable, since the style of an image is largely independent from its spatial features. Another key point is that, the style of an image can be thought of as an amalgamation of different combinations of each feature. For instance, Van Gogh’s style of painting is often associated with strong, apparent brush strokes. It is possible to decompose and analyze this style into a set of co-occurring features, such as thick line edges, curves, and so on. So in a sense, the Gram matrix encodes such information at different depths of the pretrained feature extractor, which is why it is fitting to use the Gram matrix for calculating style loss. Concretely, the equation for style loss goes as follows: The style loss is similar to content loss in the sense that it is also a sum of element-wise L2 norms of two matrices. The differences are that we are using the Gram matrix instead of the raw activations themselves, and that we have a scaling constant. But even this constant is a pretty minor change, as I have seen implementations where the style weight was made a trainable parameter as opposed to a fixed scalar. As stated earlier, this tutorial seeks to explain the original NMT algorithm. Subsequent NMT methods use an actual model instead of formulating NMT as an optimization problem in which we modify the generated image itself. The benefit of using an actual model is that it is quicker and more efficient; after all, it takes a lot of time to create a plausible image from some white noise (which is why we are going to use the clone of the content image for this tutorial—but even then, it is still very slow). Now that we have an understanding of how NMT works, let’s get down to the details. Let’s begin by importing necessary modules and handling some configurations for this tutorial. We will be using VGG 19 as our pretrained feature extractor model. We will be using five layers of the network to obtain intermediate representations of the input image. Below is a simple code that lets us achieve this task. In this case, we use the zeroth, fifth, tenth, 19tht, and 28th layers of the model. The output is a list that contains the representations of the input image. It’s time to read, load, and preprocess some images. Below is a simple helper function we will use to read an image from some file directory, then apply any necessary resizing and transformations to the image. Next, let’s define some transformations we will need. The VGG model was trained with a specific transformation configuration, which involves normalizing RGB images according to some mean and standard deviation for each color channel. These values are specified below. We will apply this transformation after loading the image. The application of this transformation will be handled by the  function we’ve defined earlier. Later on in the tutorial, we will also need to undo the transformation to obtain a human presentable image. The following  operation accomplishes this task. While the numbers might look like they came out of nowhere, it’s actually just a reversal of the operation above. Specifically, given a normalizing operation we can undo this normalization via In other words, the reverse transformation can be summarized as And thus it is not too difficult to derive the values specified in the reverse transformation . Now, let’s actually load the  style and content images. We also create a target image. The original way to create the target image would be to generate some white noise, but I decided to copy the content image instead to make things a little easier and expedite the process. Note also that the code has references to some of my local directories; if you want to test this out yourself, make changes as appropriate. Now we are finally ready to solve the optimization problem! The next step would be to generate intermediate representations of each image, then calculate the appropriate loss quantities. Let’s start by defining some values, such as the learning rate, weights, print steps, and others. Below is a helper function that we will be using to save images as we optimize. This will help us see the changes in style as we progress throughout the optimization steps. Finally, this is where all the fun part takes place. For each step, we obtain intermediate representations by triggering a forward pass. Then, for each layer, we calculate the content loss and style loss. The code is merely a transcription of the loss equations as defined above. In particular, calculating the Gram matrix might appear a little bit complicated, but all that’s happening is that we are effectively flattening each activation to make it a single matrix, then calculating the Gram via matrix multiplication with its transpose. We see that style loss decreases quite a bit, whereas the content loss seems to slightly increase with each training step. As stated earlier, it is difficult to optimize on both the content and style, since altering the style of the picture will end up affecting its content in one way or another. However, since our goal is to stylize the target image via NMT, it’s okay to sacrifice a little bit of content while performing NMT, and that’s what is happening here as we can see from the loss values. And here is the result of the transformation!  The result is… interesting, and we certainly see that somethings have changed. We see some more interesting texture in the target image, and there appears to be some changes. However, at this point, my laptop was already on fire, and more training did not seem to yield any better results. So I decided to try out other sample implementations of NMT to see how using more advanced NMT algorithms could make things any better. I decided to try out fast neural style transform, which is available on the official PyTorch GitHub repository. Fast NMT is one of the more advanced, recent algorithms that have been studied after the original NMT algorithm, which we’ve implemente above, was introduced. One of the many benefits of fast neural style transfer is that, instead of framing NMT as an optimization problem, FNMT makes it a modeling problem. In this instance, TransformerNet is a pretrained model that can transform images into their stylized equivalents. The code below was borrowed from the PyTorch repository. I decided to try out FNMT on a number of different pictures of myself, just to see how different results would be for each. Here, we loop through the directory and obtain the file path to each content photo. And here are the results!  Among the 20 photos that have been stylized, I think some definitely look better than others. In particular, I think the third row looks kind of scary, as it made every photo have red hues all over my face. However, there are definitely ones that look good as well. Overall, FNMT using pretrained models definitely yielded better results than our implementation. Of course, this is expected since the original NMT was not the most efficient algorithm; perhaps we will explore FNMT in a future post. But all in all, I think diving into the mechanics behind NMT was an interesting little project. I hope you’ve enjoyed reading this post. Catch you up in the next one!",0,0,1,0,0,0,1,0
