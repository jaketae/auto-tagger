title,body,probability_distribution,analysis,linear_algebra,pytorch,machine_learning,from_scratch,statistics,deep_learning
Naive Bayes Model From Scratch,"As per convention of this tutorial, the returned dictionary has keys corresponding to each class and values indicating the likelihood that the  belongs to that class. We can see the  function in action by passing a dummy test instance. We are almost done! All that we have to do is to create a funcition that returns the predicted label of a testing instance given some labeled training data. Implemenitng this process is straightforward since we have all the Bayesian ingredients we need, namely the prior and the likelihood. The last step is to connect the dots with Bayes’ theorem by calculating the product of the prior and likelihood for each class, then return the class label with the largest posterior, as illustrated below. Let’s see if the  works as expected by seeing if passing as argument , for which we know that its label is 1, actually returns 1. The function is only able to process a single testing instance. Let’s complete our model construction by writing the  function that takes labeled data and a testing set as its argument to return a  array containing the predicted class labels for each instance in the testing set. Done! Let’s import some data from the  library. The wine set data is a classic multi-class classfication data set.",0,0,0,0,1,1,0,0
Logistic Regression Model from Scratch,"The data we will be looking at is the banknote authentification data set, publicly available on the UCI Machine Learning Repository. This data set contains 1372 observations of bank notes, classified as either authentic or counterfeit. The five features columns of this data set are: Let’s use some modules to import this data set onto our notebook, as shown below. The imported data set was slightly modified in two ways to fit our model. First, I separated the class label data from the data set and stored it as a separate  array. Second, I appended s to each observation to create a new column that accounts for intercept approximation. All this means is that we consider our linear model to be where for all available sample observations. This is something that we have been assuming all along throughout the gradient descent derivation process, but had not been stated explicitly to reduce confusion. Just consider it a strategic choice on our part to simplify the model while allowing for the logistic regression model to consider bias. Let’s check the shape of the imported data set to check that the data has been partitioned correctly. Now, it’s time to split the data into training and testing data. To do this, I recycled a function we built earlier in the previous post on k-nearest neighbors algorithm. Using , we can partition the data set into training and testing data. Let’s make 20 percent of observations as testing data and allocate the rest for training.",0,0,0,0,1,1,0,0
Logistic Regression Model from Scratch,"The idea is that we want to get a dot product of the weight vector and the data vector, then plug the resulting value into the sigmoid function to get some value between 0 and 1. The  function shown below exactly performs this task, with the added caveat that it returns a label prediction when the boolean argument  is set to ; a raw sigmoid output when the same is set to . Let’s perform a quick sanity check by using some dummy weight vector. Using the coefficients in the  list, we can generate predictions for each observation in the . The actual class information is stored in the  list. The dummy coefficients are poorly optimized, which is why the predicted class labels do not align well with the actual class labels. This tells us that more tuning is required to update the coefficients and build a robust logistic regression model. But how exactly can we tune our model? Simply eyeballing the actual and predicted labels of our data is probably not going to help us much. To optimize the coefficients to best fit our data, we need to construct some loss function—that is, a function that describes how badly our model is performing. Then, we can optimize the weights of our model by minimizing that loss function, which would mean that our model gradually makes better predictions with each round of optimization. If you recall the previous post on entropy, you will remember that we discussed a concept called cross entropy.",0,0,0,0,1,1,0,0
Introduction to tf-idf,"This is because the way we built ordinal indexing in corpus is probably different from how scikit-learn implements it internally. This point notwithstanding, it’s clear that the values of each vectors are identical, disregarding the fact that the result produced by our algorithm has more decimal points due to floating point arithmetic. This was a short introductory post on tf-idf vectors. When I first heard about tf-idf vectors from a friend studying computational linguistics, I was intimidated. However, now that I have a project I want to complete, namely an auto-tagging and classification NLP model, I’ve mustered more courage and motivation to continue my study the basics of NLP. I hope you’ve enjoyed reading this post. Catch you up in the next one! (Yes, this is a trite ending comment I use in almost every post, so the idf scores for the words in these two sentences are going to be very low.).",0,0,0,0,0,1,0,0
Recommendation Algorithm with SVD,"The takeaway is that dimensionality reduction is a meaningful way to extract important information from our data. Now that we have performed SVD on the ratings matrix, let’s move onto the last step: crafting a model for our recommendation algorithm. My personal pet theory is that using any word in conjunction with “algorithm” makes the concept sound more complex than it actually is. This is exactly what we are doing here, because in reality, our so-called algoithm for movie recommendations is going to be very simple. The intuition behind the recommendation system is distance calculation. Simply put, if users have similar movie preferences, the points representing the two users will appear to be close when plotted on a graph. Let’s see what this means by plotting  using . This can be achieved with the following code. We can pass  as an argument for the  function to see a three-dimensional plot of users’ movie preferences, as shown below.  Note that the points corresponding to User 6 and User 8 exactly overlap, which is why the points look darker despite being positioned near the corner of the plot. This is also why we can only count seven points in total despite having plotted eight data points. In short, this visualization shows how we might be able to use distance calculation to give movie recommendations to a new user. Assume, for instance, that we get a new suscriber to our movie application.",0,0,1,0,0,1,0,0
Wonders of Monte Carlo,"We all know from basic geometry that the value of  approximates to . There are obviously various ways to derive this value. Archimedes famously used hexagons to estimate that the value of  lies between . With later advances in math, mathematicians began to approach this problem from the angle of infinite series or products, the result of which were the Leibniz formula, Wallis product, Euler product, and the likes. And of course, modern computing now allows us to borrow the prowess of machinery to calculate this quantity with extreme accuracy. While the maths behind these derivations are fascinating, our approach will not take these routes; instead, we will use a crude Monte Carlo method. First, we draw a two-by-two square, inside of which we inscribe a circle of radius 1. For convenience purposes, let’s center this circle and square both at the origin. Next, we generate a series of random coordinates within the region of the square. Then, we count the percentage of dots that fall within the area of the cricle. Using a simple formula of proportions, we can calculate the area of the circle, through which we can then estimate the value of . Before we get into the specifics of this algorithm, let’s see hwo this plays out in code. Now that we have the function ready, let’s try calling it with some input parameters. Below, we perform our little crude Monte Carlo simulation with a hundred randomly generated data points. Invoking the  function returns the value of the estimation.",0,0,0,0,0,0,1,0
On Expectations and Integrals,"Imagine this process as being similar to what we learn in Calculus 101, where integrals are visualized as an infinite sum of skinny rectangles as the limit approaches zero. Essentially, we are doing the same thing, except that now, the base of each rectangle is defined as the difference between  and  instead of  and  as is the case with the Riemann integral. Another way to look at this is to consider the integral as calculating the area beneath the curve represented by the parameterization . This connection becomes a bit more apparent if we consider the fact that the Riemann integral is calculating the area beneath the curve represented by . In other words, the Riemann-Stieltjes integral can be seen as dealing with a change of variables. You might be wondering why the Riemann-Stieltjes integral is necessary in the first place. After all, the definition of expectation we already know by heart should be enough, shouldn’t it? To answer this question, consider the following  function: This cumulative mass function is obviously discontinuous since it is a step-wise function. This also means that it is not differentiable; hence, we cannot use the definition of expectation that we already know. However, this does not mean that the random variable  does not have an expected value.",0,0,0,0,0,0,1,0
Fisher Score and Information,"To begin, let’s write out the full expression of the expectation in integral form. If we evaluate this integral at the true parameter, i.e. when , The key part of this derivation is the use of the Leibniz rule, or sometimes known as Feynman’s technique or differentiation under the integral sign. I am most definitely going to write a post detailing in intuitive explanation behind why this operation makes sense in the future, but to prevent unnecessary divergence, for now it suffices to use that rule to show that the expected value of Fisher’s score is zero at the true parameter. Things start to get a little more interesting (and more complicated) as we move onto the discussion of Fisher’s Information Matrix.  There are two sides of the coin that we will consider in this discussion: Fisher’s information as understood as the covariance matrix of the score function, and Fisher’s information as understood as a Hessian of the negative log likelihood. The gist of it is that there are two different ways of understanding the same concept, and that they provide intriguing complementary views on the information matrix. Before jumping into anything else, perhaps it’s instructive to review variance, covariance, and the covariance matrix. Here is a little cheat sheet to help you out (and my future self, who will most likely be reviewing this later as well). An intuitive way to think about variance is to consider it as a measure of how far samples are from the mean.",0,0,0,0,0,0,1,0
Principal Component Analysis,"It is not difficult to see that the trace of , which is a scalar in the one-dimensional case, is maximized when  is an eigenvector of  with the largest eigenvalue. Generalizing this result back to , we see that  is a matrix whose columns correspond to the eigenvectors of  in descending order. If you had prior exposure to PCA, you might know that the standard way of obtaining principal components is by calculating the covariance matrix of the data and finding its eigenvectors. Here, I attempt to present an explanation of how and why the procedure outlined in the preceding section is essentially achieving the same tasks, albeit through a different frame of thought. The unbiased sample covariance matrix is given by Of course, this is operating under the assumption that  has already been standardized such that the mean of the data is zero. You might be thinking that the formulation in (14) looks different from the one introduced previously on this post on SVD. In that particular post, I stated that covariance could be calculated as (14) and (15) certainly look different. However, under the hood, they express the same quantity. So in a nutshell, the conclusion we arrived at in the preceding section with the minimization of residual sums ultimately amounts to finding the covariance matrix and its eigenvectors.",0,0,1,0,0,0,1,0
"PyTorch, From Data to Modeling","These past few weeks, I’ve been powering through PyTorch notebooks and tutorials, mostly because I enjoyed the PyTorch API so much and found so many of it useful and intuitive. Well, the problem was that I ended up writing something like ten notebooks without ever publishing them on this blog. So really, I’m going over some old notebooks I’ve coded out more than a month ago to finally make it live. That’s enough excuses, let’s get into the basics of PyTorch modeling in this notebook with the CIFAR10 dataset and some basic CNNs. The setup is pretty simple here. We import some modules and functions from PyTorch, as well as  to be able to show some basic training plots. One thing I have noticed is that a lot of people do something like which I personally don’t really get, because you can easily just do If you ask me, I think the latter is more elegant and less cluttered (after all, we don’t have to repeat  twice). I don’t think the two import statements are functionally different, but if I do figure out any differences, I will make sure to update future notebooks. One of the many nice things about PyTorch is the clean, intuitive API. PyTorch comes with good GPU support, and one of the main ways through which this can be done is by creating a  object. Because I am running this notebook on my MacBook Pro, which obviously does not come with Nvidia cuda-enabled graphics cards, the device is set as the CPU.",0,0,0,1,0,0,0,1
The Magic of Euler’s Identity,"At a glance, Euler’s identity is a confusing, mind-boggling mishmash of numbers that somehow miraculously package themselves into a neat, simple form: I remember staring at this identity in high school, trying to wrap my head around the seemingly discordant numbers floating around the equation. Today, I want to share some ideas I have learned since and demonstrate the magic that Euler’s identity can play for us. The classic proof for Euler’s identity flows from the famous Taylor series, a method of expressing any given function in terms of an infinite series of polynomials. I like to understand Taylor series as an approximation of a function through means of differentiation. Recall that a first-order derivative gives the slope of the tangent line at any given point of a function. The second-order derivative provides information regarding the convexity of the function. Through induction, we can convince ourselves that higher order derivatives will convey information about the curvature of the function throughout coordinate system, which is precisely the underlying mechanism behind Taylor’s series. In a more concise notation, we have Notice that  is the starting point of our approximation. Therefore, the Taylor series will provide the most accurate estimation of the original function around that point, and the farther we get away from , the worse the approximation will be. For the purpose of our analysis, let’s examine the Taylor polynomials for the following three functions: , and . Recall that the derivative of  is , which is precisely what the Taylor series suggests.",0,1,0,0,0,0,0,0
The Math Behind GANs,"Through a partial derivative of  with respect to , we see that the optimal discriminator, denoted as , occurs when Rearranging (12), we get And this is the condition for the optimal discriminator! Note that the formula makes intuitive sense: if some sample  is highly genuine, we would expect  to be close to one and  to be converge to zero, in which case the optimal discriminator would assign 1 to that sample. On the other hand, for a generated sample , we expect the optimal discriminator to assign a label of zero, since  should be close to zero. To train the generator, we assume the discriminator to be fixed and proceed with the analysis of the value function. Let’s first plug in the result we found above, namely (12), into the value function to see what turns out. To proceed from here, we need a little bit of inspiration. Little clever tricks like these are always a joy to look at. If you are confused, don’t worry, you aren’t the only one. Basically, what is happening is that we are exploiting the properties of logarithms to pull out a  that previously did not exist. In pulling out this number, we inevitably apply changes to the terms in the expectation, specifically by dividing the denominator by two. Why was this necessary? The magic here is that we can now interpret the expectations as Kullback-Leibler divergence: And it is here that we reencounter the Jensen-Shannon divergence, which is defined as where .",0,0,0,0,0,0,1,1
Natural Gradient and Fisher,"Now, the update rule would be To solve for the argument minima operation, we will resort to the classic method for optimization: Lagrangians. In this case, the Lagrangian would be This immediately follows from using the constraint condition. To make progress, let’s use Taylor approximation again, both on the term for the loss function and the KL divergence. The good news is that we have already derived the expression for the latter. Noting the fact that there are several constants in this expression, we can simplify this into To minimize this expression, we set its gradient equal to zero. Note that we are deriving with respect to . Therefore, We are finally done with our derivation. This equation tells us that the direction of steepest descent is defined by the inverse of the Fisher matrix multiplied by the gradient of the loss function, up to some constant scaling factor. This is different from the vanilla batch gradient descent we are familiar with, which was simply defined as Although the difference seems very minor—after all, all that was changed was the addition of Fisher’s matrix—yet the underlying concept, as we have seen in the derivation, is entirely different. This was definitely a math-heavy post. Even after having written this entire post, I’m still not certain if I have understood the details and subtleties involved in the derivation. And even the details that I understand now will become confusing and ambiguous later when I return back to it.",0,0,0,0,1,0,1,0
Wonders of Monte Carlo,"There are a plethora of mathematical techniques that build on top of crude Monte Carlo to ensure that sampling is done correctly and more efficiently, such as importance sampling, but for the purposes of this post, we will stop here and move onto the last task: simulating random walk. The last task we will deal with in this post is simulating what is known as the drunkard’s walk, a version of which is introduced here. The drunkard’s walk is a type of random walk with a specified termination condition. As the name suggests, the drunkard’s walk involves a little story of an intoxicated man trying to reach (or avoid) some destination, whether that be a cliff or, in our case, a restroom. Because he is drunk, he cannot walk to the restroom in a straight path as a normal person would do; instead, he stumbles this way and that, therefore producing a random walk. Our goal here is to simulate this motion many times to estimate the probability that the man would successfully end up in the restroom to go about his business. This example was borrowed from this post by Zacharia Miller. Before we start typing up some code, let’s first lay down the ground rules of this simulation. First, we assume that the pub is modeled as a ten-by-ten grid, the bottom-left point defined as  and the top-right . The drunkard will start his walk at his table, represented by the coordinate .",0,0,0,0,0,0,1,0
Gaussian Mixture Models,"Before we get into the details of what the EM algorithm is, it’s perhaps best to provide a very brief overview of how the EM algorithm works. A very simple way to understand EM is to think of the Gibbs sampler. Simply put, Gibbs sampling is a way of approximating some joint distribution given conditional distributions. The underlying idea was to sample from one distribution and use that sampled result to in turn generate another sample from the next conditional distribution. One might visualize this as a chain of circular dependence: if we obtain a sample from past samples, the new sample can then be used to generate the next sample. Repeat this process until convergence, and we are done. Turns out that the Gibbs sampler can be considered a specific flavor of the EM method. Although I am still far away from fully understanding the inner-workings of the EM algorithm, the underlying idea is clear: given some sort of dependence relationship, much like we saw in the case of Gibbs sampling above, we can generate some sample in one iteration and use that sample in the next. As we will see in this section, such a relationship can clearly be established, which is why EM is so commonly used in the context of Gaussian mixture models. Let’s begin by defining some quantities, the first being the posterior distribution.",0,0,0,0,1,0,1,0
Moments in Statistics,"We have not looked specifically at the exponential distribution in depth previously, but it is a distribution closely related to the , which we derived in this post. Specifically, when parameter  in a Gamma distribution, it is in effect an exponential distribution. Perhaps we will explore these relationships, along with the Erlang distribution, in a future post. For now, all we have to know is the probability density function of the exponential distribution, which is This time, the task is to obtain the third moment of the distribution, i.e. . But the fundamental approach remains identical: we can either use the definition of expected values to calculate the third moment, or compute the MGF and derive it three times. At a glance, the latter seems a lot more complicated. However, it won’t take long for us to see that sometimes, calculating the MGF is sometimes as easy as, if not easier than, taking the expected values approach. Let’s twist up the order and try the MGF method first. We can pull out the lambda and combine the exponential terms to get This is an easy integral. Let’s proceed with the integration and evaluation sequence: Now, all we have to do is to derive the result in (12) three time and plug in . Although calculating the third order derivative may sound intimidating, it may seem easier in comparison to evaluating the integral which would require us to use integration by parts.",1,0,0,0,0,0,1,0
"Linear Regression, in Two Ways","But before we jump into it, let’s briefly go over some basics of matrix calculus, which is the variant of calculus we will be using throughout. Much like we can derive a function by a variable, say  or , loosely speaking, we can derive a function by a matrix. More strictly speaking, this so-called derivative of a matrix is more formally known as the gradient. The reason why we introduced the gradient as a derivative by a matrix is that, in many ways, the gradient in matrix calculus resembles a lot of what we saw with derivatives in single variable calculus. For the most part, this intuition is constructive and helpful, and the few caveats where this intuition breaks down are beyond the purposes of this post. For now, let’s stick to that intuition as we venture into the topic of gradient. As we always like to do, let’s throw out the equation first to see what we’re getting into before anything else. We can represent the gradient of function  with respect to matrix  is a matrix of partial derivatives, defined as While this formula might seem complicated, in reality, it is just a convenient way of packaging partial derivatives of the function into a compact matrix. Let’s try to understand what this operation entails through a simple dummy example. As you can see, instead of a m-by-n matrix, we have a column vector  as an ingredient for a function.",0,0,1,0,0,0,0,0
The Exponential Family,"As you might recall from a previous post on some very basic matrix calculus, the gradient is simply a way of packaging derivatives in a multivariate context, typically involving vectors. If any of this sounds unfamilar, I highly recommend that you check out the linked post. We can compute the partial derivative of the log likelihood function with respect to  as shown below. Observe that the last term in (18) is eliminated because it is a constant with respect to . This is a good starting point, but we still have no idea how to derive the log of . To go about this problem, we have to derive an expression for . Recall from the definition of the exponential family that  is a normalizing constant that exists to ensure that the probability function integrates to one. In other words, This necessarily implies that Now that we have an expression for  to work with, let’s try to compute the derivative term we left unsolved in (19). The first and second equalities stand due to the chain rule, and the third equality is a simple algebraic manipulation that recreates the probability function within the integral, allowing us to ultimately express the partial derivative as an expected value of  for the random variable . This is a surprising result, and a convenient one indeed, because we can now use this observation to conclude that the gradient of the log likelihood function is simply the expected value of the sufficient statistic.",1,0,0,0,0,0,1,0
(Attempt at) Knowledge Distillation,"Finally, we train a brand new student model through knowledge distillation. And interestingly enough, the knowledge distilled student model records an accuracy score of 98.1 percent. Why might have been the case? There are several things I think were happening in this example. The first is that the teacher model did not have enough helpful dark knowledge. In this experiment, I trained both the teacher and student models for 10 epochs. In retrospect, the teacher model should have been trained for a longer period of time to achieve the best performance possible, and thus learn enough helpful dark knowledge that could then be distilled onto the student network. Had we used some huge ImageNet-based model on CIFAR 100, we would have probably seen more interesting results through distillation. This relates to my second hypothesis, which is that the dataset was perhaps too simple for the networks. The student network was able to achieve a 98 percent point accuracy by training on the hard labels. This perhaps suggests that what we used as the student network itself could have been a teacher network of its own. Perhaps the student model should have been an even smaller network than the one we experimented with here. Although our attempt at knowledge distillation did not quite go as we had expected, nonetheless I think it was a great opportunity for me to learn about an exciting area of research. I also think understanding knowledge distillation will be helpful when using larger transformer models.",0,0,0,1,0,0,0,1
My First GAN,"This process of putting the pieces together, or adjoining the models, is where I personally find the genius in GAN design. The key takeaway here is that we define  and . As you might imagine, the shape of the input is defined by  we defined earlier. This is the latent space from which we will sample a random noise vector frame to feed into our GAN. Then, the connection between the generator and the discriminator is effectively established by the statement . All this is saying is that GAN’s output is the evaluation of the generator’s fake image by the discriminator. If the generator does well, it will fool the discriminator and thus output 1; 0 vice versa. Let’s take a look at the code implementation of this logic.  Now it’s time to train our model. Let’s first load our dataset. For this, we will be using the  images. The dataset contains low resolutions images, so our output is also going to be very rough, but it is a good starting point nonetheless. One hacky thing we do is concatenating the training and testing data. This is because for a GAN, we don’t need to differentiate the two: on the contrary, the more data we have for training, the better. One might suggest that testing data is necessary for the discriminator, which is a valid point, but the end goal here is to build a high performing generator, not the discriminator, so we will gloss over that point for now.",0,0,0,0,0,0,0,1
"Linear Regression, in Two Ways","We can further specify this equation by using the fact that  can be expressed as a linear combination of the columns of . In other words, where  is the solution to the system of equations represented by . Let’s further unpackage (1) using matrix multiplication. Therefore, We finally have a formula for : Let’s remind ourselves of what  is and where we were trying to get at with projection in the context of regression. We started off by plotting three data points, which we observed did not form a straight line. Therefore, we set out to identify the line of best fit by expressing the system of equations in matrix form, , where . But because this system does not have a solution, we ended up modifying the problem to , since this is as close as we can get to solving an otherwise unsolvable system. So that’s where we are with equation (2): a formula for , which contains the parameters that define our line of best fit. Linear regression is now complete. It’s time to put our equation to the test by applying it to our toy data set. Let’s apply (2) in the context of our toy example with three data points to perform a quick sanity check. Calculating the inverse of  is going to be a slight challenge, but this process is going to be a simple plug-and-play for the most part.",0,0,1,0,0,0,0,0
Introduction to tf-idf,"As a final step, we normalize the result to ensure that longer documents do not overshadow shorter ones. Normalizing is pretty simple, so we’ll assume that we have a function  that does the job for now. Before we test the code, we obviously need to implement . This can simply done by obtaining the sum of the L2 norm of each vector, then dividing each element by that constant. Here is an easy contrived example we can do in our heads: And now we’re done! If let’s print the tf-idf vectors for each of the four documents in the dummy example. It seems about right, as all the vectors appear normalized and are of the desired dimensions. However, to really verify the result, it’s probably a good idea to pit our algorithm against scikit-learn’s implementation. In scikit-learn, the  does all the job. To transform the data to tf-idf vectors, we need to create an instance of the  and call its method, . And here are the results: There are several observations to be made about this result. First, note that the default return type of  is a sparse matrix. Sparse matrices are a great choice since many of the entries of the matrix will be zero—there is probably no document that contains every word in the corpus. Therefore, sparse representations can save a lot of space and compute time. This is why we had to call  on the result. Second, you might be wondering why the order of elements are different.",0,0,0,0,0,1,0,0
Building Neural Network From Scratch,"I was almost about to stop here, but then decided that I wanted to express the neural network model as a Python class. After all, that is how actual machine learning and deep learning libraries are implemented. I also decided that it can’t hurt for me to practice object-oriented thinking. So presented in the next section is a nicer, cleaner implementation of a neural network model based off of the functions we designed above. A simple neural network model in just 56 lines of code, ready to be initialized, trained, deployed, and tested! You will see that much of the code is literally just copy and pasted from the original functions we designed above. But just to make sure that everything works fine, let’s try creating a neural network object and use the  function to see how well our model performs. I chose 99 as the number of neurons in the affine layers for no reason. In this instance, the accuracy of this model is 95 percent, similar to what we had above. At this point, one question that popped up in my mind was the relationship between the number of neurons and the performance of the neural network model. Intuitively, the more neurons there are, the higher the memory capacity of that model, and thus better the performance. Of course, the larger the number of neurons, the larger the risk of overfitting our model, which can also negatively impact the performance of the neural network. This is conventional wisdom in the land of deep learning.",0,0,1,0,0,1,0,1
Scikit-learn Pipelines with Titanic,"We opt to drop it instead. Correlation (or somewhat equivalently, covariance) is a metric that we always care about, since ultimately the goal of ML engineering is to use a set of input features to generate a prediction. Given this context, we don’t want to feed our model useless information that lacks value; instead, we only want to feed into the model highly correlated, relevant, and informative features. If certain features in the raw data are deemed useless, we need to either drop it or engage in some sort of feature engineering to produce a new set of more correlated features.  From this preliminary analysis, it seems like there are some very weekly correlated features, namely  and . The week correlation suggests that perhaps we need to engage in some feature engineering to extract more meaningful information out of the dataset. Let’s use the findings from the previous section to engineer some more informative features. One popular approach is to make use of names to derive a  feature. Intuitively, this makes sense: Mr. and Mrs, Cpt. and Dr. might be of interest for our model. Another popular approach is to combine the less important features— and —into something like . Implementing these should fairly be simple, so let’s try it here. Note that in an actual setting, there will be no answer to reference; we will have to rely on our own domain knowledge and more extensive EDA to figure out which features matter, and what new features we will need.",0,0,0,0,1,0,0,0
On Expectations and Integrals,"In fact, it is possible to calculate the expectation using the Riemann-Stieltjes integral quite easily, despite the discontinuity! The integral we wish to calculate is the following: Therefore, we should immediately start visualizing splitting up the domain of integration, the real number line, into infinitesimal pieces. Each box will be of height  and width . In the context of the contrived example, this definition makes the calculation extremely easy, since   equals zero in all locations but the jumps where the discontinuities occur. In other words, We can easily extend this idea to calculating things like variance or other higher moments. A more realistic example might be the Dirac delta function. Consider a constant random variable (I know it sounds oxymoronic, but the idea is that the random variable takes only one value and that value only). In this case, we can imagine the probability density function as a literal spike in the sense that the PDF will peak at  and be zero otherwise. The cumulative density function will thus exhibit a discontinuous jump from zero to 1 at . And by the same line of logic, it is easy to see that the expected value of this random variable is , as expected. Although this is a rather boring example in that the expectation of a constant is of course the constant itself, it nonetheless demonstrates the potential applications of Riemann-Stieltjes. I hope you enjoyed reading this post. Lately, I have been busy working on some interesting projects.",0,0,0,0,0,0,1,0
Dissecting the Gaussian Distribution,"We can also see why (9) is coherent by unpacking the expected values expression as shown below: Using the linearity of expectation, we can rewrite the equation as Therefore, we end up with which almost exactly parallels the definition of variance, which we might recall is where . The key takeaway is that the covariance matrix constructed from the random vector  is the multivariable analogue of variance, which is a function of the random variable . To gain a better idea of what the covariance matrix actually looks like, however, it is necessary to review its structure element-by-element. Here is the brief sketch of the -by- covariance matrix. This might seem complicated, but using the definition of covariance in (8), we can simplify the expression as: Note that the covariance matrix is a symmetric matrix since . More specifically, the covariance matrix is a positive semi-definite matrix. This flows from the definition of positive semi-definiteness. Let  be some arbitrary non-zero vector. Then, You might be wondering how (9) ends up as (10). Although this relationship may not be immediately apparent, that the two expressions are identical can be seen by setting the random vector as and performing basic matrix vector multiplication operations. For the sake of brevity, this is left as an exercise for the reader. We now have all the pieces we need to complete the puzzle. Recall that we were trying to derive the probability density function of the multivariate Gaussian by building on top of the formula for the univariate Gaussian distribution.",1,0,0,0,0,0,1,0
On Expectations and Integrals,"Expectation is a core concept in statistics, and it is no surprise that any student interested in probability and statistics may have seen some expression like this: In the continuous case, the expression is most commonly presented in textbooks as follows: However, this variant might throw you off, which happened to me when I first came across it a few weeks ago: I mean, my calculus is rusty, but it kind of makes sense: the probably density function is, after all, a derivative of the cumulative density function, and so notationally there is some degree of coherency here. But still, this definition of the expected value threw me off quite a bit. What does it mean to integrate over a distribution function instead of a variable? After some research, however, the math gurus at Stack Exchange provided me with an answer. So here is a brief summary of my findings. The integral that we all know of is called the Riemann integral. The confusing integral is in fact a generalization of the Riemann integral, known as the Riemann-Stieltjes integral (don’t ask me how to pronounce the name of the Dutch mathematician). There is an even more general interpretation of integrals called the Lebesgue integral, but we won’t get into that here. First, let’s take a look at the definition. The definition of the integral is actually a lot simpler than what one might imagine. Here,  is a value that falls within the interval . In short, we divide the interval of integration  into  infinitesimal pieces.",0,0,0,0,0,0,1,0
Neural Style Transfer,"Subsequent NMT methods use an actual model instead of formulating NMT as an optimization problem in which we modify the generated image itself. The benefit of using an actual model is that it is quicker and more efficient; after all, it takes a lot of time to create a plausible image from some white noise (which is why we are going to use the clone of the content image for this tutorial—but even then, it is still very slow). Now that we have an understanding of how NMT works, let’s get down to the details. Let’s begin by importing necessary modules and handling some configurations for this tutorial. We will be using VGG 19 as our pretrained feature extractor model. We will be using five layers of the network to obtain intermediate representations of the input image. Below is a simple code that lets us achieve this task. In this case, we use the zeroth, fifth, tenth, 19tht, and 28th layers of the model. The output is a list that contains the representations of the input image. It’s time to read, load, and preprocess some images. Below is a simple helper function we will use to read an image from some file directory, then apply any necessary resizing and transformations to the image. Next, let’s define some transformations we will need. The VGG model was trained with a specific transformation configuration, which involves normalizing RGB images according to some mean and standard deviation for each color channel. These values are specified below.",0,0,0,1,0,0,0,1
Dissecting LSTMs,"Notice that we use a  activation instead of a sigmoid, since the aim of (3) is not to produce a filter with sparse entries, but rather to generate substance, or potential information to be stored in memory. This is more in line with the classic vanilla neural network architecture we are familiar with. Now, we can finally glue the pieces together to understand (4): we enforce forgetfulness, then supply the cell state with new information. This is now the updated cell state, which gets passed onto the next sequence as new inputs are fed into the LSTM. So far, we have only looked at the recurrent features of LSTM; in other words, how it uses information from the past to update its knowledge in the present at time . However, we haven’t yet discussed the most important part of any neural network: generating output. Obviously, all that hassle of forgetting and updating the cell state would be utterly meaningless if the cell state is not used to generate output. The whole purpose of maintaining a cell state, therefore, is to imitate long and short-term memory of the brain to generate some output. Thus, it is no surprise that the following two equations are structured the way they are: First, we see the familiar forward pass, a familiar structure we have seen earlier. Borrowing the analogy we established in the previous post,  is a filter that decides which information to use and drop.",0,0,0,0,0,0,0,1
Dissecting the Gaussian Distribution,"So far, we’ve looked at the univariate Gaussian, which involved only one random variable . However, what if the random variable in question is a vector that contains multiple random variables? It is not difficult to see that answering this question requires us to think in terms of matrices, which is the go-to method of packaging multiple numbers into neat boxes, known as matrices. Instead of deriving the probability distribution for the multivariate Gaussian from scratch as we did for the univariate case, we’ll build on top of the equation for the univariate Gaussian to provide an intuitive explanation for the multivariate case. In a previous post on linear regression, we took a look at matrix calculus to cover basic concepts such as the gradient. We established some rough intuition by associating various matrix calculus operations and their single-variable calculus analogues. Let’s try to use this intuition as a pivot point to extend the univariate Gaussian model to the multivariate Gaussian. For readability sake, here is the univariate model we have derived earlier. Examining (7), the first observation we might make is that  is no longer a coherent expression in the multivariable context. The fix to this is extremely simple: recall that in vector world. Therefore, we can reexpress (7) as This is the result of simply changing the squared term.",1,0,0,0,0,0,1,0
Convex Combinations and MAP,"And we have derived the MAP estimate for the mean of the univariate Gaussian! Maximum a posteriori analysis is great and all, but what does the final result exactly tell us? While there might be many ways to interpret understand the result as derived in (9), one particular useful intuition to have relates to the concept of convex combinations. Simply put, a convex combination is a linear combination of different points or quantities in which the coefficients of the linear combinations add up to one. More concretely, We can also imagine that  and  are each -dimensional vectors, and that a convex combination is simply a dot product of these two vectors given that the elements of  sum up to one. Why did I suddenly bring up convex combinations out of no where? Well, it turns out that the result in (9) in fact an instance of a convex combination of two points satisfying the form Indeed, it is not difficult to see that the coefficient of  and  add up to 1, which is precisely the condition for a linear combination to be considered convex. Now here is the important part: the implication of this observation is that we can consider the MAP estimate of parameter  as an interpolation, or more simply, some weighted average between  and . This interpretation also aligns with the whole notion of Bayesian inference: our knowledge of the parameter is partially defined by the prior, but updated as more data is introduced.",0,0,0,0,0,0,1,0
PyTorch Tensor Basics,"Observe that the addition is not reflected in , indicating that no operations happened in-place. , however, achieves the result without copying and creating a new tensor into memory. is another common function that is used to resize tensors. It has been part of the PyTorch API for quite a long time before  was introduced. Without getting into too much technical detail, we can roughly understand view as being similar to  in that it is not an in-place operation. However, there are some notable differences. For example, this Stack Overflow post introduces an interesting example: On the other hand,  does not run into this error. The difference between the two functions is that, whereas  can only be used on contiguous tensors. This SO thread gives a nice explanation of what it means for tensors to be contiguous; the bottom line is that, some operations, such , do not create a completely new tensor, but returns a tensor that shares the data with the original tensor while having different index locations for each element. These tensors do not exist contiguously in memory. This is why calling  after a transpose operation raises an error. , on the other hand, does not have this contiguity requirement. This felt somewhat overly technical, and I doubt I will personally ever use  over , but I thought it is an interesting detail to take note of nonetheless. Another point of confusion for me was the fact that there appeared to be two different ways of initializing tensors:  and .",0,0,0,1,0,0,0,1
The Exponential Family,"First,  denotes a -dimensional random variable of interest; , a -dimensional parameter that defines the probability distribution.  is known as the sufficient statistic function. Below is a brief summary concerning the mappings of these different functions. You will notice that I used  and  instead of  and  as shown in equation (3). This is because (3) assumes vectorization of these functions as follows. We could have expressed (3) without vectorization, but doing so would be rather verbose. So we instead adhere to the vectorized convention in (3) throughout this post. As I hinted earlier, the exponential family covers a wide range of probability distributions, most PDFs and PMFs. In fact, most probability distributions that force themselves onto the page of statistics textbooks belong to this powerful family. Below is a non-comprehensive list of distributions that belong to the exponential family. Probability Density Functions Probability Mass Functions Of course, there are examples of common distributions that do not fall under this category, such as the uniform distribution or the student -distribution. This point notwithstanding, the sheer coverage of the exponential family makes it worthy of exploration and analysis. Also, notion of an exponential family itself is significant in that it allows us to frame problems in meaningful ways, such as through the notion of conjugate priors: if you haven’t noticed, the distributions outlined above all have conjugate priors that also belong to the exponential family.",1,0,0,0,0,0,1,0
Building Neural Network From Scratch,"Recall that our neural network is structured as follows: The last layer is a softmax unit that receives input  to produce output . Our goal, then, is to compute the gradient where  and  each represent the values taken by the th and th neuron in layers  and , respectively. One point of caution is that it is important to consider whether  and  are equal, as this produces differences in the calculation of the gradient. First consider the case when : When : We see that the gradient is different in the two cases! This is certainly going to important for us when calculating the gradient of , the cross entropy loss function, with respect to . Specifically, we have to consider the two cases separately by dividing up the summation expression into two parts, as shown below: That was a long ride, but in the end, we end up with a very nice expression! This tells us that the gradient of the cross entropy loss function with respect to the second affine layer is simply the size of the error term. In other words, if we expand the result in (13) to apply to the entire matrix of layers, we get This provides a great place for us to start. We can commence from here to find the gradient of the loss function with respect to other layers more further down the neural network.",0,0,1,0,0,1,0,1
Building Neural Network From Scratch,"Welcome back to another episode of “From Scratch” series on this blog, where we explore various machine learning algorithms by hand-coding them from scratch. So far , we have looked at various machine learning models, such as kNN, logistic regression, and naive Bayes. Now is time for an exciting addition to this mix: neural networks. Around last year December, I bought my first book on deep learning, titled Deep Learning from Scratch,  by Saito Goki. It was a Korean translation of a book originally published in Japanese by O’Reilly Japan. Many bloggers recommended the book as the go-to introductory textbook on deep learning, some even going as far as to say that it is a must-have. After reading a few pages in, I could see why: as the title claimed, the author used only  to essentially recreate deep learning models, ranging from simple vanilla neural networks to convolutional neural networks. As someone who had just started to learn Python, following the book was a lot harder than expected, but it was a worthwhile read indeed. Inspired by that book, and in part in an attempt to test the knowledge I gained from having read that bok, I decided to implement my own rendition of a simple neural network supported by minibatch gradient descent. Let’s jump right into it. The default setup of my Jupyter Notebook, as always: Before we start building our model, we should first prepare some data.",0,0,1,0,0,1,0,1
Traveling Salesman Problem with Genetic Algorithms,"Now, we will select  number of parents to be the basis of the next generation. Here, we use a simple roulette model, where we compare the value of the probability vector and a random number sampled from a uniform distribution. If the value of the probability vector is higher, the corresponding chromosome is added to . We repeat this process until we have  parents. As expected, we get 4 parents after selecting the parents through . Now is the crucial part: mutation. There are different types of mutation schemes we can use for our model. Here, we use a simple swap and crossover mutation. As the name implies, swap simply involves swapping two elements of a chromosome. For instance, if we have , we might swap the first two elements to end up with . The problem with swap mutation, however, is the fact that swapping is a very disruptive process in the context of TSP. Because each chromosome encodes the order in which a salesman has to visit each city, swapping two cities may greatly impact the final fitness score of that mutated chromosome. Therefore, we also use another form of mutation, known as crossovers. In crossover mutation, we grab two parents. Then, we slice a portion of the chromosome of one parent, and fill the rest of the slots with that of the other parent. When filling the rest of the slots, we need to make sure that there are no duplicates in the chromosome. Let’s take a look at an example.",0,0,0,0,0,1,0,0
"Linear Regression, in Two Ways",") In our case, we love orthogonality because they are key to deriving the equation for the line of best fit through projection. To see what this means, let’s quickly assume a toy example to work with: assume we have three points,  and , as shown below.  As we can see, the three points do not form a single line. Therefore, it’s time for some regression. Let’s assume that this line is defined by . The system of equations which we will attempt to solve looks as follows: Or if you prefer the vector-matrix representation as I do, This system, remind ourselves, does not have a solution because we have geometrically observed that no straight line can pass through all three points. What we can do, however, is find a projection of the vector  onto matrix  so that we can identify a solution that is closest to , which we shall denote as . As you can see, this is where all the linear algebra kicks in. Let’s start by thinking about , the projection of  onto . After some thinking, we can convince ourselves that  is the component of  that lives within the column space of , and that  is the error component of  that lives outside the column space of . From this, it follows that  is orthogonal to , since any non-orthogonal component would have been factored into . Concretely, since the transpose is an alternate representation of the dot product.",0,0,1,0,0,0,0,0
BLEU from scratch,"Let’s see if the simple precision metric is able to capture this intuition. And indeed that seems to be the case! However, the simple precision-based metric has some huge problems. As an extreme example, consider the following  candidate translation. Obviously,  is a horrible translation, but the simple precision metric fails to flag it. This is because precision simply involves checking whether a hit occurs or not: it does not check for repeated bag of words. Hence, the original authors of BLEU introduces modified precision as a solution, which uses clipped counts. The gist of it is that, if some n-gram is repeated many times, we clip its count through the following formula: Here,  refers to the number of hits we assign to a certain n-gram. We sum this value over all distinct n-grams in the candidate sentence. Note that the distinction requirement effectively weeds out repetitive translations such as  we looked at earlier.  refers to the number of occurrences of a n-gram in the candidate sentence. For example, in , the unigram  appears 13 times, and so . This value, however, is clipped by , which is the maximum number of occurrence of that n-gram in any one of the reference sentences. In other words, for each reference, we count the number of occurrence of that n-gram and take the maximum value among them. This can seem very confusing, but hopefully it’s clearer once you read the code. Here is my implementation using . Notice that we use a  in order to remove redundancies.",0,0,0,0,0,1,0,1
Fisher Score and Information,"Fisher’s information is an interesting concept that connects many of the dots that we have explored so far: maximum likelihood estimation, gradient, Jacobian, and the Hessian, to name just a few. When I first came across Fisher’s matrix a few months ago, I lacked the mathematical foundation to fully comprehend what it was. I’m still far from reaching that level of knowledge, but I thought I’d take a jab at it nonetheless. After all, I realized that sitting down to write a blog post about some concept forces me to study more, so it is a positive, self-reinforcing cycle. Let’s begin. Fisher’s score function is deeply related to maximum likelihood estimation. In fact, it’s something that we already know–we just haven’t defined it explicitly as Fisher’s score before. First, we begin with the definition of the likelihood function. Assume some dataset  where each observation is identically and independently distributed according to a true underlying distribution parametrized by . Given this probability density function , we can write the likelihood function as follows: While it is sometimes the convention that the likelihood function be denoted as , we opt for an alternative notation to reserve  for the loss function. To continue, we know that the maximum likelihood estimate of the distribution’s parameter is given by This is the standard drill we already know.",0,0,0,0,0,0,1,0
Wonders of Monte Carlo,"Although the rate of convergence dramatically decreases after the first few iterations, the pattern of convergence is apparrent. So how does this work? The mechanism is extremely simple: if we were to randomly generate an infinite number of dots, the proportion of the number of dots that fall within the circle versus those that do not fall within it would converge to some constant, i.e. . Why is this the case? Intuitively, the larger the area, the larger the number of points that fall into that area. Given this proportional relationship, the number of randomly generated points in an area after a simulation would mirror the actual area of the circle and the rectangle, hence the proportional expression above. By following this line of reasoning, we can then resort to Monte Carlo to generate these random points, after which we can make a reasonable estimation of . But approximation is not the only domain in which Monte Carlo methods become useful–they can also be used to calculate complicated integrals. We all know from calculus class that integration can be difficult. Everyone has encountered integrals of varying monstrosity at one point in their lives, scrambling to solve it with integration by parts or some obscure, creative substitution, only to realize that everything wounds up in the middle of nowhere. Well, good news for all of us—Monte Carlo methods can be used to estimate the value of mind-pulverizing, complicated definite integrals.",0,0,0,0,0,0,1,0
Introduction to tf-idf,"In short, document frequency tells us how frequently a given word appears throughout all documents; the inverse is the reciprocal of that quantity. In practice, we often apply a logarithm to prevent the idf score from exploding. Also, we add some smoothing to prevent division by zero. There seems to be many variations of how smoothing is implemented in practice, but here I present one way that seems to be adopted by scikit-learn. For other schemes, refer to this table on Wikipedia. However, this is a mere technically; the intuition we motivated earlier still applies regardless. With these ideas in mind, let’s go implement tf-idf vectorization in Python! In this section, we will develop a simple set of methods to convert a set of raw documents to tf-idf vectors, using a dummy dataset. Below are four documents (again, I know they’re short) that we will be using throughout this tutorial. The first step is to preprocess and tokenize the data. Although the specifics of preprocessing would probably differ from task to task, in this simple example, we simply remove all punctuations, change documents to lower case letters, and tokenize them by breaking down documents into a bag of words. Other possible techniques not discussed here include stemming and lemmatization. The  function accepts as input a set of documents and removes all the punctuation in each document. Here is the result of applying our function to the dummy data. Next, we need to tokenize the strings by splitting them into words.",0,0,0,0,0,1,0,0
"Linear Regression, in Two Ways","We can further break this expression down by taking note of the fact that the norm of a vector can be expressed as a product of the vector and its transpose, and that  as established in the previous section of this post. Putting these together, Using distribution, we can simplify the above expression as follows: It’s time to take the gradient of the error function, the matrix calculus analogue of taking the derivative. Now is precisely the time when the propositions (4) and (5) we explored earlier will come in handy. In fact, observe that first term in (6) corresponds to case (5); the second term, case (4). The last term can be ignored because it is a scalar term composed of , which means that it will not impact the calculation of the gradient, much like how constants are eliminated during derivation in single-variable calculus. Now, all we have to do is to set the expression above to zero, just like we would do in single variable calculus with some optimization problem. There might be those of you wondering how we can be certain that setting this expression to zero would yield the minimum instead of the maximum. Answering this question requires a bit more math beyond what we have covered here, but to provide a short preview, it turns out that our error function, defined as  is a positive definite matrix, which guarantees that the critical point we find by calculating the gradient gives us a minimum instead of a maximum.",0,0,1,0,0,0,0,0
How lucky was I on my shift?,"Simply put, a binomial distribution simulates multiple Bernoulli trials, which are experiments with only two discrete results, such as heads and tails, or more generally, successes and failures. A binomial random variable  can be defined as the number of success in  repeated trials with probability of success . For example, if we perform ten tosses of a fair coin, the random variable would be the number of heads;  would be , and  would be . Mathematically, the probability distribution function of a binomial distribution can be written as follows: We can derive this equation by running a simple thought experiment. Let’s say we are tossing a coin ten times. How can we obtain the probability of getting one head and nine tails? To begin with, here is the list of all possible arrangements: Notice that all we had to do was to choose one number  that specifies the index of the trial in which a coin toss produced a head. Because there are ten ways of choosing a number from integers  to , we got ten different arrangements of the situation satisfying the condition . You might recall that this combinatoric condition can be expressed as , which is the coefficient of the binomial distribution equation. Now that we know that there are ten different cases, we have to evaluate the probability that each of these cases occur, since the total probability , where . Calculating this probability is simple: take the first case,  as an example.",1,0,0,0,0,0,1,0
Dissecting the Gaussian Distribution,"Concretely, this statement might be translated as We can separate the variables to achieve the following expression: Integrating both sides yields Let’s get rid of the logarithm by exponentiating both sides. That’s an ugly exponent. But we can make things look better by observing that the constant term  can be brought down as a coefficient, since where we make the substitution . Now, the task is to figure out what the constants  and  are. There is one constraint equation that we have not used yet: the integral of a probability distribution function must converge to 1. In other words, Now we run into a problem. Obviously we cannot calculate this integral as it is. Instead, we need to make a clever substitution. Here’s a suggestion: how about we get rid of the complicated exponential through the substitution Then, it follows that Therefore, the integral in (1) now collapses into Now that looks marginally better. But we have a very dirty constant coefficient at the front. Our natural instinct when we see such a square root expression is to square it. What’s nice about squaring in this case is that the value of the expression is going to stay unchanged at 1. Because the two integrals are independent, i.e. calculating one does not impact the other, we can use two different variables for each integral. For notational convenience, let’s use  and .",1,0,0,0,0,0,1,0
Neural Style Transfer,"Pretrained models, such as the VGG network, have filters that are capable of extracting features from an image. It is known that low level convolutional filters that are closer to the input can extract low-level features such as lines or curves, whereas deeper layers are trained to have activation maps that respond to specific shapes or patterns. Notice that this is in line with what the content loss should be able to encode: the general lines and curves of the image should remain similar, as well as the location or presence of general objects like eyes, nose, or hands, to give some concrete examples. Thus, the content loss is simply the L2 norm of the features extracted from each target layer of some pretrained model . Do not let the notation confuse you. All this means is that we sum over each layers of the pretrained model . For each of these layers, we calculate matrix element-wise L2 norm of the content and generated image features extracted by the th layer of the model. If we sum all of them up, we obtain the value of the content loss. Intuitively, we can think of this as comparing both high level and low level features between the two images. The style loss is somewhat trickier, but not too much. The authors of the original NMT paper used what is called the Gram matrix, sometimes also referred to as the Gramian matrix.",0,0,0,1,0,0,0,1
A sneak peek at Bayesian Inference,"Notice that this line of code directly corresponds to the formula for the updated Beta posterior distribution we found earlier, which is  refers to ,  corresponds to , and both  and  are set to  in order to take into account the initial prior which tends to a uniform distribution. An interesting observation we can make about this result is that the variance of the Beta posterior decreases with more trials, i.e. the narrower the distribution gets. This is directly reflective of the fact that we grow increasingly confident about our estimate of the parameter with more tosses of the coin. At the end of the 500th trial, we can conclude that the coin is fair indeed, which is expected given that we simulated the coin flip using the command . If we were to alter the argument for this method, say , then we would expect the final result of the update to reflect the coin’s bias. Bayes’ theorem is a powerful tool that is the basis of Bayesian statistical analysis. Although our example was just a simple coin toss, the sample principle and mechanism can be extended to countless other situations, which is why Baye’s theorem remains highly relevant to this day, especially in the field of machine learning and statistical analysis. Bayesian statistics presents us with an interesting way of understanding probability. The classical way of understanding probability is the frequentist approach, which purports that a probability for an event is the limit of its frequency in infinite trials.",1,0,0,0,0,0,1,0
"Newton-Raphson, Secant, and More","Below is a Python variant of the backward divided difference formula. Some tweaks have been made to the formula for use in the section that follows, but at its core, it’s clear that the function uses the approximation logic we’ve discussed so far. Another variant of the forward and backward divided difference formula is the center divided difference. By now, you might have some intuition as to what this formula is—as the name implies, we somehow use the center point, instead of going forward or backwards from the point of approximation. Here is the formula: Heuristically, this formula also makes sense. We can imagine going both a step forward and backward, then dividing the results by the total of two steps we’ve taken, one in each direction. Shown below is the Python implementation of the center divided difference formula. According to conventional mathematical wisdom, the center divided method normally provides a more robust way of approximating first order derivatives. In this subsection, we discuss why this is the case. Using Taylor expansion, we can approximate the value of  as follows, given that  goes to 0 under the limit. Notice that we can manipulate (4) to derive the forward divided difference equation in (1). If we move the  term to the LHS, then divide both sides by , we end up with Here, we used big-O notation to denote the order of magnitude of the trailing terms. The trailing terms are significant since they are directly related to the accuracy of our approximation.",0,1,0,0,0,0,0,0
"Linear Regression, in Two Ways","If there is one thing I recall most succinctly from my high school chemistry class, it is how to use Excel to draw basic plots. In the eyes of a naive freshman, visualizations seemed to add an air of professionalism. So I would always include a graph of some sort in my lab report, even when I knew they were superfluous. The final icing on the cake? A fancy regression with some r-squared. In today’s post, I want to revisit what used to be my favorite tinkering toy in Excel: regression. More specifically, we’ll take a look at linear regression, which deals with straight lines and planes instead of curved surfaces. Although it sounds simple, the linear regression model is still widely used because it not only provides a clearer picture of obtained data, but can also be used to make predictions based on previous observations. Linear regression is also incredibly simple to implement using existing libraries in programming languages such as Python, as we will later see in today’s post. That was a long prologue—–let’s jump right in. In this section, we will attempt to frame regression in linear algebra terms and use basic matrix operations to derive an equation for the line of best fit. In this section, we will use linear algebra to understand regression. An important theme in linear algebra is orthogonality. How do we determine if two vectors—or more generally, two subspaces—are orthogonal to each other? How do we make two non-orthogonal vectors orthogonal? (Hence Gram-Schmidt.",0,0,1,0,0,0,0,0
Markov Chain and Chutes and Ladders,"” This simply means that the progress of the game depends only on the players’ current positions, not where they were or how they got there. A player might have ended up where they are by taking a ladder or by performing a series of regular dice rolls. In the end, however, all that matters is that the players eventually hit the hundredth cell. To perform a Markov chain analysis on the Chutes and Ladders game, it is first necessary to convert the information presented on the board as a stochastic matrix. How would we go about this process? Let’s assume that we start the game at the th cell by rolling a dice. There are six possible events, each with probability of . More specifically, we can end up at the index numbers 38, 2, 3, 14, 5, or 6. In other words, at position 0, where  and  denote the current and next position of the player on the game board, respectively. We can make the same deductions for other cases where . We are thus able to construct a 101-by-101 matrix representing the transition probabilities of our Chutes and Ladders system, where each column represents the system at a different state, i.e. the th entry of the th column vector represents the probabilities of moving from cell  to cell . To make this more concrete, let’s consider a program that constructs the stochastic matrix , without regards to the chutes and ladders for now.",0,0,1,0,0,0,0,0
"0.5!: Gamma Function, Distribution, and More","The link between the Poisson and Gamma distribution, then, is conveniently established by the fact that the time of the th arrival is lesser than  if more than  events happen within the time interval . This proposition can be expressed as an identity in the following form. Notice that the left-hand side is a cumulative distribution function of the Gamma distribution expressed in terms of . Given the derivative relationship between the CDF and PDF, we can obtain the probability distribution function of Gamma by deriving the right-hand side sigma expression with respect to . After some thinking, we can convince ourselves that unraveling the sigma results in a chain reaction wherein adjacent terms nicely cancel one another, ultimately collapsing into a single term, which also happens to be the first term of the expression: Recalling that , we can rewrite the expression as follows: Notice the structural identity between the form we have derived and the equation of the Gamma distribution function introduced above, with parameters , , and . In the language of Poisson, these variables translate to , , and , respectively. To develop and intuition of the Gamma distribution, let’s quickly plot the function. If we determine the values for the parameters  and , the term  reduces to some constant, say , allowing us to reduce the PDF into the following form: This simplified expression reveals the underlying structure behind the Gamma distribution: a fight for dominance between two terms, one that grows polynomially and the other that decays exponentially.",1,0,0,0,0,0,1,0
Principal Component Analysis,"Using (2), we can reorganize (4) as follows: The last equality is due to the fact that we constrained the columns of  to be unit vectors that are orthogonal to each other. Now we can take a derivative of the argument with respect to  and set it equal to zero to find the minimum. This tells us that the optimal way of compressing  is simply by multiplying it by the transpose of the decoding matrix. In other words, we have found the transformation  in (2). For those of you who are confused about how gradients and matrix calculus work, here is a very short explanation. First, notice that  is just a scalar, since  is a column vector. Taking a gradient with respect to this quantity would mean that we get another column vector of equal dimensions with  with the following elements: And we know how to go from there. The same line of thinking can be applied to think about the second term, . We know that  is a row vector since its dot product with  should be possible dimensionally speaking. Then, we know that the gradient with respect to  should give each of the elements of , but in column vector format—hence the need for a transpose. In general, the rule of thumb is that the gradient of a scalar with respect to a vector or a matrix should return a vector or matrix of the same dimension.",0,0,1,0,0,0,1,0
Gaussian Mixture Models,"In other words, given some data, what is the probability that it will belong to a certain class? Using the definition of conditional probability, we can arrive at the following conclusion: This represents the probability that, given some point , the point belongs in the th cluster. With this result, we can now rewrite the MLE calculation that we were performing earlier. Using the new  notation, we can thus simplify the result down to We can then simplify this expression to derive an expression for . An important trick is here to use the fact that the covariance matrix is positive semi-definite. Therefore, the covariance matrix plays no role in driving the value down to zero. With some algebraic manipulations, we arrive at Let’s introduce another notational device to simplify the expresison even further. Let Recall that  was defined to be the posterior probability that a given point  belongs to the th cluster. Then, since we are essentially summing up this quantity across the entire  data points in the dataset , we can interpret  to effectively be the number of points in the dataset that are assinged to the th cluster. Then, we can now simplify the MLE estimate of the mean as But we can now observe something interesting. Notice that a depend on . In turn,  is defined in terms of . This is the very circular dependency that we discussed earlier as we were introducing the EM algorithm and comparing it with the Gibbs sampler.",0,0,0,0,1,0,1,0
Likelihood and Probability,"For the purposes of this post, we look at the simplest way that involves just a bit of calculus. The best way to demonstrate how MLE works is through examples. In this post, we look at simple examples of maximum likelihood estimation in the context of normal distributions. We have never formally discussed normal distributions on this blog yet, but it is such a widely used, commonly referenced distribution that I decided to jump into MLE with this example. But don’t worry—we will derive the normal distribution in a future post, so if any of this seems overwhelming, you can always come back to this post for reference. The probability density function for the normal distribution, with parameters  and , can be written as follows: Assume we have a list of observations that correspond to the random variable of interest, . For each  in the sample data, we can calculate the likelihood of a distribution with parameters  by calculating the probability densities at each point of the PDF where . We can then make the following statement about these probabilities: In other words, to maximize the likelihood simply means to find the value of a parameter that which maximizes the product of probabilities of observing each data point. The assumption of independence allows us to use multiplication to calculate the likelihood in this manner. Applied in the context of normal distributions with  observations, the likelihood function can therefore be calculated as follows: But finding the maximum of this function can quickly turn into a nightmare.",0,0,0,0,0,0,1,0
Moments in Statistics,"More specifically, we can calculate the th moment of a distribution simply by taking the th derivative of a moment generating function, then plugging in 0 for parameter . We will see what  is in a moment when we look at the default formula for MGF. This sounds good and all, but why do we want an MGF in the first place, one might ask. Well, given that moments convey defining properties of a distribution, a moment generating function is basically an all-in-one package that contains every bit of information about the distribution in question. Enough of the abstract, let’s get more specific by taking a look at the mathematical formula for an MGF. If  is a continuous random variable, we would take an integral instead. Now, you might be wondering how taking the th derivative of  gives us the th moment of the distribution for the random variable . To convince ourselves of this statement, we need to start by looking at the Taylor polynomial for the exponential. It’s not difficult to see the coherency of this expression by taking its derivative—the derivative of the polynomial is equal to itself, as we would expect for . From here, we can sufficiently deduce that The coherency of (3) can simply be seen by making the substitution . To continue, now that we have an expression for , we can now calculate , which we might recall is the definition of a moment generating function. where the second equality stands due to linearity of expectation.",1,0,0,0,0,0,1,0
"Newton-Raphson, Secant, and More","An error term of  means that, if we halve the step size, we will also halve the error. This is best understood as a linear relationship between error and the step size. We can conduct a similar mode of analysis with backward divided difference. By symmetry, we can express  as If we rearrange (6), we end up with (2). Again, we see that backward divided difference yields linear error, or a trailing term of . Here’s where things get more interesting: in the case of center divided difference, the magnitude of the error term is , meaning that halving the step size decreases the error by four-folds. This is why center divided difference yields much more accurate approximations than forward or backward divided difference. To see this, we subtract (5) from (4), then move some terms, and divide both sides by . Notice that subtracting these two expression results in a lot of term cancellations. Dividing both sides by  yields From this result, we now know why the central divided difference method provides more accurate approximations of the derivative than do forward and backward divided difference. This is somewhat related to what we will be doing in the next section, so it’s a good intuition to have throughout when reading the rest of this article. Now that we have these tools for differential calculus, now comes the exciting part: solving non-linear equations. Specifically, we will be taking a look at two numerical methods: the Newton-Raphson method and the secant method.",0,1,0,0,0,0,0,0
Traveling Salesman Problem with Genetic Algorithms,"The children of one parent will not all have identical genes: due to mutation, which occurs by chance, some will acquire even more superior features that puts them far ahead of their peers. Needless to say, such beneficiaries of positive mutation will survive and leave offspring, carrying onto the next generation. Those who experience adversarial mutation, on the other hand, will not be able to survive. In genetic algorithm engineering, we want to be able to simulate this process over an extended period of time without hard-coding our solution, such that the end result after hundred or thousands of generations will contain the optimal solution. Of course, we can’t let the computer do everything: we still have to implement mutational procedures that define an evolutionary process. But more on that later. First, let’s begin with the simple task of building a way of modeling a population. First, let’s define a class to represent the population. I decided to go with a class-based implementation to attach pieces of information about a specific generation of population to that class object. Specifically, we can have things like  to represent the full population,  to represent th chosen, selected superior few,  to store the score of the best chromosome in the population,  to store the best chromosome itself, and , the adjacency matrix that we will be using to calculate the distance in the context of TSP. Here is a little snippet of code that we will be using to randomly generate the first generation of population.",0,0,0,0,0,1,0,0
(Attempt at) Knowledge Distillation,"is the added component, which is the KL divergence between the temperature-adjusted softmax outputs of the student and teacher models. Now that we have all the ingredients we need, let’s write the knowledge distillation training loop. In the loop, we invoke the  function, apply a weighted average, and backpropagate on the combined loss. One technicality we have not touched upon earlier is the fact that we need to apply some scaling to the KL divergence loss. The gradient of the  term, compared to , is smaller by a factor of . Thus, we need to multiply  to correct this difference in magnitude. Let’s also write a training loop for just training the model as is. We will essentially conduct a controlled experiment where we compare the result of knowledge distillation and vanilla training. And here is a simple evaluation function we will use to check the performance of each model at the end of training. Since we are merely evaluating the model, we don’t need to keep gradients. First, we train the teacher model. After 10 epochs, the teacher model manages to get an accuracy of around 98 percent. Next, we train the student model using the typical training scheme without knowledge distillation. Using this method, the student model manages to get an accuracy of 98 percent; in fact, 0.1 percentage point higher than that of the teacher model. At this point, I already knew that something was off, but I decided to continue with the experiment.",0,0,0,1,0,0,0,1
"Basel, Zeta, and some more Euler","The more I continue my journey down the rabbit hole of mathematics, the more often I stumble across one name: Leonhard Euler. Nearly every concept that I learn, in one way or another, seems to be built on top of some strand of his work, not to mention the unending list of constants, formulas, and series that bears his name. It is simply mind-blowing to imagine that a single person could be so creative, inventive, and productive to the extent that the field of mathematics would not be where it is today had it not been for his birth on April 15, 1707. Why such intensive fanboying, you might ask. Well, let’s remind ourselves of the fact that the interpolation of the factorial through the Gamma function was spearheaded by Euler himself. But this is just the start of the beginning. Consider, for example, the Basel problem, an infamous problem that mathematicians have been trying to solve for nearly a century with no avail, until the 28-year-old Euler came to the rescue. The Basel problem can be stated as follows: At a glance, this seems like a fairly simple problem. Indeed, we know that this series converges to a real value. We also know that integration would give us a rough approximation. However, how can evaluate this series with exactitude? Euler’s solution, simple and elegant, demonstrates his genius and acute heuristics.",0,1,0,0,0,0,0,0
Building Neural Network From Scratch,"This is what is at the heart of back propagation: in one huge swoop, we can obtain the gradient for all weights and parameters at once instead of having to calculate them individually. For a more detailed explanation of  this mechanism, I strongly recommend that you take a look at this excellent blog post written by Christopher Olah. How do we go about back propagation in the case of our model? First, it is necessary to define a loss function. The most commonly used loss function in the context of classification problems is cross entropy, which we explored in this post previously on this blog. For a brief recap, presented below is the formula for calculating cross entropy given a true distribution  and a predicted distribution : Our goal is to train our neural network so that is output distribution  is as close to  as possible. In the case of binary classification, we might alter equation (9) to the following form: The reformulation as shown in equation (10) is the formula for what is known as binary cross entropy. This is the equation that we will be using in the context of our problem, since the dataset we have only contains two class labels of 0 and 1. Now that we have an idea of what the loss function looks like, it’s time to calculate the gradient. Since we are going to be back propagating the gradient, it makes sense to start from the very back of the neural network.",0,0,1,0,0,1,0,1
Complex Fibonacci,"The takeaway from the code snippet is that holds, regardless of whether or not  is a non-negative integer. Indeed, Binet’s formula gives us what we might refer to as the interpolation of the fibonacci sequence, in this case extended along the real number line. A corollary of the real number interpolation of the fibonacci sequence via Binet’s formula is that now we can effectively plot the complex fibonacci numbers on the Cartesian plane. Because  can be continuous, we would expect some graph to appear, where the -axis represents real numbers, and , the imaginary. This requires a bit of a hack though; note that the result of Binet’s formula is a complex number, or a two-dimensional data point. The input to the function is just a one-dimensional real number. Therefore, we need a way of representing a map from a one-dimensional real number line to a two-dimensional complex plane. This is sort of tricky if you think about it: the normal two-dimensional plane as we know it can only represent a mapping from the -axis to the -axis—in other words, a transformation from one-dimensional space to another one-dimensional space. A three-dimensional -coordinate system, on the other hand, represents a transformation from a two-dimensional space, represented by  and , to another one-dimensional space, namely . We aren’t used to going to other way around, where a one-dimensional space is mapped to a two-dimensional space, as is the case here.",0,1,0,0,0,0,0,0
A Simple Autocomplete Model,"6: is a woman–what then? is there not ground 
for suspecting to and the world will had to a such that the basis of the incussions of the spirit as the does not because actian free spirits of intellect of the commstical purtious expression of men are so much he is not unnor experiences of self-conturity, and 
as anifegently religious in the man would not consciously, his action is not be actian at in accombs life for the such all procees of great and the heart of this conduct the spirity of the man can provate for in any 
once in any of the suriticular conduct that which own needs, when they are therefore, as 
such action and some difficulty that the strength, it, himself which has to its fine term of pricismans the exacte in its self-recuphing and every strength and man to wist the action something man as the worst, that the was of a longent that the whole not be all the very subjectical proves the stronger extent he is necessary to metaphysical figure of the faith in the bolity in the pure belief–as “the such a successes of the values–that is he ​ Generated text at temperature 0.",0,0,0,0,0,0,0,1
"Beta, Bayes, and Multi-armed Bandits","Simply put, regret refers to the amount that we have comparatively lost by making a sub-optimal choice from the get go. Here is a visual diagram I came across on Analytics Vidhya.  The maximum reward would obviously be achieved if we pull on the slot machine with the highest success parameter from trial 1. However, this does not happen since the gambler dives into the game without this prior knowledge. Hence, they have to learn what the optimal choice is through exploration and exploitation. It is of course in this learning process that the greedy algorithm or Bayesian analysis with Thompson sampling comes into play. The amount that we have theoretically lost—or, in other words, the extent to which we are far away from the maximum amount we could have earned—is denoted as regret. Thus, to maximize reward is to minimize regret, and vice versa. Now let’s simulate a hundred pulls on the lever using Bayesian analysis using the Beta-Binomial model and Thompson sampling. Nothing much fancy here, all we’re doing is Thompson sampling from the Beta distribution via , then obtaining the index of the bandit with the highest parameter, then pulling the machine that corresponds to that index. We will also keep cumulative track of our results to reproduce the regret diagram shown above. And we’re done with the hundred round of simulations! Hopefully our simulator gambler has made some good choices by following Bayesian update principles, with the Beta-Binomial model and Thompson sampling under their belt.",1,0,0,0,0,0,1,0
The Gibbs Sampler,"The goal is to derive is the conditional distribution, . This derivation was heavily adapted from this source and this thread on Stack Exchange. It is certainly a somewhat lengthy derivation, but there is nothing too conceptually difficult involved—it’s just a lot of algebra and simplifications. We begin from the formula for the multivariate Gaussian: For convenience purposes, let Then, Let Note that this is not a one-to-one correspondence, i.e. . The blocks are only one-to-one insofar as being dimensionally equivalent. Then, using block matrix multiplication, Notice that the final result should be a single scalar given the dimensions of each matrix. Therefore, we can further simply the expression above using the fact that . Specifically, the second and third terms are transposes of each other. Although we simply resorted a convenient substitution in (6), we still need to derive an expression for the inverse of the covariance matrix. Note that the inverse of the covariance matrix can intuitively be understood as the precision matrix. We won’t derive the block matrix inversion formula here. The derivation is just a matter of simply plugging in and substituting one expression for another. For a detailed full derivation, checkout this link or this journal article. To cut to the chase, we end up with Plugging these results back into (8), and with some elided simplification steps, we end up with Note that we can more conveniently express the result in the following fashion: We’re now almost done.",0,0,1,0,0,0,1,0
k-Nearest Neighbors Algorithm from Scratch,"We can achieve this by building a function as shown below. Passing 100 to the  argument results in a list of accuracy scores. We can go through this list and try to see for which value of  accuracy is maximized. But this is a rather tedious job, and things would get quickly out of control if we were to deal with much larger data sets where the value of  can be set to much larger numbers. Instead, let’s create a visualization to see how accuracy changes with respect to .  The plot shows that accuracy is maximized for many values of , not just 1. Also, we can learn that accuracy does not go beyond the 97 percent we saw earlier, which is a bit of sad news. An interesting insight we can glean, however, is that accuracy seems to drop past some certain thresholds, most notably around 80. One reasonable explanation might be that the model is looking at too many neighbors that it cannot produce a reliable estimate. At any rate, this visualization shows that hyperparameter tuning is an important job of a machine learning engineer—even if the model is great, if the wrong  value is used, the model will only demonstrate lackluster performance. This was perhaps the first post where we dealt with a machine learning algorithm. ML is sometimes treated as a black box, where some magic beneath the hood produces desirable results.",0,0,0,0,1,1,0,0
k-Nearest Neighbors Algorithm from Scratch,"As we can see, the KNN algorithm is extremely simple, but if we have enough data to feed it, it can produce some highly accurate predictions. There are still missing pieces to this puzzle, such as how to find the nearest neighbors, but we will explore the specifics of the algorithm on the go as we build the model from scratch. For now, just remember the big picture. Let’s get into the nuts and bolts of the KNN model. Below are the dependencies we will need for this demonstration. One problem we need to start thinking about is how to measure distance between two data points. After all, the implementation of KNN requires that we define some metric to measure the proximity between different points, rank them in order, and sort the list to find  nearest neighbors. One way to go about this is to use Euclidean distance, which is defined as follows: It is not difficult to build an implementation of in Python. We can easily achieve this using . Let’s test the functionality of the  function using some dummy dataset. This data set was borrowed from Jason Brownlee. Great! As expected, the distance between a point and itself is 0, and other calculated distances also seem reasonable. The next step is to write a function that returns the  nearest neighbors of a point given a data set and parameter . There are many ways to implement this, but an example is shown below.",0,0,0,0,1,1,0,0
My First GAN,"As this competition progresses, the generator becomes increasingly better at creating fake images; the discriminator also starts to excel at determining the veracity of a presented image. Enough of theoretical dwellings, let’s begin by defining the generator model. The  is a function that returns a generator model according to some set parameters. Let’s take a look at the structure of this network in more detail.  Notice that the output of the generator is a batch image of dimensions . This is exactly the same as the , , and  information we defined earlier, and that is no coincidence: in order to fool the discriminator, the generator has to generate images that are of the same dimensions as the training images from ImageNet. Now it’s time to complete the GAN by creating a corresponding discriminator, the discerning police officer. The discriminator is essentially a simple binary classier that ascertains whether a given image is true or fake. Therefore, it is no surprise that the final output layer will have one neuron with a sigmoid activation function. Let’s take a more detailed look at the  function as shown below. And again, a model summary for convenient reference:  Now we have both the discriminator and the generator, but the two are not really connected in the sense that they exist as discrete models lacking any connection between them. What we want to do, however, is to establish some relationship between the generator and the discriminator to complete a GAN, and hence train them in conjunction.",0,0,0,0,0,0,0,1
Better seq2seq,"Most of the enhancements were already baked into the decoder, and the fundamental logic through which predictions are generated remain unchanged. Thus, only minimal changes have to be made to the seq2seq model: namely, we need to handle the context vector and pass it to the decoder at every time step. And from here on, the details are exactly identical; the same  and  functions can be used in the previous post. Since I intended this post to be a simple little exercise as opposed to a fully blown out tutorial, we’ll stop here, but by all means, feel free to experiment more with it. Below are the configurations Ben Trevett used in his tutorial. When I was writing this notebook, I realized that I enjoy thinking about the dimensional details of each tensor being passed around here and there. It is difficult, and sometimes it required me to use dirty print statements to actually log what was happening to each variable, but all in all, I think attention to dimensional detail is definitely something that one should practice and think about when modeling. I hope you enjoyed reading this post. In a future post, we will explore what attention is and how to bake it into a seq2seq model to take it to the next level. Also, happy holidays!.",0,0,0,1,0,0,0,1
The Math Behind GANs,"Therefore, we might consider the following to be the loss function of the discriminator: Here, we are using a very generic, unspecific notation for  to refer to some function that tells us the distance or the difference between the two functional parameters. (If this reminded you of something like cross entropy or Kullback-Leibler divergence, you are definitely on the right track.) We can go ahead and do the same for the generator. The goal of the generator is to confuse the discriminator as much as possible such that it mislabels generated images as being true. The key here is to remember that a loss function is something that we wish to minimize. In the case of the generator, it should strive to minimize the difference between 1, the label for true data, and the discriminator’s evaluation of the generated fake data. A common loss function that is used in binary classification problems is binary cross entropy. As a quick review, let’s remind ourselves of what the formula for cross entropy looks like: In classification tasks, the random variable is discrete. Hence, the expectation can be expressed as a summation. We can simplify this expression even further in the case of binary cross entropy, since there are only two labels: zero and one. This is the  function that we have been loosely using in the sections above.",0,0,0,0,0,0,1,1
Building Neural Network From Scratch,"We don’t have to worry about the dimensionality of the bias since  supports broadcasting by default. Presented below is a visualization of our neural network, created using NN-SVG. Instead of cluttering the diagram by attempting to visualize all 64 neurons, I decided to simplify the picture by assuming that we have 16 neurons in each of the affine layers. But with the power of imagination, I’m sure it’s not so much difficult to see how the picture would change with 64 neurons.  Hopefully the visualization gave you a better understanding of what our model looks like. Now that we have a function that creates our model, we are ready to run the model! At this point, our neural network model is only a dictionary that contains matrices of specified sizes, each containing randomly genereated numbers. You might be wondering how a dictionary can be considered a model—after all, a dictionary is merely a data structure, and so is incapable of performing any operations. To make our model to work, therefore, we need a function that performs matrix multiplications and applies activation functions based on the dictionary. The  function is precisely such a function that uses the weights stored in our model to return both the intermediary and final outputs, denoted as  and  respectively.  Note that we apply activation functions, such as  and  when appropriate. This process of deriving an output from an input using a neural network is known as forward propagation.",0,0,1,0,0,1,0,1
An Introduction to Markov Chain Monte Carlo,"Of course, this code is limited in that is only applicable to a very specific situation, namely the task of deriving the posterior given a normal prior and a normal likelihood with known variance. Nevertheless, we can glean so much insight from this fascinating function. Let’s quickly test the  function by making it sample five estimations of the mean parameter. As expected, the sampler starts from the 0, which is the default argument  and took a jump at the second sample. After that jump, the sampler rejects the next three values sampled from the proposal distribution, as it stayed dormant at the value 0.17414333. However, with more iterations, we would expect the function to make more jumps, gradually painting a picture of what the posterior should look like. In fact, we can create what is called the trace plot to see which values were sampled by the Metropolis-Hastings algorithm. Trace plots are important because they tell us whether or not our model is well-calibrated, i.e. a sufficient amount of state changes occur.  The trace plot contains the trace of 15000 accepted values sampled from the proposal distribution. We see that there are some fluctuations, indicating that state transitions occurred, but also that there seems to be values that the sampler preferred over others. Eyeballing the trace plot, the “comfort zone” seems to be slightly above 0, as we expect. To illustrate the importance of trace plots, let’s see an example involving a bad setup involving a proposal distribution with too small a variance.",0,0,0,0,0,1,0,0
Markov Chain and Chutes and Ladders,"The indexing is key here: for each column, th rows were assigned the probability of . Let’s say that a player is in the th cell. Assuming no chutes or ladders, a single roll of a dice will place him at one of the cells from  to ; hence the indexing as presented above. However, this algorithm has to be modified for  bigger or equal to 95. For example if , there are only three probabilities: , , and , each of values , , and  respectively. The  statements are additional corrective mechanisms to account for this irregularity. So now we’re done with the stochastic matrix! … or not quite. Things get a bit more complicated once we throw the chutes and ladders into the mix. To achieve this, we first build a dictionary containing information on the jump from one cell to another. In this dictionary, the keys correspond to the original position; the values, the index of the cell after the jump, either through a chute or a ladder. For example,  represents the first ladder on the game board, which moves the player from the first cell to the thirty eighth cell. To integrate this new piece of information into our code, we need to build a permutation matrix that essentially “shuffles up” the entries of the stochastic matrix  in such a way that the probabilities can be assigned to the appropriate entries.",0,0,1,0,0,0,0,0
Gaussian Process Regression,"Here, we modify (9) to have an added parameter, , which is a multiplicative constant to the exponent. The  function simply uses double iteration to fill each entry of the covariance matrix. Note that  and  do not have to be identical in length; if their lengths are different, the resulting kernel matrix will simply be rectangular. This is expected given that the components of , namely  in (19), will never be square unless the number of test and training points are equal. Now let’s generate some dummy data. In theory, the final function sampled through GP is considered an infinite dimensional vector, but for practical reasons of implementation, the vector in this case will be at most 60 dimensions: ten training points and 50 test points, appended together as one vector. Next, let’s build the kernel with the test points and draw random samples to see what our prior looks like. Recall that sampling can be easily achieved by performing the Cholesky decomposition on the kernel. Let’s plot the ten random samples drawn from the prior. Note that at this point, we have not seen any training data at all. The only stricture imposed on GP vis a vis the kernel is the fact that the function must be smooth, i.e. points that are close to each other in must be highly correlated.  Indeed, the sampled data seems to present somewhat smooth curves, although the smoothness is somewhat mitigated by the fact that the model are only vectors of 50 dimensions.",0,0,0,0,1,1,0,0
Riemann Zeta and Prime Numbers,"Before we get into the specifics, below are the dependencies we will need. The first function we will build is one that randomly samples  natural numbers from 1 to , and checks if all number pairs within this sample is coprime. For this, we use , which reduces the result of applying  to two pairs of numbers in the randomly sampled number list.  is a quite common operation in functional programming, and we saw an example of this operation in the context of Spark in a previous post as well. Let’s see this function in action. I’ve added a  flag for convenience of testing and demonstration. Let’s toggle this option on for now and see what we get. The GCD of 6, 7, and 1 are 1, so the returned result is  as we expect. We also notice that three numbers were returned since . Next, we define a testing function that will simulate multiple runs of the  test for us. Because this is a Monte Carlo simulation, to have confidence in our estimate, we need to iterate the sampling process multiple times until we have sufficient amount of data. The  parameter determines the number of simulations we will perform. And much like in the previous  function, the  parameter determines the upper bound of our sampling range. Therefore, the total number of simulations we run will effectively be  times. Last but not least,  indicates how many numbers we want to sample each time—this parameter is semantically identical to the  parameter we saw in the  function above.",0,1,0,0,0,0,0,0
"Newton-Raphson, Secant, and More","Recently, I ran into an interesting video on YouTube on numerical methods (at this pont, I can’t help but wonder if YouTube can read my mind, but now I digress). It was a channel called numericalmethodsguy, run by a professor of mechanical engineering at the University of Florida. While the videos themselves were recorded a while back in 2009 at just 240p, I found the contents of the video to be very intriguing and easily digestable. His videos did not seem to assume much mathematical knowledge beyond basic high school calculus. After watching a few of his videos, I decided to implement some numerical methods algorithms in Python. Specifically, this post will deal with mainly two methods of solving non-linear equations: the Newton-Raphson method and the secant method. Let’s dive right into it. Before we move on, it’s first necessary to come up with a way of representing equations in Python. For the sake of simplicity, let’s first just consider polynomials. The most obvious, simplest way of representing polynomials in Python is to simply use functions. For example, we can express  as However, a downside of this approach is the fact that it’s difficult to directly derive this equation despite the fact that it is nothing more than just a simple polynomial. So instead, we will use a list index-based representation. Namely, the  th element of a list represents the coefficient of the th power in a polynomial equation. In other words,  would translate into .",0,1,0,0,0,0,0,0
The Gibbs Sampler,"The full result is available on Wikipedia, but it’s always more interesting and rewarding to derive these results ourselves. But in this section, we will assume that we already know the final result of the derivation and use the formula for now. Note that the two functions are symmetrical, which is expected given that this is a bivariate distribution. These functions simulate a conditional distribution, where given a value of one random variable, we can sample the value of the other. This is the core mechanism by which we will be sampling from the joint probability distribution using the Gibbs sampling algorithm. Let’s initialize the parameters for the distribution and test the sampler. Great! This works as expected. For the purposes of demonstrating the implications of burn-in, let’s define discard the first 100 values that were sampled. Below is the plot of the final resulting distribution based on sampled values using the Gibbs sampler. The result is what we would expect: a bivariate Gaussian.  And this is what we end up with if we sample directly from the bivariate Gaussian instead of using the Gibbs sampler. Note that we can do this only because we chose a deliberately simple example; in many other contexts, this would certainly not be the case (if we could sample from a distribution directly, why use the Gibbs sampler in the first place?). Notice the similarity between the result achieved by sampling from the Gibbs sampler and the result produced from direct sampling as shown below.",0,0,1,0,0,0,1,0
