title,body,from_scratch,linear_algebra,deep_learning,tensorflow,statistics,machine_learning,analysis,probability_distribution
Gaussian Process Regression,"I think this is the most fascinating part about GPs—as we will see later on, GPs do not require us to specify any function or model to fit the data. Instead, all we need to do is to identify the mean and covariance of a multivariate Gaussian that defines the posterior of the GP. All of this sounds too good be true—how can a single multivariate Gaussian distribution be enough for what could potentially be a high-dimensional, complicated regression problem? Let’s discuss some mathematical ideas that enable GP to be so powerful. Gaussians are essentially a black hole of distributions: once a Gaussian, always a Gaussian. For example, we know from a previous post on Gibbs sampling that the conditional of a multivariate Gaussian is also Gaussian. given the setup that and And of course, the marginal of a multivariate Gaussian also produces another Gaussian. This marginalization property can be understood both intuitively by thinking about the implications of viewing the mean and covariance as vectors and matrices, or by taking a direct integral: Lastly and most importantly, we also saw in the post on Bayesian linear regression that the product of two Gaussians is also Gaussian. Like this, a distribution that is Gaussian most likely stays Gaussian, withstanding such operations as marginalization, multiplication, or conditioning. This is a powerful property that we can use to motivate the “Gaussian-ness” behind GP. As stated earlier, GP is non-parametric.",1,0,0,0,0,1,0,0
So What are Autoencoders?,"In today’s post, we will take yet another look at an interesting application of a neural network: autoencoders. There are many types of autoencoders, but the one we will be looking at today is the simplest variant, the vanilla autoencoder. Despite its simplicity, however, there is a lot of insight to glean from this example—in fact, it is precisely the simplicity that allows us to better understand how autoencoders work, and potentially extend that understanding to to analyze other flavors of autoencoders, such as variational autoencoder networks which we might see in a future post. Without further ado, let’s get started. We begin by importing all modules and configurations necessary for this tutorial. How do autoencoders work? There are entire books dedicated to this topic, and this post in no way claims to introduce and explore all the fascinating complexities of this model. However, one intuitive way to understand autoencoders is to consider them as, lo and behold, encoders that map complex data points into vectors living in some latent dimension. For example, a 28-by-28 pixel RGB channel image might be compressed into a five-dimensional latent vector. The five numbers composing this vector somehow encodes the core information needed to then decode this vector back into the original 28-by-28 pixel RGB channel image.",0,0,1,1,0,0,0,0
Building Neural Network From Scratch,"For example, we can calculate the gradient with respect to the weights of the second affine layer as follows: We won’t get into much mathematical details here, but a useful intuition we can use to derive equation (15) is to pay close attention to the dimensionality of data. Note that the dimension of the gradient as a matrix should equal to that of the layer itself. In other words, , so on and so forth. This is because the purpose of gradient computation is to update the matrix of parameters: to perform an element-by-element update with the gradient, it must necessarily be true that the dimensionality of the gradient equals that of the original matrix. Using this observation, it is possible to navigate through the confusion of transposes and left, right matrix multiplication that one might otherwise encounter if they were to approach it without any intuition or heuristics. To expedite this post, I’ll present the result of the gradient calculations for all parameters below. Note that the indicator function, denoted as , is a simple gate function that calculates the gradient of the ReLU unit: It isn’t difficult to see that the indicator function is simply a derivative of the ReLU function as shown in equation (3). Now, it is time to translate our findings into Python. Because our neural network model is represented as a dictionary, I decided to adopt the same data structure for the gradient. Indeed, that is how we designed the  function above.",1,1,1,0,0,0,0,0
"Linear Regression, in Two Ways","This statement might sometimes be phrased differently along the lines of convexity, but this topic is better tabled for a separate future post. The key point here is that setting the gradient to zero would tell us when the error is minimized. This is equivalent to Therefore, Now we are done! Just like in the previous section,  gives us the parameters for our line of best fit, which is the solution to the linear regression problem. In fact, the keen reader might have already noted that (7) is letter-by-letter identical to formula (2) we derived in the previous section using plain old linear algebra! One the one hand, it just seems surprising and fascinating to see how we end up in the same place despite having taken two disparate approaches to the linear regression problem. But on the other hand, this is what we should have expected all along: no matter what method we use, the underlying thought process behind both modes of approach remain the same. Whether it be through projection or through derivation, we sought to find some parameters, closest to the values we are approximating as much as possible, that would turn an otherwise degenerate system into one that is solvable. Linear regression is a simple model, but I hope this post have done it justice by demonstrating the wealth of mathematical insight that can be gleaned from its derivation.",0,1,0,0,0,0,0,0
Riemann Zeta and Prime Numbers,"Based on our earlier mathematical analysis, we would expect this convergence to get even better as we expand out the  range, with an upper bound that is greater than the current 200.  While jumping around in Wikipedia, I came across the Dirichlet Eta function, which is a slight variant of the Riemann Zeta function. This function looks as follows: As you can see, this is essentially the alternating version of the Riemann Zeta function. Given this design, we can derive what may appear to be apparent to some yet nonetheless interesting relationship between the Eta and Zeta. Deriving this relationship requires a very similar operation to the sieving or factorizing we performed earlier to derive the probabilistic interpretation of the Zeta function. For a bit of intuition, observe that the Eta function can be split up into what may be referred to as even and odd terms. In other words, The idea is that the even terms are just a multiple of the Zeta function, namely Then, the odd terms can also be seen as the Zeta function minus this multiple: We now have successfully expressed both the even and odd terms of the Eta function in terms of the Zeta function. If we put the two together, we will then be able to express the entirety of the Eta function fully in terms of the Zeta function.",0,0,0,0,0,0,1,0
Logistic Regression Model from Scratch,"If the output of an algorithm given some data point is larger than 0.5, it is likely that the given input is a spam; if it is smaller than the 0.5 threshold, chances are the email is not spam. Let’s take a look at the shape of the sigmoid function, which is a special case of the logistic function that we will use throughout this post. To plot the sigmoid function, we need to import some libraries. The sigmoid function is defined as follows: We can express this as a Python function, as demonstrated in the code snippet below. Let’s quickly plot the graph to see what the sigmoid function looks like.  As we can see, the sigmoid is a smooth, differentiable function that is bounded between 0 and 1. It is also symmetrical around the point , which is why we can use 0.5 as a threshold for determining the class of a given data point. The logistic regression model uses the sigmoid function to generate predictions, but how exactly does it work? Recall that, in the case of linear regression, our goal was to determine the coefficients of some linear function, specifically Logistic regression is not so different from linear regression.",1,0,0,0,0,1,0,0
Principal Component Analysis,"If this is not the case, we can easily perform standardization by subtracting the mean from the data. With this setup in mind, let’s finally start the derivation. As said earlier, the goal of PCA is to compress data (and be able to uncompress it) with as little loss of information as possible. We don’t want to compress data in a haphazard fashion; instead, we want the compression scheme to be able to preserve the structure of the data as much as possible in its lower dimensional representation. From this, we can come up with the following equation: In other words, the goal is to find  that which minimizes the difference between the original data and the reconstructed data. Note that finding this optimal  amounts to finding  that most effectively compresses given data. Instead of the L2 norm, let’s consider the squared L2 norm for convenience purposes. Note that minimizing the L2 norm is equal to minimizing the squared L2 norm, so there is no semantic difference. By definition of vector transpose, we can now express the squared L2 norm versions of (3) as follows: where the second to last equality is due to the fact that  and  are both constants that denote the same value. Also,  the argument of the minimum is with respect to , we can omit the first term, which is purely in terms of . It’s time to take derivatives. But in order to do so, we need to unpack  , since we have no idea how to take its derivative.",0,1,0,0,1,0,0,0
Moments in Statistics,"Let’s start by simplifying the factorial in the denominator, and pulling out some expressions out of the sigma. where the third equality stands due to the variant of the Taylor series for the exponential function we looked at earlier: Therefore, we have confirmed that the mean of a Poisson distribution is equal to , which aligns with what we know about the distribution. Another way we can calculate the first moment of the Poisson is by deriving its MGF. This might sound a lot more complicated than just computing the expected value the familiar way demonstrated above, but in fact, MGFs are surprisingly easy to calculate, sometimes even easier than using the definition expectation. Let’s begin by presenting a statement of the MGF. Let’s factor out terms that contain lambda, which is not affected by the summation. Again, we refer to equation (9) to realize that the sigma expression simplifies into an exponential. In other words, From this observation, we can simplify equation (10) as follows: And there is the MGF of the Poisson distribution! All we have to do to obtain the first moment of the Poisson distribution, then, is to derive the MGF once and set  to 0. Using the chain rule, At , So we have confirmed again that the mean of a Poisson distribution is equal to . Let’s take another distribution as an example, this time the exponential distribution.",0,0,0,0,1,0,0,1
Bayesian Linear Regression,"Although it may seem as if we made zero progress by unpacking , this process is in fact necessary to complete the square of the exponent according to the Gaussian form after making the substitutions By now, you should be comfortable with this operation of backtracking a quadratic and rearranging it to complete the square, as it is a standard operation we have used in multiple parts of this process. Finally, we have derived the predictive distribution in closed form: With more simplification using the , it can be shown that And there’s the grand formula for Bayesian linear regression! This result tells us that, if we were to simply get the best point estimate of the predicted value , we would simply have to calculate , which is the tranpose product of the MAP estimate of the weights and the input vector! In other words, the answer that Bayesian linear regression gives us is not so much different from vanilla linear regression, if we were to reduce the returned predictive probability distribution into a single point. But of course, doing so would defeat the purpose of performing Bayesian inference, so consider this merely an intriguing food for thought. As promised, we will attempt to visualize Bayesian linear regression using the  library. Doing so will not only be instructive from a perspective of honing probabilistic programming skills, but also help us better understand and visualize Bayesian inference invovled in linear regression as explored in the context of this article.",0,1,0,0,0,0,0,0
Moments in Statistics,"All the magic happens when we derive this function with respect to . At , all terms in (5) except for the very first one go to zero, leaving us with In other words, deriving the MGF once and plugging in 0 to  leaves us with the first moment, as expected. If we derive the function again and do the same, And by induction, we can see how the th derivative of the MGF at  would give us the th moment of the distribution, . The easiest way to demonstrate the usefulness of MGF is with an example. For fun, let’s revisit a distribution we examined a long time ago on this blog: the Poisson distribution. To briefly recap, the Poisson distribution can be considered as an variation of the binomial distribution where the number of trials, , diverges to infinity, with rate of success defined as . This is why the Poisson distribution is frequently used to model how many random events are likely in a given time frame. Here is the probability distribution of the Poisson distribution. Note that  denotes the number of occurrences of the random event in question. The task here is to obtain the mean of the distribution, i.e. to calculate the first moment, . The traditional, no-brainer way of doing this would be to refer to the definition of expected values to compute the sum Computing this sum is not difficult, but it requires some clever manipulations and substitutions.",0,0,0,0,1,0,0,1
Word2vec from Scratch,"Now, we are finally ready to build and train our embedding network. At this point, you might be wondering how it is that training a neural network that predicts some nearby context word given an input token can be used to embed words into vectors. After all, the output of the network is going to be some probability vector that passed through a softmax layer, not an embedding vector. This is entirely correct, and this is a question that came to my mind as well. However, this is the part that gets the most interesting: the rows of the intermediate weight matrix is the embedding we are looking for! This becomes much more apparent once we consider the dimensions of the weight matrices that compose the model. For simplicity purposes, say we have a total of 5 words in the corpus, and that we want to embed these words as three-dimensional vectors. More specifically, here is the first weight layer of the model: A crucial observation to make is that, because the input is a sparse vector containing one-hot encoded vectors, the weight matrix effectively acts as a lookup table that moves one-hot encoded vectors to dense vectors in a different dimension—more precisely, the row space of the weight matrix. In this particular example, the weight matrix was a transformation of . This is exactly what we want to achieve with embedding: representing words as dense vectors, a step-up from simple one-hot encoding.",1,0,1,0,0,0,0,0
Recommendation Algorithm with SVD,"We can calculate the eigenvalues of this matrix by finding the roots of the following characteristic polynomial: Since  in SVD is the diagonal matrix that contains the square roots of the eigenvalues of , we can conclude that where  denotes the value of the th diagonal entry in . Therefore, given the dimensionality of , we can conclude that Next, we find the eigenvalues of . This process can be performed by identifying the null space of the matrix . For instance, given , Given the orientation of this matrix, we see that By doing the same for , we can construct the matrix : Repeating the procedure for  to obtain the factor , we can complete the singular value decomposition on A: The key to dimensionality reduction is that the first few columns of , its corresponding eigenvalues in , and the corresponding first few rows of  contain the most amount of information on matrix . As we  go down the diagonal entries of , we see that the eigenvalues get smaller. The rule of thumb is that the smaller the eigenvalue, the lesser contribution it has on expressing data on . In other words, we can obtain an approximation of  by extracting the first few columns and rows of each factor. For example, This may seem like a very clumsy way of approximating . However, this is because the toy matrix we dealt with was a mere two-by-three matrix with only two non-zero entries in the diagonal of .",1,1,0,0,0,0,0,0
Building Neural Network From Scratch,"ReLU is a piece-wise function, and hence introduces nonlinearity, which is one of the purposes of having an activation function in a neural network. The formula for ReLU is extremely simple. If the input value  i s greater or equal to zero, the ReLU function outputs the value without modification. However, if  is smaller than zero, the returned value is also zero. There are other ways of expressing the ReLU function. One version that is commonly used and thus deserves our attention is written below. Although this appears different from (3), both formulas express the same operation at their core. We can get a better sense of what the function with the help of Python. Assuming that the input is a  vector, we can use vectorization to change only the elements in the input vector that are negative to zero, as shown below. Let’s see what the ReLU function looks like by plotting it on the plane.  The visualization makes clear the point that ReLU is a piece-wise function that flattens out negative values while leaving positive values unchanged. Now that we have all the ingredients ready, it’s time to build the neural network. Earlier, I said that a neural network can be reduced to matrix multiplication. This is obviously an oversimplification, but there is a degree of truth to that statement. Recall that a single neuron of a neural network can be expressed as a dot product of two vectors, as shown below. Following conventional notation,  represents weights; , input data; , bias.",1,1,1,0,0,0,0,0
Gaussian Mixture Models,"We’ve discussed Gaussians a few times on this blog. In particular, recently we explored Gaussian process regression, which is personally a post I really enjoyed writing because I learned so much while studying and writing about it. Today, we will continue our exploration of the Gaussian world with yet another machine learning model that bears the name of Gauss: Gaussian mixture models. After watching yet another inspiring video by mathematicalmonk on YouTube, I meant to write about Gaussian mixture models for quite some time, and finally here it is. I would also like to thank ritvikmath for a great beginner-friendly explanation on GMMs and Expectation Maximization, as well as fiveMinuteStats for a wonderful exposition on the intuition behind the EM algorithm. Without further ado, let’s jump right into it. The motivating idea behind GMMs is that we can model seemingly complicated distributions as a convex combination of Gaussians each defined by different parameters. One visual analogy I found particularly useful is imagining Gaussians as some sort of hill or mountain on a contour map. If we have multiple hills adjacent to one another, we can essentially model the topography of the region as a combination of Gaussians. At peaks, we would see circular contour lines, but where the hills meet, we might see different patterns, most likely circular patterns overlapping with each other. The key point here is that the combination is convex; in other words, the mixing coefficient for each Gaussian should add up to one.",0,0,0,0,1,1,0,0
Gaussian Process Regression,"Then, we can now establish the following: where  denotes the observed values in the training set and the s are each components of the kernel matrix for the entire dataset, including both the training and test sets: This partition also means that  is the kernel for the training set; , the kernel for the test set. You might be wondering how the generic formula for the conditional distribution morphed into (18). While the notation might obscure their similarity, (18) immediately follows from (1). First, because we assumed zero mean, the term  simply collapses into . The same line of reasoning applies to ’ hence, the first term disappears from the mean. As for the covariance, a simple comparison is enough to show that the two equations are identical. In a nutshell, GP regression simply amounts to generating a prediction given some training data through conditioning, under the assumption that the underlying function is a infinite-dimensional vector that follows some Gaussian distribution with a kernel acting as its prior. Given this broad conceptual understanding, let’s move onto more concrete implementations. These are the setting we will be using for this post. We set a random seed for reproducibility purposes. Recall that, depsite its beautiful underlying complexity, all there is to GP regression is to identify some conditional Gaussian with a kernel as its covariance. Then, we can simply sample from this conditional distribution to obtain possible models that fit the data. As the first step, let’s implement the RBF kernel.",1,0,0,0,0,1,0,0
Wonders of Monte Carlo,"There are a plethora of mathematical techniques that build on top of crude Monte Carlo to ensure that sampling is done correctly and more efficiently, such as importance sampling, but for the purposes of this post, we will stop here and move onto the last task: simulating random walk. The last task we will deal with in this post is simulating what is known as the drunkard’s walk, a version of which is introduced here. The drunkard’s walk is a type of random walk with a specified termination condition. As the name suggests, the drunkard’s walk involves a little story of an intoxicated man trying to reach (or avoid) some destination, whether that be a cliff or, in our case, a restroom. Because he is drunk, he cannot walk to the restroom in a straight path as a normal person would do; instead, he stumbles this way and that, therefore producing a random walk. Our goal here is to simulate this motion many times to estimate the probability that the man would successfully end up in the restroom to go about his business. This example was borrowed from this post by Zacharia Miller. Before we start typing up some code, let’s first lay down the ground rules of this simulation. First, we assume that the pub is modeled as a ten-by-ten grid, the bottom-left point defined as  and the top-right . The drunkard will start his walk at his table, represented by the coordinate .",0,0,0,0,1,0,0,0
The Math Behind GANs,"Through a partial derivative of  with respect to , we see that the optimal discriminator, denoted as , occurs when Rearranging (12), we get And this is the condition for the optimal discriminator! Note that the formula makes intuitive sense: if some sample  is highly genuine, we would expect  to be close to one and  to be converge to zero, in which case the optimal discriminator would assign 1 to that sample. On the other hand, for a generated sample , we expect the optimal discriminator to assign a label of zero, since  should be close to zero. To train the generator, we assume the discriminator to be fixed and proceed with the analysis of the value function. Let’s first plug in the result we found above, namely (12), into the value function to see what turns out. To proceed from here, we need a little bit of inspiration. Little clever tricks like these are always a joy to look at. If you are confused, don’t worry, you aren’t the only one. Basically, what is happening is that we are exploiting the properties of logarithms to pull out a  that previously did not exist. In pulling out this number, we inevitably apply changes to the terms in the expectation, specifically by dividing the denominator by two. Why was this necessary? The magic here is that we can now interpret the expectations as Kullback-Leibler divergence: And it is here that we reencounter the Jensen-Shannon divergence, which is defined as where .",0,0,1,0,1,0,0,0
Bayesian Linear Regression,"Whereas vanilla linear regression only gives us a single point estimate given an input vector, Bayesian linear regression gives an entire distribution. For the purposes of our demonstration, we will define the predictive posterior to take the following form as shown below, with precision  pre-given. Precision is simply the reciprocal of variance and is commonly used as an alternative way of parametrizing Gaussian distributions. In other words, we assume the model Our goal will be to derive a posterior for this distribution by performing Bayesian inference on , which corresponds to the slope of the linear regression equation, where  denotes noise and randomness in the data, thus affecting our final prediction. To begin Bayesian inference on parameter , we need to specify a prior. Our uninformed prior will look as follows. where  denotes precision, the inverse of variance. Note that we have a diagonal covariance matrix in place of variance, the distribution for  will be a multivariate Gaussian. The next ingredient we need for our recipe is the likelihood function. Recall that likelihood can intuitively be understood as an estimation of how likely it is to observe the given data points provided some parameter for the true distribution of these samples. The likelihood can easily be computed by referencing back to equation (1) above. Note that the dot product of  with itself yields the sum of the exponents, which is precisely the quantity we need when computing the likelihood.",0,1,0,0,0,0,0,0
Introduction to tf-idf,"This is all there is to it—in fact, the formula for tf-idf can simply be expressed as where  denotes a single term; , a singe document, and , a collection of documents. So simply put, tf-idf is simply a product of the term frequency, denoted above as , and inverse document frequency, . All there is left, then, is to figure out what term frequency and inverse document frequency are. Without much explanation, you can probably guess what term frequency is: it simply indicates how frequently a word appeared in a given document. For example, if there were a total of 3 distinct words in a document (very short, I know), then each of the three words would have a tf score of . Put differently, the sum of the tf vector for each document should sum to one. The definition of a tf score might be thus expressed as where the denominator denotes the count of all occurrences of the term  in document , and the numerator represents the total number of terms in the document. Roughly speaking, inverse document frequency is simply the reciprocal of document frequency. Therefore, it suffices to show what document frequency is, since idf would immediately follow from df. Before getting into the formula, I think it’s instructive to consider the motivation behind tf-idf, and in particular what role idf plays in the final score.",1,0,0,0,0,0,0,0
Natural Gradient and Fisher,"In the classic context of ML, we want to minimize the KL divergence. In this case, however, we’re simply using KL divergence as a means of measuring distance between two parameters in defined within a distribution space. As nicely stated in layman’s term in this Medium article, … instead of “I’ll follow my current gradient, subject to keeping the parameter vector within epsilon distance of the current vector,” you’d instead say “I’ll follow my current gradient, subject to keeping the distribution my model is predicting within epsilon distance of the distribution it was previously predicting” I see this as an intuitive way of nicely summarizing why we’re using KL divergence in searching the distribution space, as opposed to using Euclidean distance in searching the parameter space. Now it’s time for us to connect the dots between KL divergence and Fisher’s matrix. Before we diving right into computations, let’s think about how or why these two concepts might be related at all. One somewhat obvious link is that both quantities deal with likelihood, or to be more precise, log likelihood. Due to the definition of entropy, KL divergence ends up having a log likelihood term, while Fisher’s matrix is the negative expected Hessian of the log likelihood function, or the covariance matrix of Fisher’s score, which is the gradient of the log likelihood. Either way, we know that likelihood is the fundamental bridge connecting the two. Let’s try to compute the KL divergence between  and .",0,0,0,0,1,1,0,0
"Beta, Bayes, and Multi-armed Bandits","Note that we can always generalize such quantities into moments. Given , the expected value of the Beta random variable can be expressed as Proving this is pretty straightforward if we simply use the law of the unconscious statistician. Using the definition of expectation, we can derive the following: Here, we use the Gamma representation of the Beta function. This conclusion gives an even nicer, more intuitive interpretation of the Bayesian update we saw earlier with the Beta prior and binomial likelihood. Namely, given the new posterior we know that sampling from that new posterior will give us a mean value that somewhat resembles the crude approach we would have taken without the prior expectation. Here, the crude approach is referring to the raw frequentist estimate we would have made had we not taken the Bayesian approach to the problem. It is obvious that the two hyperparameters of the prior are acting as an initial weight of sorts, making sure that when little data is available, the prior overshadows observations, but when ample amount of data is collected and available, eventually yields to those observations to estimate the parameter. Now we can turn our attention back to the multi-armed bandit problem. Now we can build on top of our knowledge of the Beta-Binomial update and refine what the frequentist greedy approach. We will also write out some simple functions to simulate the bandit problem and thus demonstrate the effectiveness of the Bayesian approach.",0,0,0,0,1,0,0,1
Natural Gradient and Fisher,"Now, the update rule would be To solve for the argument minima operation, we will resort to the classic method for optimization: Lagrangians. In this case, the Lagrangian would be This immediately follows from using the constraint condition. To make progress, let’s use Taylor approximation again, both on the term for the loss function and the KL divergence. The good news is that we have already derived the expression for the latter. Noting the fact that there are several constants in this expression, we can simplify this into To minimize this expression, we set its gradient equal to zero. Note that we are deriving with respect to . Therefore, We are finally done with our derivation. This equation tells us that the direction of steepest descent is defined by the inverse of the Fisher matrix multiplied by the gradient of the loss function, up to some constant scaling factor. This is different from the vanilla batch gradient descent we are familiar with, which was simply defined as Although the difference seems very minor—after all, all that was changed was the addition of Fisher’s matrix—yet the underlying concept, as we have seen in the derivation, is entirely different. This was definitely a math-heavy post. Even after having written this entire post, I’m still not certain if I have understood the details and subtleties involved in the derivation. And even the details that I understand now will become confusing and ambiguous later when I return back to it.",0,0,0,0,1,1,0,0
Dissecting LSTMs,"Given an intermediate variable we can express the gradient in the following fashion: Then, we can obtain  by un-concatenation: where  denotes the number of neurons in the LSTM layer. We can do the same for . This is a lot simpler: These gradients, of course, will be passed onto the next iteration of backpropagation, just like we had assumed that the values of  and  were given from the previous sequence of backpropagation. Because DL libraries make it extremely easy to declare and train LSTM networks, it’s often easy to gloss over what actually happens under the hood. However, there is certainly merit to dissecting and trying to understand the inner-working of DL models like LSTM cells, which offer a fascinating way of understanding the notion of memory. This is also important since RNNs are the basis of other more complicated models such as attention-based models or transformers, which is arguably the hottest topic these days in the field of NLP with the introduction of GPT-3 by OpenAI. I hope you have enjoyed reading this post. Catch you up in the next one!.",0,0,1,0,0,0,0,0
Recommendation Algorithm with SVD,"In eigendecomposition, the factors were all square matrices whose dimension was identical to that of the matrix that we sought to decompose. In SVD, however, since the target matrix can be rectangular, the factors are always of the same shape. The second point to note is that  and  are orthogonal matrices; , a diagonal matrix. This decomposition structure is similar to that of eigendecomposition, and this is no coincidence: in fact, formula (1) can simply be shown by performing an eigendecomposition on  and . Let’s begin by calculating the first case, , assuming formiula (1). This process looks as follows: The last equality stands since the inverse of an orthogonal matrix is equal to its transpose. Substituting  for , equation (2) simplifies to And we finally have what we have seen with eigendecomposition: a matrix of independent vectors equal to the rank of the original matrix, a diagonal matrix, and an inverse. Indeed, what we have in (3) is an eigendecomposition of the matrix . Intuitively speaking, because matrix  is not necessarily square, we calculate  to make it square, then perform the familiar eigendecomposition. Note that we have orthogonal eigenvectors in this case because  is a symmetric matrix—more specifically, positive semi-definite. We won’t get into this subtopic too much, but we will explore a very simple proof for this property, so don’t worry. For now, let’s continue with our exploration of the SVD formula by turning our attention from matrix —a factor of eigendecomposition on —to the matrix .",1,1,0,0,0,0,0,0
Word2vec from Scratch,"What is the value that we are trying to approximate, and what sort of input will we be feeding into the model to generate predictions? The answer to these questions and how they tie into word2vec is at the heart of understanding word embeddings—as you may be able to tell, word2vec is not some sort of blackbox magic, but a result of careful training with input and output values, just like any other machine learning task. So here comes the crux of word2vec: we loop through each word (or token) in the sentence. In each loop, we look at words to the left and right of the input word, as shown below. This illustration was taken from this article by Ramzi Karam.  In the particular example as shown above, we would generate the following input and prediction pairs part of the training data. Note that the window size is two, which is why we look up to two words to the left and right of the input word. So in a way, we can understand this as forcing the model to understand a rough sense of context—the ability to see which words tend to stick together. In our own example, for instance, we would see a lot of , meaning that the model should be able to capture the close contextual affinity between these two words. Below is the code that generates training data using the algorithm described above. We basically iterate over the tokenized data and generate pairs.",1,0,1,0,0,0,0,0
First Neural Network with Keras,"Note that the hidden layer uses the  function as its activation function. The dropout layers ensure that our model does not overfit to the data. The last output layer has 10 neurons, each corresponding to digits from 0 to 9. The activation fuction of this last layer is the softmax function, which allows us to interpret the final results as a categorical distribution. Let’s double check that the layers have been formed correctly as per our intended design. Everything looks good, which means we are now ready to compile and train our model. Before we do that, however, it is always a good idea to use the  module to ensure that gradient descent stops when no substantial weight adjustments are being made to our model. In other words, when the model successfully finds the local minimum (or preferably the global minimum), the  will kick in and stop gradient descent from proceeding with further epochs. We are now ready to go! Let’s compile the model by making some configurations, namely the , , and . Simply put, an  specifies which flavor of the gradient descent algorithm we want to choose. The simplest version is known as , or the stochastic gradient descent.  can be considered an improved version of the stochastic gradient descent in that its learning rate changes depending on the slope of the loss function, defined here as cross entropy. If you recall, cross entropy is basically a measurement of the pseudo-distance between two distributions, i.e. how different two distributions are.",0,0,1,1,0,1,0,0
Naive Bayes Model From Scratch,"A good way to understand this data is through visualization. Let’s try to visualize what the distribution of  and  looks like for data labeled class . We can use the  library to create a joint plot of the two random variables.  We see that both variables are normally distributed. Therefore, we can imagine data points for class  to be distributed across a three-dimensional Gaussian distribution whose center lies at the point where the the plot has the darkest color, i.e. . I find this way of understanding data to be highly intuitive in this context. Now, it’s time to bake Bayesian philosophy into code. Recall that to perform Bayesian analysis, we first need to specify a prior. Although we could use an uninformed prior, in this case, we have data to work with. The way that makes the most sense would be to count the number of data points corresponding to each class to create a categorical distribution and use that as our prior, as shown below. If we use the  created from , we should get a very simple prior whereby  since there is an equal number of data points belonging to the two classes in the toy data set. Indeed, this seems to be true. Next, it’s time to model the likelihood function. I won’t get into the specifics of this function, but all it does is that it calculates the likelihood by using the parameters returned by the  function to indicate the likelihood that a particular  belongs to a certain class.",1,0,0,0,0,1,0,0
A Brief Introduction to Recurrent Neural Networks,"For control our experiment, we will train all four models over the same , , and . There isn’t much exciting here to look at it terms of code; it’s just a matter of patience, waiting for the models to hopefully converge to a global minimum. For future reference, all training history is dumped in the  object where  corresponds to the model number. After a long time of waiting, the training is finally complete! If you are following this tutorial on your local workstation, please note that the time required for training may vary depending on your hardware configurations or the specification of our instance if you are using a cloud-based platform like AWS. None of our models reached the threshold of ninety percent accuracy, but they all managed to converge to some reasonable number, hovering around the high seventies to low eighties. Let’s test the performance of our models by using the  and  data, both of which none of our models have seen before. Based on the results, it looks like the LSTM model performed best, beating other models by a small margin. At this point, we cannot conclude as to whether or not this marginal boost in performance is significant. Judging this would not only depend on the context, but also most likely require us to have a larger test dataset that captures the statistics of the population data. This point notwithstanding, it is certainly beneficial to know that LSTM networks are good at detecting sequential patterns in data.",0,0,1,1,0,0,0,0
Bayesian Linear Regression,"where  is a design matrix given by and  is a column vector given by Before calculating the posterior, let’s recall what the big picture of Bayesian inference looks like. where  denotes the parameter of interest for inference. In plain terms, the proposition above can be written as In other words, the posterior distribution can be obtained by calculating the product of the prior distribution and the likelihood function. In many real-world cases, this process can be intractable, but because we are dealing with two Gaussian distributions, the property of conjugacy ensures that this problem is not only tractable, but also that the resulting posterior would also be Gaussian. Although this may not be immediately apparent, observe that the exponent is a quadratic that follows the form after making appropriate substitutions Therefore, we know that the posterior for  is indeed Gaussian, parameterized as follows: Let’s try to obtain the MAP estimate of of , i.e. simplify  Notice the similarity with the MLE estimate, which is the solution to normal equation, which I otherwise referred to as vanilla linear regression: This is no coincidence: in a previous post on MAP and MLE, we observed that the MAP and MLE become identical when we have a uniform prior. In other words, the only cause behind the divergence between MAP and MLE is the existence of a prior distribution. We can thus consider the additional term in (10) absent in (11) as a vestige of the prior we defined for .",0,1,0,0,0,0,0,0
Likelihood and Probability,"For the purposes of this post, we look at the simplest way that involves just a bit of calculus. The best way to demonstrate how MLE works is through examples. In this post, we look at simple examples of maximum likelihood estimation in the context of normal distributions. We have never formally discussed normal distributions on this blog yet, but it is such a widely used, commonly referenced distribution that I decided to jump into MLE with this example. But don’t worry—we will derive the normal distribution in a future post, so if any of this seems overwhelming, you can always come back to this post for reference. The probability density function for the normal distribution, with parameters  and , can be written as follows: Assume we have a list of observations that correspond to the random variable of interest, . For each  in the sample data, we can calculate the likelihood of a distribution with parameters  by calculating the probability densities at each point of the PDF where . We can then make the following statement about these probabilities: In other words, to maximize the likelihood simply means to find the value of a parameter that which maximizes the product of probabilities of observing each data point. The assumption of independence allows us to use multiplication to calculate the likelihood in this manner. Applied in the context of normal distributions with  observations, the likelihood function can therefore be calculated as follows: But finding the maximum of this function can quickly turn into a nightmare.",0,0,0,0,1,0,0,0
Revisiting Basel with Fourier,"To recap, from a very high level, Fourier expansion is a way of expressing some function in terms of trigonometric functions. If Taylor expansion used polynomials as the building block, Fourier expansion uses sines and cosines. A generic formula for the Fourier transform can be expressed as follows: With some integration, it can be shown that where  refers to the domain of integration. For instance, if we are integrating from  to , . A classic interval that is most commonly used is , and this is no coincidence: notice that, when , the Taylor series shown in (2) simplifies into the following: And indeed this is the format and the interval we will be using when constructing a Fourier series to tackle the Basel problem. To continue, we can derive a very similar expression for , given the specified interval from . Now that we have reviewed what Fourier series is and how we can construct it, let’s jump into the Basel problem. Just like the Taylor series, we can use Fourier expansion to represent any function continuous function. For our purposes, let’s try to expand a simple polynomial function, , using Fourier. We can begin with . Let’s continue with finding the even coefficients corresponding to the cosines. With some integration by parts, we can all agree that where the  terms appear because we end up plugging  into , a periodic function. And we can do the same for sine.",0,0,0,0,0,0,1,0
Scikit-learn Pipelines with Titanic,"Let’s top this discussion off with a look at the confusion matrix, which is another way of compactly encoding various pieces of information for model evaluation, namely true positives, true negatives, false positives, and false negatives. Note that precision and recall are all metrics that are computed using TP, TN, FP and FN as parameters. The confusion matrix shows that our model performs well at determining the death and survival of those passengers who actually died, but performs rather poorly on those who lived. Analyses like these cannot be obtained simply by looking at accuracy, which is why plotting the confusion matrix is always a good idea to get a sense of the model’s performance.  Although the titanic dataset is considered trite, much like MNIST is in the context of DL, I still think there is a lot to be learned. Even simple ML projects like these have infinite spaces and options for exploration and experimentation. I hope to go through these classic datasets and competitions to glean insight from excellent public kernels, just like this Kaggle kernel which I referenced extensively to write this tutorial. In its inception, this post was conceived of as a simple introduction to ’s pipelines, but it eventually ballooned up into a somewhat comprehensive rundown of a little Kaggle project. I hope to do a lot more of these in the coming days, just because I think there is immense value in mastering ML, although DL sounds a lot cooler. I hope you enjoyed reading this post.",0,0,0,0,0,1,0,0
PyTorch RNN from Scratch,"It’s also not entirely fair game for the model since there are many names that might be described as multi-national: perhaps there is a Russian person with the name of Demirkan. I learned quite a bit about RNNs by implementing this RNN. It is admittedly simple, and it is somewhat different from the PyTorch layer-based approach in that it requires us to loop through each character manually, but the low-level nature of it forced me to think more about tensor dimensions and the purpose of having a division between the hidden state and output. It was also a healthy reminder of how RNNs can be difficult to train. In the coming posts, we will be looking at sequence-to-sequence models, or seq2seq for short. Ever since I heard about seq2seq, I was fascinated by tthe power of transforming one form of data to another. Although these models cannot be realistically trained on a CPU given the constraints of my local machine, I think implementing them themselves will be an exciting challenge. Catch you up in the next one!.",1,0,1,0,0,0,0,0
A Step Up with  Variational Autoencoders,"How do we find this distribution? Well, we know one handy concept that measures the difference or the pseudo-distance between two distributions, and that is Kullback-Leibler divergence. As we discussed in this post on entropy, KL divergence tells us how different two distributions are. So the goal here would be find a distribution that minimizes the following expression: Using the definition of conditional probability, we can simplify (4) as follows: The trick is to notice that  is a constant that can break out of the expectation calculation. Let’s continue by deriving an expression for the evidence term. A useful property to know about KL divergence is the fact that it is always non-negative. We will get into why this is the case in a moment. For now, let’s assume non-negativity to be true and transform (6) into an inequality: The term on the right of the inequality is known as the Evidence Lower Bound, or ELBO for short. Why are we interested in ELBO? First, note that , the evidence, is a constant. Therefore, minimizing KL divergence amounts to maximizing ELBO. This is the key to variational inference: instead of calculating the intractable integral in (3), we can find a distribution  that which minimizes KL divergence by maximizing ELBO, which is a tractable operation. Let’s prove why KL divergence is always greater or equal to zero, which is a condition we assumed to be true in the derivation of ELBO above. For the sake of completeness, I present two ways of proving the same property.",0,0,1,1,0,0,0,0
Word2vec from Scratch,"One technicality here is that, for the first and last few tokens, it may not be possible to obtain words to the left or right of that input token. In those cases, we simply don’t consider these word pairs and look at only what is feasible without causing s. Also note that we create  and  separately instead of putting them in tuple form as demonstrated above. This is just for convenience with other matrix operations later on in the post. Below is the definition for , an auxiliary function we used above to combine two  objects. Also, here is the code we use to one-hot vectorize tokens. This process is necessary in order to represent each token as a vector, which can then be stacked to create the matrices  and . Finally, let’s generate some training data with a window size of two. Let’s quickly check the dimensionality of the data to get a sense of what matrices we are working with. This intuition will become important in particular when training and writing equations for backpropagation in the next section. Both  and  are matrices with 330 rows and 60 columns. Here, 330 is the number of training examples we have. We would expect this number to have been larger had we used a larger window. 60 is the size of our corpus, or the number of unique tokens we have in the original text. Since we have one-hot encoded both the input and output as 60-dimensional sparse vectors, this is expected.",1,0,1,0,0,0,0,0
Riemann Zeta and Prime Numbers,"A corollary of this simple analysis is that we can now express the probability that a given random number will be a prime number as follows, using (6): In other words, the reciprocal of the Zeta function tells us the probability that a randomly chosen number will be a prime! The more interesting part of the story is that, we can now extend this single-number example to the case of multiple numbers. The only difference is that, instead of considering whether a single number is prime or not, we will consider the notion of coprimeness, or relative primeness. Imagine we randomly sample  numbers, ranging from  all the way up to . What is the probability that these  numbers are all coprime to each other, i.e. the greatest common divisor for these numbers is 1? With some rumination, it isn’t difficult to convince ourselves that this probability can be expressed as Let’s think for a second why this is the case. The probability that some prime number  divides all  through  is going to be , as dividing each number can be considered an independent event. Therefore, the probability that some prime number  does not divide all numbers—i.e. it may divide none or some, but definitely not all—can be expressed as the complement of , or equivalently, . If we apply this analysis to all prime numbers, we end up with (6). Now, let’s simulate the process of random sampling to empirically verify the probabilistic interpretation of the Riemann Zeta function.",0,0,0,0,0,0,1,0
Dissecting the Gaussian Distribution,"Continuing, the next subject of our interest would be , as the variance is only strictly defined for one variable, as expressed by its definition below: where  is a random variable, which takes a scalar value. This necessarily begs the question: what is the multivariable equivalent of variance? To answer this question, we need to understand covariance and the covariance matrix. To jump right into the answer, the multivariable analogue of variance is covariance, which is defined as Notice that  equals variance, which is why we stated earlier that covariance is the multivariate equivalent of variance for univariate quantities. The intuition we can develop from looking at the equation is that covariance measures how far our random variables are from the mean in the  and  directions. More concretely, covariance is expresses the degree of association between two variables. Simply put, if there is a positive relationship between two variables, i.e. an increase in one variable results in a corresponding increase in the other, the variance will be positive; conversely, if an increase in one variable results in a decrease in the other, covariance will be negative. A covariance of zero signifies that there is no linear relationship between the two variables. At a glance, the concept of covariance bears strong resemblance to the notion of correlation, which also explains the relationship between two variables. Indeed, covariance and correlation are related: in fact, correlation is a function of covariance.",0,0,0,0,1,0,0,1
Convolutional Neural Network with Keras,"Recently, a friend recommended me a book, Deep Learning with Python by Francois Chollet. As an eager learner just starting to fiddle with the Keras API, I decided it was a good starting point. I have just finished the first section of Part 2 on Convolutional Neural Networks and image processing. My impression so far is that the book is more focused on code than math. The apparent advantage of this approach is that it shows readers how to build neural networks very transparently. It’s also a good introduction to many neural network models, such as CNNs or LSTMs. On the flip side, it might leave some readers wondering why these models work, concretely and mathematically. This point notwithstanding, I’ve been enjoying the book very much so far, and this post is a reflection of just that. Today, we will use TensorFlow’s  module to build a convolutional neural network for image detection. This code is based on what I have learned from the book, so much credit goes to Deep Learning with Python. I have also looked at Machine Learning Mastery blog for additional reference. Let’s begin! Below are the modules that we will need to import for this demonstration. Note that this Jupyter Notebook was written on Google Colaboratory. The default version of TensorFlow in Colab will soon switch to TensorFlow 2.x. We recommend you upgrade now or ensure your notebook will continue to use TensorFlow 1.x via the  magic: more info.",0,0,1,1,0,0,0,0
Gaussian Mixture Models,"In other words, given some data, what is the probability that it will belong to a certain class? Using the definition of conditional probability, we can arrive at the following conclusion: This represents the probability that, given some point , the point belongs in the th cluster. With this result, we can now rewrite the MLE calculation that we were performing earlier. Using the new  notation, we can thus simplify the result down to We can then simplify this expression to derive an expression for . An important trick is here to use the fact that the covariance matrix is positive semi-definite. Therefore, the covariance matrix plays no role in driving the value down to zero. With some algebraic manipulations, we arrive at Let’s introduce another notational device to simplify the expresison even further. Let Recall that  was defined to be the posterior probability that a given point  belongs to the th cluster. Then, since we are essentially summing up this quantity across the entire  data points in the dataset , we can interpret  to effectively be the number of points in the dataset that are assinged to the th cluster. Then, we can now simplify the MLE estimate of the mean as But we can now observe something interesting. Notice that a depend on . In turn,  is defined in terms of . This is the very circular dependency that we discussed earlier as we were introducing the EM algorithm and comparing it with the Gibbs sampler.",0,0,0,0,1,1,0,0
Naive Bayes Model From Scratch,"The data set contains three target classes, labeled as integers from 0 to 2, and thirteen feature columns, listed below: As I am not a wine afficionado, I have no idea what some of these columns represent, but that is irrelevant to the purpose of this tutorial. Let’s jump right in by loading the data. It always a good idea to get a sense of what the data looks like by verifying its dimension. Note that we used the  function we wrote in previous posts to shuffle and slice the data into training and validation sets. For convenience, the code for this function is presented below. Now it’s finally time to check our model by making predictions. This can simply be done by passing the training and testing data set into the  function that represented our Gaussian naive Bayes model. Let’s check if the predicted class labels match the answer key, i.e. the  array. Eyeballing the results, it seems like we did reasonably well! In fact, the line below tells us that our model mislabeled only one test instance! We can quantify the performance our model through the metric of accuracy. The  function does this for us. Note that instead of using the for-loop approach used in previous posts, this function is more vectorized, making computation less expensive. The shorter code is also an added benefit. The accuracy of our from-scratch model is 97 percent, which is not bad for a start. Let’s see if the  model in  outperforms our hand-coded model.",1,0,0,0,0,1,0,0
The Gibbs Sampler,"The goal is to derive is the conditional distribution, . This derivation was heavily adapted from this source and this thread on Stack Exchange. It is certainly a somewhat lengthy derivation, but there is nothing too conceptually difficult involved—it’s just a lot of algebra and simplifications. We begin from the formula for the multivariate Gaussian: For convenience purposes, let Then, Let Note that this is not a one-to-one correspondence, i.e. . The blocks are only one-to-one insofar as being dimensionally equivalent. Then, using block matrix multiplication, Notice that the final result should be a single scalar given the dimensions of each matrix. Therefore, we can further simply the expression above using the fact that . Specifically, the second and third terms are transposes of each other. Although we simply resorted a convenient substitution in (6), we still need to derive an expression for the inverse of the covariance matrix. Note that the inverse of the covariance matrix can intuitively be understood as the precision matrix. We won’t derive the block matrix inversion formula here. The derivation is just a matter of simply plugging in and substituting one expression for another. For a detailed full derivation, checkout this link or this journal article. To cut to the chase, we end up with Plugging these results back into (8), and with some elided simplification steps, we end up with Note that we can more conveniently express the result in the following fashion: We’re now almost done.",0,1,0,0,1,0,0,0
How lucky was I on my shift?,"At a glance, this distribution resembles the binomial distribution we looked at earlier, and indeed that is no coincidence: the Poisson distribution is essentially a special case of binomial distributions whereby the number of trials is literally pushed to the limit. As stated earlier, the binomial distribution can be considered as a very rough approximation of the Poisson distribution, and the accuracy of approximation would be expected to increase as  increases. So let me ask the question again: how lucky was I yesterday? The probability distribution function of the Poisson distribution tells us that  can be calculated through the following equation: The result given by the Poisson distribution is somewhat larger than that derived from the binomial distribution, which was . This discrepancy notwithstanding, the fact that I had a very lucky day yesterday does not change: I would have days like these once every 100 days, and those days surely don’t come often. But to really calculate how lucky I get for the next 18 months of my life in the military, we need to do a bit more: we need to also take into account the fact that receiving lesser than 5 calls on a shift also constitutes a lucky day. In other words, we need to calculate , as shown below: This calculation can be done rather straightforwardly by plugging in numbers into the Poisson distribution function as demonstrated above. Of course, this is not the most elegant way to solve the problem.",0,0,0,0,1,0,0,1
An Introduction to Markov Chain Monte Carlo,"The benefit of working with this dumb example is that we can analytically derive a closed-form exprerssion for the posterior distribution. This is because a normal prior is conjugate with a normal likelihood of known variance, meaning that the posterior distribution for the mean will also turn out to be normal. If you are wondering if this property of conjugacy is relevant to the notion of conjugacy discussed above with Bayesian inference, you are exactly correct: statisticians have a laundry list of distributions with conjugate relationships, accessible on this Wikipedia article. The bottom line is that we can calculate the posterior analytically, which essentially gives us an answer with which we can evaluate our implementation of the Metropolis-Hastings algorithm. The equation for the posterior is presented below. This assumes that the data is normally distributed with known variance and that the prior is normal, representable as For a complete mathematical derivation of (8), refer to this document. As we will see later on, we use (9) to calculate the likelihood and (10) to calculate the prior. For now, however, let’s focus on the analyticial derivation of the posterior. This can be achieved by translating the equation in (8) into code as shown below. Let’s see what the posterior looks like given the prior . For sample observations, we use the toy data set  we generated earlier.  There we have it, the posterior distribution given sample observations and a normal prior.",1,0,0,0,0,0,0,0
Recommendation Algorithm with SVD,"We would expect singular value decomposition to capture these observations in some way, albeit approximately. Now, let’s actually perform singular value decomposition on the ratings matrix. We could try to do this manually by hand, but let’s utilize the power of modern computing to save ourselves of the time and mental effort involved in calculating the eigenvalues and eigenvectors of a ten-by-ten matrix. Luckily for us, the  module contains some excellent functionality to help us with singular value decomposition. Using this library, singular value decomposition can very simply be achieved with just a few lines of code. The parameters of the  function are , the ratings matrix, and , the number of non-trivial entries of  to select for dimensionality reduction, as we have seen earlier. More technically speaking,  corresponds to the number of “concepts” or dimensions that we will extract from the matrix. Let’s see what this means by actually running this function. Great! This is what dimensionality reduction means in the loosest sense. Instead of having 5 entries each row, as we had with the original ratings matrix , we now have 3 entries per row. In other words, the information on users has been compressed into three dimensions. Unlike in , where each column corresponded to some movie, we don’t really know what the columns of  stand for. It might be some genre, actress, or any hidden patterns in the data set that we are not aware of. Regardless, what’s important here is that we can now understand data more easily in smaller dimensions.",1,1,0,0,0,0,0,0
My First GAN,"Generative models are fascinating. It is no wonder that GANs, or General Adversarial Networks, are considered by many to be where future lies for deep learning and neural networks. In this post, we will attempt to create a very simple vanilla GAN using TensorFlow. Specifically, our goal will be to train a neural network that is capable of generating compelling images of ships. Although this is a pretty mundane task, it nonetheless sheds lights on the potential that GAN models hold. Let’s jump right into it. Below are the dependencies and settings we will be using throughout this tutorial. Before we start building the GAN model, it is probably a good idea to define some variables that we will be using to configure the parameters of convolutional layers, namely the dimensionality of the images we will be dealing with, as well as the number of color channels and the size of the latent dimension. Similar to variational autoencoders, GANs are composed of two parts: the generator and the discriminator. As Ian Goodfellow described in the paper where he first put out the notion of a GAN, generators are best understood as counterfeiters of currency, whereas the discriminator is the police trying to distinguish the fake from the true. In other words, a GAN is a two-component model that involves an internal tug-of-war between two adversarial parties, each trying their best to accomplish their mission.",0,0,1,1,0,0,0,0
"Beta, Bayes, and Multi-armed Bandits","In the simple, greedy frequentist approach, we would determine which bandit to pull on given our historical rate of success. If the first slot machine approximately yielded success 60 percent of the time, whereas the second one gave us 40, we would choose the first. Of course, this approach is limited by the fact that, perhaps we only pulled on the second machine 5 times and got only 2 success out of them, whereas we pulled on the first bandit a hundred times and got 60 successes. Maybe it turns out that the second bandit actually has a higher success rate, and that we were simply unlucky those five turns. Thompson sampling remedies this problem by suggesting a different approach: now that we have Bayesian posteriors, we can now directly sample from those posteriors to get an approximation of the parameter values. Since we are sampling from a distribution instead of relying on a point estimate as we do for the greedy approach, this allows for both exploration and exploitation to happen at reasonable frequencies. If a posterior distribution has large variance, this means that we will explore that particular bandit slightly more than others. If a posterior has a large mean—a high success parameter—then we will exploit that machine a bit more to earn more profit, or, in this context, to minimize regret. Before we move on any farther, perhaps’ it’s worth discussing what the term “regret” means in this context.",0,0,0,0,1,0,0,1
Demystifying Entropy (And More),"The other day, my friend and I were talking about our mutual friend Jeremy. “He’s an oddball,” my friend Sean remarked, to which I agreed. Out of nowhere, Jeremy had just told us that he would not be coming back to Korea for the next three years. “He is just about the most random person I know.” And both of us, being aspiring statistics majors, began wondering: is there a systematic way of measuring randomness? It is from here that we went down the rabbit hole of Google and Wikipedia search. I ended up landing on entropy land, which is going to be the topic for today’s post. It’s a random post on the topic of randomness. To begin our discussion of randomness, let’s take a look at how scientists measure the randomness involved in natural phenomena, such as particle movement. If you are a chemist or physicist, you might be familiar with the concept of entropy, one of the core elements of thermodynamics and a topic that recurs throughout many subfields of natural sciences.",0,0,0,0,1,0,0,0
Naive Bayes Model From Scratch,"The accuray score yielded by  is exactly identical to that achieved by our model! Looks like the  model in scikit-learn does exactly what our model does, at least juding from the metric of accuracy. This is surprising, but since we basically followed the Bayesian line of reasoning to buid our model, which is what naive Bayes really is all about, perhaps this is not as astonishing as it seems. In this post, we built the Gaussian naive Bayes model from scratch. In the process, we reviewed key concepts such as Bayesian inference and maximum a posteriori estimation, both of which are key statistical concepts used in many subdomains of machine learning. Hopefully through this tutorial, you gained a better understanding of how Gaussian mathematics and Bayesian thinking can be used in the context of classification. The true power of naive Bayes is not limited to the task of classificaiton, however. In fact, it is used in many fields, most notably natural language processing. Perhaps we might look into the possible applications of naive Bayes in the context of NLP in a future post. But for now, this level of modeling will do. Thanks for reading. See you in the next post!.",1,0,0,0,0,1,0,0
First Neural Network with Keras,"Lately, I have been on a DataCamp spree after unlocking a two-month free unlimited trial through Microsoft’s Visual Studio Dev Essentials program. If you haven’t already, make sure to check it out, as it offers a plethora of tools, journal subscriptions, and software packages for developers. Anyhow, one of the courses I decided to check out on DataCamp was titled “Introduction to Deep Learning with Python,” which covered basic concepts in deep learning such as forward and backward propagation. The latter half of the tutorial was devoted to the introduction of the Keras API and the implementation of neural networks. I created this notebook immediately after finishing the tutorial for memory retention and self-review purposes. First, we begin by importing the  library as well as other affiliated functions in the module. Note that Keras uses TensorFlow as backend by default. The warning in the code block below appears because this notebook was written on Google Colab, which informs users that the platform will be switching over to TensorFlow 2 in the future. As you might be able to guess from one of the imported modules, the objective of the neural network will be to classify hand-written digits. In doing so, we will be dealing with a classic in machine learning literature known as the the MNIST data set, which contains images of hand-written digits from 0 to 9, each hand-labeled by researchers. The  variable denotes the total number of class labels available in the classification task, which is 10.",0,0,1,1,0,1,0,0
The Math Behind GANs,"This is because the gradient of the function  is steeper near  than that of the function , meaning that trying to maximize , or equivalently, minimizing  is going to lead to quicker, more substantial improvements to the performance of the generator than trying to minimize . Now that we have defined the loss functions for the generator and the discriminator, it’s time to leverage some math to solve the optimization problem, i.e. finding the parameters for the generator and the discriminator such that the loss functions are optimized. This corresponds to training the model in practical terms. When training a GAN, we typically train one model at a time. In other words, when training the discriminator, the generator is assumed as fixed. We saw this in action in the previous post on how to build a basic GAN. Let’s return back to the min-max game. The quantity of interest can be defined as a function of  and . Let’s call this the value function: In reality, we are more interested in the distribution modeled by the generator than . Therefore, let’s create a new variable, , and use this substitution to rewrite the value function: The goal of the discriminator is to maximize this value function.",0,0,1,0,1,0,0,0
Gaussian Process Regression,"Then, This means that we can calculate the mean  as Similarly, for the covariance , we can introduce an intermediate variable  from which we obtain Notice that the final expressions for mean and covariance do not require any form of inversion, which was our end goal for efficient and accurate computation. Let’s transcribe everything back to code. Let  refer to  (and by the same token  refers to ). Then, Just to be safe, let’s check that  is of the desired shape, namely a vector with 50 entries. Continuing with our computation of the posterior covariance, As expected,  is a 50-by-50 matrix. We are now almost done. Since we have computed the mean  and covariance , all there is left is to generate samples from this distribution. For that, we resort to Cholesky decomposition again, recalling the idea discussed earlier in (19). Let’s sample a total of 50 samples. now contains 50 samples generated from the posterior. It’s important to keep in mind that these samples are each 50-dimensional vectors—in a sense, they can be considered as “functions”, which is why the Gaussian process is often referred to as sampling functions from a multivariate Gaussian. Let’s plot the final result, alongside the actual function . In red, I’ve also plotted the average of all the 50 samples to see how accurate the result holds up.  The model behaves exactly as we would expect: where there is data, we are confident; where there is no data, we are uncertain.",1,0,0,0,0,1,0,0
Scikit-learn Pipelines with Titanic,"Therefore, it is important to consider which features are potentially the most important and zoom into these deciding parameters for hypterparameter optimization. The search took a good five to ten minutes, which is a fair amount of time. Let’s take a look at its results. We can also take a look at the best parameters that were found. It’s worth noting that the algorithm decided that the  is superior to , which in my opinion is no surprise. However, it is interesting to see our intuition being vindicated in this fashion nonetheless. Now it’s time for us to evaluate the model. While there are many different metrics we can use, in binary classification, we can look at things like accuracy, precision, recall, and the F1 score. Let’s take a look. The pipeline seems to be working correctly as expected, preprocessing and imputing the data as it was fit on the training data, then generating predictions using the model with optimized parameters. Let’s see how well our model is doing. One useful function in  is the  function, which, as the name implies, gives us a comprehensive report of many widely-used metrics, such as precision, recall, and the F1 score. The report suggests that the accuracy of our model on the test dataset is about 84 percent. We can manually verify this claim by calculating the accuracy ourselves using boolean indexing.",0,0,0,0,0,1,0,0
"PyTorch, From Data to Modeling","However, I actually prefer this low-levelness because it requires me to really think through what is happening in each iteration, namely what the dimension of each batch is, what the model expects to receive as input in the forward computation, and what loss function is appropriate given the output and label. Let’s see what all of this means. First, we begin by actually initializing an instance of the model, a loss function named , and an , which is Adam in this case. A quick note of caution: if you dig into the PyTorch documentation or look at other example classifiers, you will realize, like me, there are two loss functions you can typically use:  and , or negative log likelihood loss. The difference between the former and latter is that, while the former applies a softmax function to the output before calculating the actual loss, the latter does not. In our case, since we simply output the raw logits instead of applying a softmax calculation, we need to use the former. Let’s return where we were. Before we jump into training and defining the training loop, it’s always a good idea to see if the output of the model is what you’d expect. In this case, we can simply define some random dummy input and see if the output is correct. Now that we’ve verified the input and output dimensions, we can move onto defining the training loop.",0,0,1,0,0,0,0,0
Word2vec from Scratch,"The first step, as is the approach taken in many NLP tasks, is to tokenize the text, i.e. splitting the text up into smaller units like words, getting rid of punctuations, and so on. Here is a function that does this trick using regular expressions. Let’s create tokens using the Wikipedia excerpt shown above. The returned object will be a list containing all the tokens in . Another useful operation is to create a map between tokens and indices, and vice versa. In a sense, we are creating a lookup table that allows us to easily convert from words to indices, and indices to words. This will be particularly useful later on when we perform operations such as one-hot encoding. Let’s check if the word-to-index and index-to-word maps have successfully been created. As we can see, the lookup table is a dictionary object containing the relationship between words and ids. Note that each entry in this lookup table is a token created using the  function we defined earlier. Now that we have tokenized the text and created lookup tables, we can now proceed to generating the actual training data, which are going to take the form of matrices. Since tokens are still in the form of strings, we need to encode them numerically using one-hot vectorization. We also need to generate a bundle of input and target values, as this is a supervised learning technique. This then begs the question of what the input and target values are going to look like.",1,0,1,0,0,0,0,0
A PyTorch Primer,"We can go even a step farther and declare custom operations. For example, here’s a dummy implementation of the ReLU function. Let’s talk about the  method first. Note that it takes in two argument parameters:  and . As you might have guessed,  is simply the value that the function will be provided with. The  can simply be thought of as a cache where we can store vectors or matrices to be used during backpropagation. In this case, we store the  by calling  method. During the backward pass, we compute the gradient. Here, we need to retrieve the  variable which was stored in the context. This is because the ReLU function takes the following form: Thus, its derivative is During backpropagation, this means that gradients will flow down to the next layer only for those indices whose input elements to te ReLU function were greater than 0. Thus, we need the input vector for reference purposes, and this is done via stashing it in the  variable. We will see how we can incorporate  into the model in the next section. In this example, we’ll take a look at an extremely simple model to gain a better understanding of how everything comes into play in a more practical example. This is the method that I’ve mostly been using when implementing simple dense fully-connected models in NumPy. The idea is that we would mathematically derive the formula for the gradients ourselves, then backpropagate these values during the optimization process. Of course, this can be done with PyTorch.",0,0,1,0,0,0,0,0
First Neural Network with Keras,"specifies the number of iterations the gradient descent algorithm will run for. Let’s begin by loading the data from . Now we have to slightly modify the loaded data so that its dimensions and values are made suitable to be fed into a neural network. Changing the dimensionality of data can be achieved through the  function, which takes in the number of rows and columns as its argument. We convert the numbes into type , then normalize it so that its values are all between 0 and 1. Although we won’t get into too much detail as to why normalization is important, an elementary intuition we might develop is that normalization effectively squishes all values into the same bound, making data much more processable. We also implement one-hot encoding on  through the  function. Let’s quickly check if the necessary adjustments were made by looking up the dimensions of  and , respectively. Looks like the data has been reshaped successfully. Now, it’s finally time to get into the nuts and bolts of a neural network. The simplest neural network is the  model, which means that every neuron in one layer is connected to all other neurons in the previous layer. Building a simple neural network is extremely easy in a high level API like Keras. The model below has 784 input nodes. The input layer is then connected to a hidden layer with 512 neurons, which is then connected to a second hidden layer with also 512 neurons.",0,0,1,1,0,1,0,0
How lucky was I on my shift?,"In fact, some weird things happen if we block time into large units, such as an hour—notice how the value of  becomes , which is a probabilistic impossibility as  should always take values between . Another issue with this model is that a Bernoulli trial does not allow for simultaneous successes. Say, for instance, that within one ten-minute block, we got two calls. However, because the result of a Bernoulli trial is binary, i.e. either a success or a failure, it cannot contain more than one success in unit time. Therefore, binary distribution cannot encode higher dimensions of information, such as two or three simultaneous successes in one trial. These set of complications motivate a new way of modeling phone calls. In the next section, we look at an alternate approach to the problem: the Poisson distribution. Here is some food for thought: what if we divide up unit time into infinitesimally small segments instead of the original ten, such that ? This idea is precisely the motivation behind the Poisson distribution. If we divide our time frame of interest into infinite segments, smaller even than microseconds, we can theoretically model multiple successful events, which is something that the binomial distribution could not account for. Intuitively speaking, this approach is akin to modeling a continuous function as infinitely many stepwise functions such that two “adjacent” dots on the graph could be considered as identical points—or, in probabilistic terms, a simultaneous event.",0,0,0,0,1,0,0,1
PyTorch Tensor Basics,"More generally speaking, we can think that concatenation effectively brought the two elements of each tensor together to form a larger tensor of four elements. I found concatenation along the first and second dimensions to be more difficult to imagine right away. The trick is to mentally draw a connection between the dimension of concatenation and the location of the opening and closing brackets that we should focus on. In the case of the example above, the opening and closing brackets were the outer most ones. In the example below in which we concatenate along the first dimension, the brackets are those that form the boundary of the inner two-dimensional 3-by-4 tensor. Let’s take a look. Notice that the rows of  were essentially appended to those of , thus resulting in a tensor whose shape is . For the sake of completeness, let’s also take a look at the very last case, where we concatenate along the last dimension. Here, the brackets of focus are the innermost ones that form the individual one-dimensional rows of each tensor. Therefore, we end up with a “long” tensor whose one-dimensional rows have a total of 8 elements as opposed to the original 4. In this post, we took a look at some useful tensor manipulation operations and techniques. Although I do have some experience using Keras and TensorFlow, I never felt confident in my ability to deal with tensors, as that felt more low-level. PyTorch, on the other hand, provides a nice combination of high-level and low-level features.",0,0,1,0,0,0,0,0
The Exponential Family,"In this sense, the exponential family is particularly of paramount importance in the field of Bayesian inference, as we have seen many times in previous posts. Let’s concretize our understanding of the exponential family by applying factorization to actual probability distributions. The easiest example, as you might have guessed, is the exponential distribution. Recall that the formula for the exponential distribution is where the indicator function, denoted as , takes the following form: The indicator function is a simple  modification applied to ensure that the function is well-defined across the entire real number domain. Normally, we omit the indicator function since it is self-apparent, but for the sake of robustness in our analysis, I have added it here. How can we coerce equation (6) to look more like (3), the archetypal form that defines the exponential family? Well, now it’s just a matter of drag and match: by paying close attention to the variables, parameters, and the output of each function, we can reconstruct (3) to take the form of (6). The easeist starting point is to observe the exponent to identify  and , after which the rest of the surrounding functions can be inferred. The end result is presented below: After substituting each function with their prescribed value in (8), it isn’t difficult to see that the exponential distribution can indeed by factorized according to the form outlined in (3).",0,0,0,0,1,0,0,1
