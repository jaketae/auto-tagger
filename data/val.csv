title,body,deep_learning,linear_algebra,machine_learning,from_scratch,statistics,pytorch,analysis,probability_distribution
Scikit-learn Pipelines with Titanic,"In today’s post, we will explore ways to build machine learning pipelines with Scikit-learn. A pipeline might sound like a big word, but it’s just a way of chaining different operations together in a convenient object, almost like a wrapper. This abstracts out a lot of individual operations that may otherwise appear fragmented across the script. I also personally think that Scikit-learn’s ML pipeline is very well-designed. So here is a brief introduction to ML pipelines is Scikit-learn. For the purposes of this tutorial, we will be using the classic Titanic dataset, otherwise known as the course material for Kaggle 101. I’m still trying to get my feet into Kaggle, so it is my hope that this tutorial will also help those trying to break into data science competitions. First, let’s import the modules and datasets needed for this tutorial. Scikit-learn is the go-to library for machine learning in Python. It contains not only data loading utilities, but also imputers, encoders, pipelines, transformers, and search tools we will need to find the optimum model for the task. Let’s load the dataset using . Let’s observe the data by calling . By default, this shows us the first five rows and as many columns as it can fit within the notebook. Let’s take a look at the data in more depth to build a foundation for our analysis. This step typically involves the following steps: Let’s proceed in order. Before proceeding with any data analysis, it’s always a good idea to pay attention to missing values—how many of them there are, where they occur, et cetera. Let’s take a look. The is useful, but is doesn’t really show us how many values are missing for each column. To probe into this issue in more detail, we need to use instead. I recently realized that there is also a very cool data visualization library called for observing missing data. This visualization gives us a more intuitive sense of where the values are missing. In this case, the missing values seem to be distributed somewhat evenly or randomly. However, we can also imagine cases were missing values might have something to do with an inherent attribute in the dataset (e.g. only male participants of a survey might reply “N/A” to some health questionaire involving inquiries on pregnancy). In such cases, using this library to visualize where missing values occur is a good idea, as this is an additional dimension of information that calling wouldn’t be able to reveal. Now that we have a rough sense of where missing values occur, we need to decide from one of few choices: Indeed, in this case, we will go ahead and drop the attribute. This choice becomes more obvious when we compute the percentage of null values. This shows us that 77 percent of the rows have missing attribute values. Given this information, it’s probably a bad idea to try and impute these values. We opt to drop it instead. Correlation (or somewhat equivalently, covariance) is a metric that we always care about, since ultimately the goal of ML engineering is to use a set of input features to generate a prediction. Given this context, we don’t want to feed our model useless information that lacks value; instead, we only want to feed into the model highly correlated, relevant, and informative features. If certain features in the raw data are deemed useless, we need to either drop it or engage in some sort of feature engineering to produce a new set of more correlated features. From this preliminary analysis, it seems like there are some very weekly correlated features, namely and . The week correlation suggests that perhaps we need to engage in some feature engineering to extract more meaningful information out of the dataset. Let’s use the findings from the previous section to engineer some more informative features. One popular approach is to make use of names to derive a feature. Intuitively, this makes sense: Mr. and Mrs, Cpt. and Dr. might be of interest for our model. Another popular approach is to combine the less important features— and —into something like . Implementing these should fairly be simple, so let’s try it here. Note that in an actual setting, there will be no answer to reference; we will have to rely on our own domain knowledge and more extensive EDA to figure out which features matter, and what new features we will need. Sometimes, weakly correlated features can be combined together to form a new feature, which might exhibit higher correlation with respect to the target. We can combine and into a new feature, called . Strictly speaking, we would have to add 1, but adding all values by one corresponds to shifting everything by a constant value, which will not affect modeling since such constant adjustments will be taken care of by the preprocessing step anyway. Note that feature engineering is also applied to both the training and test set simultaneously. We have created two new features, namely and . Let’s go ahead and perform feature engineering on the column as well to squeeze out more information. Now we have some data that seems a lot more workable. However, we still have a problem with the column: It seems like there are many titles, so we should probably perform some binning or grouping. For men, the most common title is ; for women, and . Let’s see if there is a difference in the survival rate between the two most common title for females It seems like the the difference is insignificant, so we will simply group them together in one. Imputation refers to a technique used to replace missing values. There are many techniques we can use for imputation. From the analysis above, we know that the columns that require imputation are as follows: Let’s first take a look at the data types for each column. Checking data types is necessary both for imputation and general data preprocessing. Specifically, we need to pay attention as to whether a given column encodes categorical or numerical variables. For example, we can’t use the mean to impute categorical variables; instead, something like the mode would make much more sense. The best way to determine whether a variable is categorical or not is simply to use domain knowledge and actually observe the data. Of course, one might use hacky methods like the one below: Although you might think that this is a working hack, this approach is in fact highly dangerous, even in this toy example. For example, consider , which is supposedly a numerical variable of type . However, earlier with , we saw that is in fact a ordinal variable taking discrete values, one of 1.0, 2.0, and 3.0. So hacky methods must not be used in isolation; at the very least, they need to be complemented with some form of human input. Let’s try to use a simple pipeline to deal with missing values in some categorical variables. This is going to be our first sneak peak at how pipelines are declared and used. Here, we have declared a three-step pipeline: an imputer, one-hot encoder, and principal component analysis. How this works is fairly simple: the imputer looks for missing values and fills them according to the strategy specified. There are many strategies to choose from, such as most constant or most frequent. Then, we one-hot encode the categorical variables since most machine learning models cannot accept non-numerical values as input. The last PCA step might seem extraneous. However, as discussed in this Stack Overflow thread, the judicious combination of one-hot plus PCA can seldom be beat by other encoding schemes. PCA finds the linear overlap, so will naturally tend to group similar features into the same feature. I don’t have enough experience to attest to the veracity of this claim, but mathematically or statistically speaking, this proposition seems valid. The idea is that one-hot encoding all categorical variables may very well lead to an unmanageable number of columns, thus causing one to flounder in the curse of dimensionality. A quick fix, then, is to apply PCA or some other dimensionality reduction technique onto the results of one-hot encoding. Back to the implementation, note that we can look inside the individual components of by simply treating it as an iterable, much like a list or tuple. For example, Next, we need to do something similar for numerical variables. Only this time, we wouldn’t be one-hot encoding the data; instead, what we want to do is to apply some scaling, such as normalization or standardization. Recently in one of Andreas Mueller’s lectures on YouTube, I learned about the , which uses median and IQR instead of mean and standard deviation as does the . This makes the a superior choice in the presence of outliers. Let’s try using it here. Now that we have the two pipelines for numeric and categorical columns, now it’s time to put them together into one nice package, then apply the process over the entire dataframe. This packaging can nicely be abstracted via the , which is the magic glue to put all the pieces together. We simply have to tell which transformer applies to which column, along with the name for each process. is the complete package that we will use to transform our data. Note that allows us to specify which pipeline will be applied to which column. This is useful, since by default, imputers or transformers apply to the entire dataset. More often or not, this is not what we want; instead, we want to be able to micro-manage categorical and numerical columns. The combination of and is thus a very powerful one. Now all that is left is to build a final pipeline that includes the classifier model. Let’s see how well our model performs on a stratified 5-fold cross validation. Note that this is without any hyperparameter tuning. And just like that, we can evaluate the performance of our model. When it comes to general fitting and testing, a useful tip I found on Kaggle is the following rule of thumb: If you think about it for a second, this configurations makes a lot of sense: if the pipeline contains a model, it means that it is the full package. All the steps prior to the model would involve wrangling the data; the last step would have the model use the data to make a prediction. Therefore, calling should apply only to the last model after is called on all the preprocessing steps. If the pipeline itself is just a bundle of preprocessors, on the other hand, we should only be able to call . Scikit-learn’s models are great, but in a sense they are too great. This is because there are a lot of hypterparameters to tune. Fortunately for us, we can somewhat resort to a quasi-brute force approach to deal with this: train models on a number of different combinations of hyperparameters and find the one that performs best! Well, this is what does. is not quite as bad in that it doesn’t create and test all possible models that distinct combinations of hyperparameters can yield: instead, it relies on a randomized algorithm to perform a search of the hyperparameter space. This is why is a lot quicker than , with marginal sacrifices in model performance. Let’s see how we might be able to perform hyperparameter search given a pipeline like the one we have built above. The parameter space we are searching for here is by no means exhaustive, but it covers a fair amount of ground. Of course, we can go crazy with randomized search, basically shoving Scikit-learn with every possible configuration and even running a grid search instead. However, that would take an extreme amount of time and computing resources. Therefore, it is important to consider which features are potentially the most important and zoom into these deciding parameters for hypterparameter optimization. The search took a good five to ten minutes, which is a fair amount of time. Let’s take a look at its results. We can also take a look at the best parameters that were found. It’s worth noting that the algorithm decided that the is superior to , which in my opinion is no surprise. However, it is interesting to see our intuition being vindicated in this fashion nonetheless. Now it’s time for us to evaluate the model. While there are many different metrics we can use, in binary classification, we can look at things like accuracy, precision, recall, and the F1 score. Let’s take a look. The pipeline seems to be working correctly as expected, preprocessing and imputing the data as it was fit on the training data, then generating predictions using the model with optimized parameters. Let’s see how well our model is doing. One useful function in is the function, which, as the name implies, gives us a comprehensive report of many widely-used metrics, such as precision, recall, and the F1 score. The report suggests that the accuracy of our model on the test dataset is about 84 percent. We can manually verify this claim by calculating the accuracy ourselves using boolean indexing. Let’s top this discussion off with a look at the confusion matrix, which is another way of compactly encoding various pieces of information for model evaluation, namely true positives, true negatives, false positives, and false negatives. Note that precision and recall are all metrics that are computed using TP, TN, FP and FN as parameters. The confusion matrix shows that our model performs well at determining the death and survival of those passengers who actually died, but performs rather poorly on those who lived. Analyses like these cannot be obtained simply by looking at accuracy, which is why plotting the confusion matrix is always a good idea to get a sense of the model’s performance. Although the titanic dataset is considered trite, much like MNIST is in the context of DL, I still think there is a lot to be learned. Even simple ML projects like these have infinite spaces and options for exploration and experimentation. I hope to go through these classic datasets and competitions to glean insight from excellent public kernels, just like this Kaggle kernel which I referenced extensively to write this tutorial. In its inception, this post was conceived of as a simple introduction to ’s pipelines, but it eventually ballooned up into a somewhat comprehensive rundown of a little Kaggle project. I hope to do a lot more of these in the coming days, just because I think there is immense value in mastering ML, although DL sounds a lot cooler. I hope you enjoyed reading this post. Catch you up in the next one!",0,0,1,0,0,0,0,0
Revisiting Basel with Fourier,"In the last post, we revisited the Riemann Zeta function, which we had briefly introduced in another previous post on Euler’s take on the famous Basel problem. It seems like math is my jam nowadays, so I decided to write another post on this topic—but this time, with some slightly different takes. In this post, we will explore an alternative way of solving the Basel problem using Fourier series expansion, and also discuss a alternative representations of the Basel problem in integral form. For the integral representations, I’m directly referencing Flammable Maths, a YouTube channel that I found both entertaining and informative. Let’s get started. First, let’s recall what the Basel problem is. The problem is quite simple: the goal is to obtain the value of an infinite series, namely This seems like an innocuous, straightforward problem. One can easily prove, for instance, the fact that this series converges using integral approximation. However, to obtain the value of this series is a lot more difficult than it appears—it is no coincidence that this problem remained unsolved for years until Euler came along. While there are many ways to solve this problem—Euler’s method, in particular, is one of the countless examples through which one can witness his amazing intuition and heuristic—but we will be using Fourier expansion to solve this problem, as it also provides a nice segue into the Dirichlet Eta function. We explored the topic of Fourier expansion in this previous post. To recap, from a very high level, Fourier expansion is a way of expressing some function in terms of trigonometric functions. If Taylor expansion used polynomials as the building block, Fourier expansion uses sines and cosines. A generic formula for the Fourier transform can be expressed as follows: With some integration, it can be shown that where math variable refers to the domain of integration. For instance, if we are integrating from math variable to math variable, math variable. A classic interval that is most commonly used is math variable, and this is no coincidence: notice that, when math variable, the Taylor series shown in (2) simplifies into the following: And indeed this is the format and the interval we will be using when constructing a Fourier series to tackle the Basel problem. To continue, we can derive a very similar expression for math variable, given the specified interval from math variable. Now that we have reviewed what Fourier series is and how we can construct it, let’s jump into the Basel problem. Just like the Taylor series, we can use Fourier expansion to represent any function continuous function. For our purposes, let’s try to expand a simple polynomial function, math variable, using Fourier. We can begin with math variable. Let’s continue with finding the even coefficients corresponding to the cosines. With some integration by parts, we can all agree that where the math variable terms appear because we end up plugging math variable into math variable, a periodic function. And we can do the same for sine. Or, even better, with the key insight that math variable is an even function, we might intelligently deduce that there will be no sine terms at all, since sine functions are by nature odd. In other words, all math variable. This can of course be shown through derivation as we have done above for the cosine coefficients. Therefore, putting everything together, we end up with If we consider the case when math variable, we have Do you smell the basel problem in the air? The summation on the right hand side is a great sign that we are almost done in our derivation. Moving the fractional term to the left hand side, we get: Diding both sides by 4, And there you have it, the answer to the Basel problem, solved using Fourier series! We can also derive a convergence value of the Dirichelt Eta function from this Fourier series as well. Recall that the Eta function looks as follows: Now how can we get a Dirichelt Eta function out of the fourier series of math variable? Well, let’s get back to (8) and think our way through. One noteworthy observation is that we already have math variable in the summation, which looks awfully similar to the Dirichlet Eta function. Since we want to get rid of the cosine term, we can simply set math variable—this will make all cosine terms evaluate to 1, effectively eliminating them from the expression. Then, we get With a very small bit of algebra, we end up with And there we have it, the value of math variable! It’s interesting to see how all this came out of the fourier series of math variable. In this section, we will be taking a look at some interesting representations of the Basel problem, mysteriously packaged in integrals. At a glance, it’s somewhat unintuitive to think that an infinite summation problem can be stated as an integral in exact terms; however, the translation from summation to integrals are not out of the blue. Using things like Taylor series, it is in fact possible to show that the Basel problem can be stated as an integral. For instance, consider this integral One thing I am starting to realize these past few days is that some of these integrals are extremely difficult despite being deceptively simple in their looks. This is a good example. To get started, we might consider making a quick change of variables, namely math variable. This will effectively get rid of the rather messy-looking denominator sitting in the fraction. To make further progress, at this point let’s consider the Taylor series expansion of math variable. We can derive this by considering the following integral: since this integral evaluates to math variable. One way to look at (10) would be to consider it as a sum of some geometric series whose first term begins with 1 and has a constant ratio of math variable. In other words, Here is where a bit of complication comes in. Turns out that under certain conditions, we can exchange the summation and the integral (or, more strictly speaking, the limit and the integral), using things like the dominating convergence theorem of Fubini’s theorem. However, these are topics for another post. For now, we will assume that this trick is legal and continue on. Now we have Now that we have a summation representation of math variable, let’s move onto (11). We use the same trick we used earlier to interchange the summation and the integral. This gives us Since we have to terms with negative ones with the same exponent, we can safely remove both of them: And notice that we now have the Basel problem! If you plug in math variable and increment math variable from there, it is immediately apparent that this is the case. So there we have it, the integral representation of the Basel problem! Let’s look at another example, this time using a double integral representation. The motivation behind this approach is simple. This is a useful result, since it means that we can express the Basel problem as an integral of two different variables. Now, all we need is a summation expression before the integration. And now we are basically back to the Basel problem. Note that we can also use the interchange of integral and summation technique again to reexpress (19) as shown below. Notice that now we have a geometric series, which means that now we can also express this integral as Like this, there are countless ways of using integrals to express the Basel problem. This representation, in particular, could be understood as an integral over a unit square in the cartesian coordinate over a bivariate function, math variable. In this post, we took a look at a new way of approaching the Basel problem using Fourier expansion. We also looked at some interesting integral representations of the Basel problem. While a lot of this is just simple calculus and algebra, I nonetheless find it fascinating how the Basel problem can be approached from so many different angles—hence my renewed respect for Euler and other mathematicians who wrestled with this problem hundreds of years ago. As simple as it appears, there are so many different techniques and modes of analysis we can use to approach the problem. It was nice exercise and review of some calculus techniques. I’ve been digging more into the curious interchange of integral and summation recently, and when this operation is allowed, if at all. Turns out that this problem is slightly more complicated than it appears and requires some understanding of measure theory, which I had tried getting into a few months ago without much fruition. Hopefully this time, I’ll be able to figure something out, or at the very least gain some intuition on this operation. I hope you’ve enjoyed reading this post. Catch you up in the next one.",0,0,0,0,0,0,1,0
The Exponential Family,"Normal, binomial, exponential, gamma, beta, poisson… These are just some of the many probability distributions that show up on just about any statistics textbook. Until now, I knew that there existed some connections between these distributions, such as the fact that a binomial distribution simulates multiple Bernoulli trials, or that the continuous random variable equivalent of the geometric distribution is the exponential. However, reading about the concept of the exponential family of distributions has lent me new insight, and I wish to share that renewed understanding on probability distributions through this post. In this section, we will take a look at what the exponential family of distributions is all about. We will begin by laying out a few mathematical definitions, then proceed to see examples of probability distributions that belong to the exponential family. To cut to the chase, the exponential family simply denotes a group of probability distributions that satisfy a certain condition, namely that they can be factorized and parametrized into a specific form, as show below: Here, math variable is a log noramlizing constant that ensures that the probability distribution integrates to 1. There are other alternative forms that express the same factorization. One such variant that I prefer and find more intuitive uses a simple fractional approach for normalization instead of adding complications to the exponential term. For notational convenience, I will follow the fractional normalization approach shown below throughout this post. Before we proceed any further, it is probably a good idea to clarify the setup of the equations above. First, math variable denotes a math variable-dimensional random variable of interest; math variable, a math variable-dimensional parameter that defines the probability distribution. math variable is known as the sufficient statistic function. Below is a brief summary concerning the mappings of these different functions. You will notice that I used math variable and math variable instead of math variable and math variable as shown in equation (3). This is because (3) assumes vectorization of these functions as follows. We could have expressed (3) without vectorization, but doing so would be rather verbose. So we instead adhere to the vectorized convention in (3) throughout this post. As I hinted earlier, the exponential family covers a wide range of probability distributions, most PDFs and PMFs. In fact, most probability distributions that force themselves onto the page of statistics textbooks belong to this powerful family. Below is a non-comprehensive list of distributions that belong to the exponential family. Probability Density Functions Probability Mass Functions Of course, there are examples of common distributions that do not fall under this category, such as the uniform distribution or the student math variable-distribution. This point notwithstanding, the sheer coverage of the exponential family makes it worthy of exploration and analysis. Also, notion of an exponential family itself is significant in that it allows us to frame problems in meaningful ways, such as through the notion of conjugate priors: if you haven’t noticed, the distributions outlined above all have conjugate priors that also belong to the exponential family. In this sense, the exponential family is particularly of paramount importance in the field of Bayesian inference, as we have seen many times in previous posts. Let’s concretize our understanding of the exponential family by applying factorization to actual probability distributions. The easiest example, as you might have guessed, is the exponential distribution. Recall that the formula for the exponential distribution is where the indicator function, denoted as math variable, takes the following form: The indicator function is a simple modification applied to ensure that the function is well-defined across the entire real number domain. Normally, we omit the indicator function since it is self-apparent, but for the sake of robustness in our analysis, I have added it here. How can we coerce equation (6) to look more like (3), the archetypal form that defines the exponential family? Well, now it’s just a matter of drag and match: by paying close attention to the variables, parameters, and the output of each function, we can reconstruct (3) to take the form of (6). The easeist starting point is to observe the exponent to identify math variable and math variable, after which the rest of the surrounding functions can be inferred. The end result is presented below: After substituting each function with their prescribed value in (8), it isn’t difficult to see that the exponential distribution can indeed by factorized according to the form outlined in (3). Although this is by no means a rigorous proof, we see not only the evident fact that the exponential distribution indeed belongs to the exponential family, but also that the factorization formula in (3) isn’t just a complete soup of equations and variables. We can do the same for the Bernoulli distribution, which also falls under the exponential family. The formula for the Bernoulli distribution goes as follows: Again, I have added a very simple indicator function to ensure that the the probability mass function is well-defined across the entire real number line. Again, the indicator function is a simple boolean gate function that checks whether math variable is an element within a set of zero and one: Factorizing the Bernoulli is slightly more difficult than doing the same for the exponential distribution, largely because it is not apparent from (9) how factorization can be achieved. For example, we do not see any exponential term embedded in (9) as we did in the case of the exponential distributions. Therefore, a simple one-to-one correspondence cannot be identified. The trick to get around this problem is to introduce a log transformation, then reapplying an exponential. In other words, By applying this manipulation, we can artificially create an exponential term to more easily coerce (9) into the factorization mold. Specifically, observe that the power of the exponent can be expressed as a dot product between two vectors, each parameterized by math variable and math variable , respectively. This was the hard part: now, all that is left is to configure the rest of the functions to complete the factorization. One possible answer is presented below: By now, it should be sufficienty clear that the definition of the exponential family is robust enough to encompass at least the two probability distributions: the exponential and the Bernoulli. Although we do not go over other examples in this article, the exponential family is a well-defined set of probability distributions that, at thei core, are defined by a common structure. And as we will see in the next section, this underlying similarity makes certain calculations surprisingly convenient. In a previous post, we explorerd the notion of maximum likelihood estimation, and contrasted it with maximum a posteriori estimation. The fundamental question that maximum likelihood estimation seems to answer is: given some data, what parameter of a distribution best explains that observation? This is an interesting question that merits exploration in and of itself, but the discussion becomes a lot more interesting and pertinent in the context of the exponential family. Before diving into MLE, let’s define what is known as the canonical form of the exponential family. Despite its grandiose nomenclature, the canonical form simply refers to a specific flavor of factorization scheme where in which case (3) simplifies to We will assume some arbitrary distribution in the exponential family following this canonical form to perform maxmimum likelihood estimation. Much like in the previous post on maximum likelihood estimation, we begin with some data set of math variable independent and identically distributed observations. This is going to be the setup of the MLE problem. Given this dataset, the objective of maximum likelihood estimation is to identify some parameter math variable that maximizes the likelihood, i.e. the probability of observing these data points under a probability distribution defined by math variable. In other words, How do we identify this parameter? Well, the go-to equipment in a mathematician’s arsenal for an optimization problem like this one is calculus. Recall that our goal is to maximize the likelihood function, which can be calculated as follows: The first equality stands due to the assumption that all data are independent and identically distributed. Maximizing (16) is a complicated task, especially because we are dealing with a large product. Products aren’t bad, but we typically prefer sums because they are easier to work with. A simple hack that we almost always use when dealing with maximum likelihood, therefore, is to apply a log transformation to calculate the log likelihood, since the logarithm is a monotonically increasing function. In other words, What does the log likelihood look like? Well, all we have to do is to apply a log function to (16), which yields the following result. Maximizing the log liklihood can be achieved by setting the gradient to zero, as the gods of calculus would tell us. As you might recall from a previous post on some very basic matrix calculus, the gradient is simply a way of packaging derivatives in a multivariate context, typically involving vectors. If any of this sounds unfamilar, I highly recommend that you check out the linked post. We can compute the partial derivative of the log likelihood function with respect to math variable as shown below. Observe that the last term in (18) is eliminated because it is a constant with respect to math variable. This is a good starting point, but we still have no idea how to derive the log of math variable. To go about this problem, we have to derive an expression for math variable. Recall from the definition of the exponential family that math variable is a normalizing constant that exists to ensure that the probability function integrates to one. In other words, This necessarily implies that Now that we have an expression for math variable to work with, let’s try to compute the derivative term we left unsolved in (19). The first and second equalities stand due to the chain rule, and the third equality is a simple algebraic manipulation that recreates the probability function within the integral, allowing us to ultimately express the partial derivative as an expected value of math variable for the random variable math variable. This is a surprising result, and a convenient one indeed, because we can now use this observation to conclude that the gradient of the log likelihood function is simply the expected value of the sufficient statistic. Therefore, starting again from (19), we can continue our calculation of the gradient and set the quantity equal to zero to calculate the MLE estimate of the parameter. It then follows that How do we interpret the final result in equation (25)? It looks nice, simple, and concise, but what does it mean to say that the expected value of the sufficient statistic is the average of the sufficient statistic for each observed individual data points? To remove abstractness, let’s employ a simple example, the exponential distribution, and attempt to derive a clearer understanding of the final picture. Recall that the probability density function of the exponential distribution takes the following form according to the factorizations outlined below: Computing the derivative of the log of the normalizing term math variable as we did in (22), Because we know that the resulting quantity is the expected value of the sufficient statistic, we know that And indeed, this is true: the expected value of the random variable characterized by an exponential distribution is simply the inverse of the parameter defining that distribution. Note that the parameter for the exponential distribution is most often denoted as math variable, in which case the expected value of the distribution would simply be written as math variable. This is all great, but there is still an unanswered question lingering in the air: what is the MLE estimate of the parameter math variable ? This moment is precisely when equation (25) comes in handy. Recall that Therefore, Finally, we have arrived at our destination: We finally know how to calculate the parameter under which the likelihood of observing given data is maximized. The beauty of this approach is that it applies to all probability distributions that belong to the exponential family because our analysis does not depend on which distribution is in question; we started from the canonical form of the exponential family to derive a set of generic equations. This is the convenience of dealing with the exponential family: because they are all defined by the same underlying structure, the MLE equations hold general applicability. In this post, we explored the exponential family of distributions, which I flippantly ascribed the title “The Medici of Probability Distributions.” This is obviously my poor attempt at an intellectual joke, to which many of you might cringe, but I personally think it somewhat captures the idea that many probability distributions that we see on the textbook are, in fact, surprisingly more related than we might think. At least to me, it wasn’t obvious from the beginning that the exponential and the Bernoulli distributions shared the same structure, not to mention the wealth of other distributions that belong to the exponential family. Also, the convenient factorization is what allowed us to perform an MLE estimation, which is an important concept in statistics with wide ranging applications. This post in no way claims to give a full, detailed view of the exponential family, but hopefully it gave you some understanding of what it is and why it is useful. In the next post, we will take a look at maximum a posteriori estimation and how it relates to the concept of convex combinations. Stay tuned for more.",0,0,0,0,1,0,0,1
Bayesian Linear Regression,"In today’s post, we will take a look at Bayesian linear regression. Both Bayes and linear regression should be familiar names, as we have dealt with these two topics on this blog before. The Bayesian linear regression method is a type of linear regression approach that borrows heavily from Bayesian principles. The biggest difference between what we might call the vanilla linear regression method and the Bayesian approach is that the latter provides a probability distribution instead of a point estimate. In other words, it allows us to reflect uncertainty in our estimate, which is an additional dimension of information that can be useful in many situations. By now, hopefully you are fully convinced that Bayesian linear regression is worthy of our intellectual exploration. Let’s take a deep dive into Bayesian linear regression, then see how it works out in code using the library. In this section, we will derive the formula for Bayesian linear regression step-by-step. If you are feeling rusty on linear algebra or Bayesian analysis, I recommend that you go take a quick review of these concepts before proceeding. Note that I borrowed heavily from this video for reference. For any regression problem, we first need a data set. Let math variable denote this pre-provided data set, containing math variable entries where each entry contains an math variable-dimensional vector and a corresponding scalar. Concretely, where The goal of Bayesian linear regression is to find the predictive posterior distribution for math variable. This is where the difference between Bayesian linear regression and the normal equation method becomes most apparent. Whereas vanilla linear regression only gives us a single point estimate given an input vector, Bayesian linear regression gives an entire distribution. For the purposes of our demonstration, we will define the predictive posterior to take the following form as shown below, with precision math variable pre-given. Precision is simply the reciprocal of variance and is commonly used as an alternative way of parametrizing Gaussian distributions. In other words, we assume the model Our goal will be to derive a posterior for this distribution by performing Bayesian inference on math variable, which corresponds to the slope of the linear regression equation, where math variable denotes noise and randomness in the data, thus affecting our final prediction. To begin Bayesian inference on parameter math variable, we need to specify a prior. Our uninformed prior will look as follows. where math variable denotes precision, the inverse of variance. Note that we have a diagonal covariance matrix in place of variance, the distribution for math variable will be a multivariate Gaussian. The next ingredient we need for our recipe is the likelihood function. Recall that likelihood can intuitively be understood as an estimation of how likely it is to observe the given data points provided some parameter for the true distribution of these samples. The likelihood can easily be computed by referencing back to equation (1) above. Note that the dot product of math variable with itself yields the sum of the exponents, which is precisely the quantity we need when computing the likelihood. where math variable is a design matrix given by and math variable is a column vector given by Before calculating the posterior, let’s recall what the big picture of Bayesian inference looks like. where math variable denotes the parameter of interest for inference. In plain terms, the proposition above can be written as In other words, the posterior distribution can be obtained by calculating the product of the prior distribution and the likelihood function. In many real-world cases, this process can be intractable, but because we are dealing with two Gaussian distributions, the property of conjugacy ensures that this problem is not only tractable, but also that the resulting posterior would also be Gaussian. Although this may not be immediately apparent, observe that the exponent is a quadratic that follows the form after making appropriate substitutions Therefore, we know that the posterior for math variable is indeed Gaussian, parameterized as follows: Let’s try to obtain the MAP estimate of of math variable, i.e. simplify math variable Notice the similarity with the MLE estimate, which is the solution to normal equation, which I otherwise referred to as vanilla linear regression: This is no coincidence: in a previous post on MAP and MLE, we observed that the MAP and MLE become identical when we have a uniform prior. In other words, the only cause behind the divergence between MAP and MLE is the existence of a prior distribution. We can thus consider the additional term in (10) absent in (11) as a vestige of the prior we defined for math variable. MAP versus MLE is a recurring theme that appears throughout the paradigmatic shift from frequentist to Bayesian, so it merits discussion. Now that we have a posterior distribution for math variable which we can work with, it’s time to derive the predictive distribution. We go about this by marginalizing math variable using the property of conditional probability, as illustrated below. This may seem like a lot, but most of it was simple calculation and distributing vectors over parentheses. It’s time to use the power of conjugacy again to extract a normal distribution out of the equation soup. Let’s complete the square of the exponent according to the Gaussian form after making the appropriate substitutions Again, observing this is not a straightforward process, especially if we had no idea what the final distribution is going to look like. However, given that the resulting predictive posterior will take a Gaussian form, we can backtrack using this knowledge to obtain the appropriate substitution parameters in (13). Continuing, where the last equality stands because we can pull out terms unrelated to math variable by considering them as constants. Why do we bother to pull out the exponent? This is because the integral of a probability density function evaluates to 1, leaving us only with the exponential term outside the integral. To proceed further from here, let’s take some time to zoom in on math variable for a second. Substituting math variable, we get We can now plug this term back into (15) as shown below. Although it may seem as if we made zero progress by unpacking math variable, this process is in fact necessary to complete the square of the exponent according to the Gaussian form after making the substitutions By now, you should be comfortable with this operation of backtracking a quadratic and rearranging it to complete the square, as it is a standard operation we have used in multiple parts of this process. Finally, we have derived the predictive distribution in closed form: With more simplification using the , it can be shown that And there’s the grand formula for Bayesian linear regression! This result tells us that, if we were to simply get the best point estimate of the predicted value math variable, we would simply have to calculate math variable, which is the tranpose product of the MAP estimate of the weights and the input vector! In other words, the answer that Bayesian linear regression gives us is not so much different from vanilla linear regression, if we were to reduce the returned predictive probability distribution into a single point. But of course, doing so would defeat the purpose of performing Bayesian inference, so consider this merely an intriguing food for thought. As promised, we will attempt to visualize Bayesian linear regression using the library. Doing so will not only be instructive from a perspective of honing probabilistic programming skills, but also help us better understand and visualize Bayesian inference invovled in linear regression as explored in the context of this article. Note that, being a novice in , I borrowed heavily from this resource available on the official documentation. First, let’s begin by importing all necessary modules. Let’s randomly generate two hundred data points to serve as our toy data set for linear regression. Below is a simple visualization of the generated data points alongside the true line which we will seek to approximate through regression. Now is the time to use the library. In reality, all of the complicated math we combed through reduces to an extremely simple, single-line command shown below. Under the hood, the using variations of random sampling to produce an approximate estimate for the predictive distribution. Now that the trace plot is ready, let’s see what the estimated vallues are like. We drop the first hundred sampled values may have been affected by a phenomena known as burn-in. Intuitively, the sampler needs some time to stabilize around the mean value, which is why the first few samples may contain more noise and provide information of lesser value compared to the rest. We see two lines for each plot because the sampler ran over two chains by default. What do those sampled values mean for us in the context of linear regression? Well, let’s plot some sampled lines using the function conveniently made available through the library. We see that the gray lines, sampled by , all seem to be a good estimate of the true regression line, colored in gold. We might also notice that the sampled regression lines seem to stay below the true regression line for smaller values of math variable. This is because we have more samples beneath the true regression line that we have above it. Bayesian linear regression is able to account for such variations in data and uncertainty, which is a huge advantage over the simple MLE linear regression method. The true power of Bayesian linear regression might be summarized as follows: instead of returning just a single line using the MLE weight estimate of data, Bayesian linear regression models the entire data set to create a distribution of linear functions so to speak, allowing us to sample from that distribution to obtain sample linear regression lines. This is an approach that makes much more sense, since it allows us to take into account the uncertainty in our linear regression estimate. The reason why the normal equation method is unable to capture this uncertainty is that—as you might recall from the derivation of the formula for vanilla linear regression—the tools we used did not involve any probabilistic modeling. Recall that we used only linear algebra and matrix calculus to derive the model for vanilla linear regression. Bayesian linear regression is more complicated in that it involves computations with probability density functions, but the end result is of course more rewarding. That’s it for today! I hope you enjoyed reading this post. Catch you up in the next one.",0,1,0,0,0,0,0,0
Dissecting LSTMs,"In this post, we will revisit the topic of recurrent neural networks, or RNNs. Although we have used RNNs before in a previous post on character-based text prediction, we glossed over LSTM and assumed it as a black box that just worked. Today, we will take a detailed look at how LSTMs work by dissecting its components. Note that this post was inspired by this article by Kristiadi. I also heavily referenced this post by Christopher Olah. If you find any part of this article intriguing and intellectually captivating, you will surely enjoy reading their blogs as well. With this in mind, let’s jump right into it. Long Short-Term Memory networks, or LSTMs for short, are one of the most widely used building blocks of Recurrent Neural Networks, or RNNs. This is because LSTMs overcame many of the limitations of basic vanilla RNNs: while simple RNN gates are bad at retaining long-term information and only remember input information that were fed into it relatively recently, LSTMs do a great job of retaining important information, even if they were fed into the cell long time ago. In other words, they are able to somewhat mimic the function of the brain, which involves both long and short-term memory. The structure of an LSTM cell might be summarized as follows: Note that math variable represents the Hadamard Product, which is nothing more than just the element-wise multiplication of matrices. This long list of equations surely looks like a lot, but each of them has a specific purpose. Let’s take a look. The first component of LSTM is the forget gate. This corresponds to these two set of equations: (1) is nothing more than just the good old forward pass. We concatenate math variable and math variable, then multiply it with some weights, add a bias, and apply a sigmoid activation. At this point, you might be wondering why we use a sigmoid activation instead of something like ReLU. The reason behind this choice of activation function becomes apparent once we look at (4), which is how LSTM imitates forgetting. For now, we will only focus on the first term in (4). Recall that the output of a sigmoid activation is between 0 and 1. Say the output of applying a sigmoid activation results in some value that is very close to 0. In that case, calculating the Hadamard product will also result in a value of an entry very close to 0. Given the interpretation that math variable, also known as the cell state, is an artificial way of simulating long-term memory, we can see how having zeros is similar to forgetfulness: a zero entry effectively means that the network deemed a particular piece of information as obsolete and decided to forget it in favor of accepting new information. In short, the sigmoid activation and the Hadamard product form the basis of LSTM’s forget gate. By now, it should be apparent why we use sigmoid activations: instead of causing divergence with something like ReLU, we want to deliberately saturate and cause the network to produce some “vanishing” values. But if our LSTM network only keeps forgetting, obviously this is going to be problematic. Instead, we also want to update the cell state using the new input values. Let’s take a look at the cell state equation again: Previously when discussing the forget gate, we focused only on the first term. Taking a look at the second term, we note that the term is adding some value to the cell state that has been updated to forget information. It only makes sense, then, for the second term to perform the information update sequence. But to understand the second term, we need to take a look at two other equations: (2) is another forward pass involving concatenation, much like we saw in (1) with math variable. The only difference is that, instead of forgetting, math variable is meant to simulate an update of the cell state. In some LSTM variants, math variable is simply replaced with math variable, in which case the cell state update would be rewritten as However, we will stick to the convention that uses math variable instead of the simpler variant as shown in (4-2). The best way to think of math variable or math variable is a filter: math variable is a filter that determines which information to be updated and passed onto the cell state. Now all we need are the raw materials to pass into that filter. The raw material is math variable, defined in (3). Notice that we use a math variable activation instead of a sigmoid, since the aim of (3) is not to produce a filter with sparse entries, but rather to generate substance, or potential information to be stored in memory. This is more in line with the classic vanilla neural network architecture we are familiar with. Now, we can finally glue the pieces together to understand (4): we enforce forgetfulness, then supply the cell state with new information. This is now the updated cell state, which gets passed onto the next sequence as new inputs are fed into the LSTM. So far, we have only looked at the recurrent features of LSTM; in other words, how it uses information from the past to update its knowledge in the present at time math variable. However, we haven’t yet discussed the most important part of any neural network: generating output. Obviously, all that hassle of forgetting and updating the cell state would be utterly meaningless if the cell state is not used to generate output. The whole purpose of maintaining a cell state, therefore, is to imitate long and short-term memory of the brain to generate some output. Thus, it is no surprise that the following two equations are structured the way they are: First, we see the familiar forward pass, a familiar structure we have seen earlier. Borrowing the analogy we established in the previous post, math variable is a filter that decides which information to use and drop. The raw material that we pass into this filter is in fact the cell state, processed by a math variable activation function. This is also a familiar structure we saw earlier in the information update sequence of the network. Only this time, we use the cell state to generate output. This makes sense somewhat intuitively, since the cell state is essentially the memory of the network, and hence to generate output would require the use of this memory. Of course, this should not be construed so literally since what ultimately happens during backpropagation is entirely up to the network, and at that point we simply lay back and hope for the network to learn the best. This point notwithstanding, I find this admittedly coarse heuristic to be nonetheless useful in intuiting the clockwork behind LSTMs. At this point, we’re not quite done yet; math variable is not a vector of probabilities indicating which letter is the most likely in a one-hot encoded representation. Therefore, we will need to pass it through another affine layer, than apply a softmax activation. Hence, math variable is the final output of an LSTM layer. Here comes the tricky part: backprop. Thankfully, backprop is somewhat simple in the case of LSTMs due to the use of Hadamard products. The routine is not so much different from a vanilla neural network, so let’s try to hash out the equations. As we already know, backpropagation in neural networks is merely an extended application of the chain rule, with some minor caveats that matrix calculus entails. First, let’s begin slow and easy by deriving the expressions for the derivative of the sigmoid and the math variable functions. First, below is the derivative of the sigmoid with respect to math variable, the input. Recall that the sigmoid function is defined as . Let’s do the same for math variable. One useful fact about math variable is the fact that it is in fact nothing more than just a rescaled sigmoid. This relationship becomes a bit more apparent when we graph the two functions side by side. Let’s refer to the definition of math variable to derive an expression for its derivative (no pun intended). Now comes the more complicated part. Thankfully, we’ve already done something very similar in the past when we were building a vanilla neural network from scratch. For instance, we know from this post that, given a cross entropy loss function, the gradient of the softmax layer can simply be calculated by subtracting the predicted probability from the true distribution. In other words, given an intermediate variable we know that Note that math variable is denoted as in the code segment. Since we have this information, now it’s just a matter of back propagating the gradients to the lower segments of the acyclic graph that defines the neural network. Given (8), it only makes sense to continue with the next parameter, math variable. The transpose or the order in which the terms are multiplied may be confusing, but with just some scratch work on paper, it isn’t difficult to verify these gradients by checking their dimensions. The equation for math variable is even simpler, since there is no matrix multiplication involved. Thus, the gradient flows backwards without any modification. Moving down a layer, we come across (6): Let’s begin by trying to find the gradient for math variable. You might be wondering what the math variable term is doing in that equation. After all, isn’t that quantity precisely what we are trying to calculate? This is the one tricky yet also interesting part about RNN backpropagation. Recall that the whole point of a recurrent neural network is its use of variables from the previous forward pass. For example, we know that in the next forward pass, math variable will be concatenated with the input math variable. In the backpropagation step corresponding to that forward pass, we would have computed math variable; thus, this gradient flows into the current backpropagation as well. Although this diagram applies to a standard RNN instead of an LSTM, the recurrent nature of backprop still stands. I present it here because I find this diagram to be very intuitive. If you look at the right, the star represents the gradient from the last pass. If you look to the left, you will see that there is going to be a gradient for math variable that will eventually be passed over to the next backpropgation scheme. Since the forward pass is recurrent, so is the backward pass. Since we have math variable, now it’s time to move further. Let’s derive the expression for the gradient for math variable. Let’s do the same for the other term, math variable. To make things easier, let’s make a quick substitution with an intermediate variable, i.e. let math variable. Then, But math variable was just an intermediate variable. How can we get the gradient for math variable itself? Well, since the only transformation was just a math variable, chain rule tells us that all we need is to multiply the antiderivative of math variable, which we already derived above. Also keep in mind that since math variable is a recurrent variable, we have to apply the gradient from the next call as well, just like math variable. Note that all we had to do is to multiply the function we derived above, then add the backpropgation from the next iteration to account for the recurrent nature of the network. We still have a decent amount of work to do, but the fortunate news is that once we derive an expression for one parameter, the rest can also be obtained in an identical fashion. Therefore, for the sake of demonstration, we will only deal with math variable and math variable. Let’s start with the easier of the two, math variable. Recall that As we have done earlier, let’s introduce an intermediate variable, math variable, and try deriving the gradient for that variable. Note that with this substitution, math variable. Now we can move onto deriving the expressions for the gradient of the actual parameters, starting with math variable. This is extremely simple since math variable and math variable are defined by a linear relationship. The next in line is math variable. This is also very simple, since all we need to do is to consider one instance of matrix multiplication. where, given a concatenation operator math variable, Now we are done! The gradient for the rest of the parameters, such as math variable or math variable look almost exactly the same as math variable and math variable respectively, and not without reason: as we have noted above, what I conveniently called the filter-and-raw-material structure of LSTM gates remain consistent across the forget, input, and output gates. Therefore, we can apply the same chain rule to arrive at the same expressions. However, there is one more caveat that requires our last bit of attention, and that is the gradient for math variable. Note that math variable had been concatenated to the input in the form of math variable throughout the forward pass. Because this was a variable that was used during computation, we need to calculate its gradient as well. This might appear rather confusing since we are currently looking at time math variable, and it seems as if the gradient for math variable variables should be happening in the next iteration of backpropagation. While this is certainly true for the most part, due to the recurrent nature of LSTMs, we need to compute these gradients for math variable in this step as well. This is precisely what we were talking about earlier when discussing the recurrent nature of backprop; the math variable we compute here will be used in the next iteration of backpropagation, just like we added math variable in the current backprop to calculate math variable. Becaue math variable was used in many different places during the forward pass, we need to collect the gradients. Given an intermediate variable we can express the gradient in the following fashion: Then, we can obtain math variable by un-concatenation: where math variable denotes the number of neurons in the LSTM layer. We can do the same for math variable. This is a lot simpler: These gradients, of course, will be passed onto the next iteration of backpropagation, just like we had assumed that the values of math variable and math variable were given from the previous sequence of backpropagation. Because DL libraries make it extremely easy to declare and train LSTM networks, it’s often easy to gloss over what actually happens under the hood. However, there is certainly merit to dissecting and trying to understand the inner-working of DL models like LSTM cells, which offer a fascinating way of understanding the notion of memory. This is also important since RNNs are the basis of other more complicated models such as attention-based models or transformers, which is arguably the hottest topic these days in the field of NLP with the introduction of GPT-3 by OpenAI. I hope you have enjoyed reading this post. Catch you up in the next one!",1,0,0,0,0,0,0,0
"Basel, Zeta, and some more Euler","The more I continue my journey down the rabbit hole of mathematics, the more often I stumble across one name: Leonhard Euler. Nearly every concept that I learn, in one way or another, seems to be built on top of some strand of his work, not to mention the unending list of constants, formulas, and series that bears his name. It is simply mind-blowing to imagine that a single person could be so creative, inventive, and productive to the extent that the field of mathematics would not be where it is today had it not been for his birth on April 15, 1707. Why such intensive fanboying, you might ask. Well, let’s remind ourselves of the fact that the interpolation of the factorial through the Gamma function was spearheaded by Euler himself. But this is just the start of the beginning. Consider, for example, the Basel problem, an infamous problem that mathematicians have been trying to solve for nearly a century with no avail, until the 28-year-old Euler came to the rescue. The Basel problem can be stated as follows: At a glance, this seems like a fairly simple problem. Indeed, we know that this series converges to a real value. We also know that integration would give us a rough approximation. However, how can evaluate this series with exactitude? Euler’s solution, simple and elegant, demonstrates his genius and acute heuristics. Euler begins his exposition by analyzing the Taylor expansion of the sine function, which goes as follows: Dividing both sides by math expression, we obtain the following: Now it’s time to follow Euler’s amazing intuition. If we take a close look at the equation math expression, we can convince ourselves that its solutions will adhere to the form math expression, where math expression is a non-zero integer between math expression. This is expected given the periodic behavior of the sine function and its intercepts with the math expression-axis. Given these zeros, we can then reconstruct the original function math expression as an infinite product using the fundamental theorem of algebra, or more specifically, Weierstrass factorization. Let’s try to factor out the coefficient of the math expression term through some elementary induction. First, we observe that calculating the product of the first two terms produces the following expression: Then, we can express the target coefficient, denoted by math expression, as follows: Where math expression denotes the coefficient of math expression obtained by expanding the rest of the terms following math expression in the infinite product above. If we repeat this process once more, a clear pattern emerges: Iterating over this process will eventually allow us to express our target coefficient as a sum of inverse squares multiplied by some constant, in this case math expression: But then we already know the value of math expression from the modification of the Taylor polynomial for sine we saw earlier, which is math expression! Therefore, the Basel problem reduces to the following: Therefore, And there we have the solution to the Basel problem. In hindsight, solving the Basel problem is not rocket science; it is a mere application of the Taylor polynomial, coupled with some modifications and operations to mold the problem into a specific form. However, it takes extreme clairvoyance to see the link between the Basel problem and the Taylor polynomial of the sine function. At this point, it doesn’t even surprise us to know that Euler applied this line of thinking to calculate the value of the sum of higher order inverses. An interesting corollary of Euler’s solution to the Basel problem is the Wallis product, which is a representation of the quantity math expression as an infinite product, as shown below: It seems mathematically unintuitive to say that an irrational number such as math expression can be expressed as a product of fractions, which is a way of representing rational numbers. However, we can verify the soundness of the Wallis product by substituting math expression for math expression in (1): Taking the reciprocal of this entire expression reveals the Wallis product. The Basel problem is a specific case of the Riemann zeta function, whose general form can be written as follows. A small digression: when math expression, the zeta function converges to a value known as Apéry’s constant, eponymously named after the French mathematician who proved its irrationality in the late 20th century. Beyond the field of analytics and pure math, the zeta function is widely applied in fields such as physics and statistics. Perhaps we will explore these topics in the future. So back to the zeta function. In the later segment of his life, Euler found a way to express the zeta function as, you guessed it, an infinite product. This time, however, Euler did not rely on Taylor polynomials. Instead, he employed a more general approach to the problem. It is here that we witness Euler’s clever manipulation of equations again. We commence from the zeta function, whose terms are enumerated below. Much like how we multiply the ratio to a geometric sequence to calculate its sum, we adopt a similar approach by multiplying the second term, math expression to the entire expression. This operations yields By subtracting this modified zeta function from the original, we derive the following expression below. Now, we only have what might be considered as the odd terms of the original zeta function. We then essentially repeat the operation we have performed so far, by multiplying the expression by math expression and subtracting the result from the odd-term zeta function. It is not difficult to see that iterating through this process will eventually yield Euler’s product identity for the zeta function. The key to understanding this identity is that only prime numbers will appear as a component of the product identity. We can see this by reminding ourselves of the clockwork behind the sieve of Eratosthenes, which is basically how the elimination and factorization works in the derivation of Euler’s identity. Taking this into account, we can deduce that Euler’s identity will take the following form: This expression is Euler’s infinite product representation of the zeta function. These days, I cannot help but fall in love with Euler’s works. His proofs and discoveries are simple and elegant yet also fundamental and deeply profound, revealing hidden relationships between numbers and theories that were unthought of during his time. I tend to avoid questions like “who was the best math expression in history” because they most often lead to unproductive discussions that obscure individual achievements amidst meaningless comparisons, but I dare profess here my belief that only a handful of mathematicians can rival Euler in terms of his genius and prolific nature. That is enough Euler for today. I’m pretty sure that this is not going to be the last post on Euler given the sheer amount of work he produced during his lifetime. My exploration of the field of mathematics is somewhat like a random walk, moving from one point to another with no apparent pattern or purpose other than my interest and Google’s search suggestions, but my encounter with Euler will recur continuously throughout this journey for sure. But for now, I’m going to take a brief break from Euler and return back to the topic of good old statistical analysis, specifically Bayesian methods and Monte Carlo methods. Catch you up in the next one!",0,0,0,0,0,0,1,0
A Brief Introduction to Recurrent Neural Networks,"Neural networks are powerful models that can be used to identify complex hidden patterns in data. There are many types of neural networks, two of which we have seen already on this blog: the vanilla, feed-forward neural network and convolutional neural networks, often abbreviated as convnets. Today, we will add a third kind to this exciting mix: recurrent neural networks, or RNNs. Let’s take a brief conceptual look at how recurrent neural networks work, then implement a toy RNN to see how it compares to other models on the IMDB movie reviews dataset. I heavily borrowed my examples from Deep Learning with Python by François Chollet and the tutorial on text classification available from the official TensorFlow documentation. Recurrent neural networks, as the name implies, refer to neural network models that contain some sort of internal looping structure that simulates a flow of information. A good way to conceptualize this loop is to think of something like loops, where a certain operation is performed repeatedly for a specified number of cycles. Given these pieces of information, we might ask ourselves two questions. Firstly, what does this looping operation involve? Secondly, what is the purpose of having this loop in the first place? Let’s try to answer both questions in the following subsections. One of the most salient features of a recurrent neural network is that it is capable of emulating some primitive form of memory. Why might we want to do this? Well, take the example of reading a text. When we read, we don’t process a given text at once in its totality; instead, we break them down into pieces, such as a word or a bag of words, and build our understanding based on information obtained from the previous sequence of text. In other words, processing information through reading is at best understood as a process of continuously receiving new information while retaining information obtained from the previous sequence. This is why recurrent neural network models are frequently employed in the context of natural language processing. But the applications of RNNs extends beyond the domain of NLP. For example, say we are given a dataset of temperature recording of a city district. Obviously, the structural integrity of that dataset is very important, i.e. we should not shuffle the datasets because making weather predictions requires us to understand temporal patterns. In predicting the weather 24 hours from today, data points pertaining to the last two days will be obviously much more important that those recorded a month ago. In such instances of time series analysis, recurrent neural networks perform better than other models we have looked at thus far. To better understand how RNNs work, let’s try to build a very simple recurrent neural network from scratch with . We will only implement forward propagation for the sake of simplicity, but with some matrix calculus, one can imagine how deriving the formula for back propagation will be possible. Let’s cut to the chase: RNNs emulate memory by using the output from the previous sequence as an input to the next. Perhaps writing this down in matrix notation might give you a better idea of what the statement above means. Here is one way we might implement a very simple recurrent neural network. If the word “recursion” pops up into your mind, then you are on the right track. Notice that in calculating math variable, the output of the current sequence, the output of the previous sequence, math variable is used. By using the output of the previous sequence, the recurrent neural network is able to “remember” some of the information that was produced by the previous input. Granted, this is not exactly what memory is or how it works in the strictest sense, but we can see how some information from the previous input is trickling down to affect the computation of the current sequence of input data. Note that I used math variable for the example, but we can just about use any other activation function. Here is one way we might implement this in Python. Although not necessary, I decided to opt for a class-based implementation to make things look tight and nicer. Let’s create a class object to see that everything works properly. There is really not much point in seeing the output because the calculations are going to be based off of randomly generated data and randomly created weights, but perhaps there is something to be learned from the dimensionality of input and output data. First, note that our model accepts input of size . The dimensionality of the output is a little more tricky because of the option. What concatenate does is that it basically flattens all number of outputs into a single list. In this case, because we set the option to , we get a flattened list containing , or 6400 elements. The main takeaway is that recurrent neural networks can be used to implement some sort of memory functionality, which is useful when dealing with datasets where there exists some sort of sequential structure. One way to implement memory is by using the output of the previous sequence to define a variable, which is used to compute the next output as we have done above. Now let’s get down to business with the API. Implementing a recurrent neural network is not so much different from building a simple feed forward or convolutional neural network: we simply import a RNN-specific layer and arrange these layers to construct a working model. Before we proceed any further, let’s first import all necessary dependencies for this tutorial. As with any tutorial, we need to start by loading and preprocessing data. Luckily, there isn’t going to be much preprocessing involved since we will be using a dataset available from the library, the IMBD movie reviews dataset. The dataset contains 25,000 movie reviews from IMDB, labeled as either positive or negative. Each review is encoded as a sequence of integers according to a consistent encoding scheme. In other words, each integer corresponds to a unique word in the vocabulary of the dataset. More specifically, the integer to which a word is mapped corresponds to the frequency with which the word appears, i.e. the word encoded as 10 corresponds to the 10th most frequent word in the data. We will apply some very basic preprocessing on the dataset so that we can feed it into our model. Specifically, we will preprocess the dataset such that only a number of most frequently occurring words are considered. This step will weed out words that occur very infrequently, thus decreasing the amount of noise from the network’s perspective. Next, we will apply padding to the dataset so that all reviews are of length . This means that longer reviews will be truncated, whereas shorter reviews will be padded with zero entries. Below is a sample code implementation of this process. Let’s load the data using the function after specifying necessary parameters. Now that the data is here and ready to go, it’s time to build our neural network. To spice things up a bit, let’s create four different models and compare their performance. Before we jump into that, however, we first need to understand what an embedding layer is, as it is key to natural language processing. Simply put, an embedding layer is a layer that transforms words or integers that encode words into dense vectors. This is a necessary transformation since neural networks are incapable of dealing with non-quantitative variables. Why dense vectors, then? Can’t we simply use one-hot encoding? That is a valid point, since one-hot encoding is how we mostly deal with categorical variables in a dataset. However, one downside of this approach is that we end up with many sparse vectors. In other words, a lot of resources are wasted because the model now has to process vectors of thousands or millions of dimensions, depending on the vocabulary size. Instead of using sparse vectors to represent each word, we can simply use a denser vector of smaller dimensions to encode our data. Another advantage of this approach is that dense vectors can be used to encode semantic information. You might have heard of the famous example that “king minus male equals queen minus female.” If we were to represent the words king, queen, male, and female as vectors, we can add and subtract vectors to represent and distill meaningful information. This vector-based computation is the key to natural language processing with deep neural networks: by back propagating and adjusting the weights of our embedding layer, our model can eventually be trained to “understand” the meaning of words and their relationship with other words in the form of dense vectors. Enough talking, let’s use the embedding layer to build our neural networks, starting with the simple feed-forward model. The feed-forward neural network model will first have an embedding layer that processes input. Then, the output of this embedding layer will be flattened to be passed onto a dense layer with one output transformed by the sigmoid activation function. We use the sigmoid function since we want to conduct a sentiment analysis of determining whether a given movie review is positive or negative. That wasn’t so difficult. Let’s initialize our model by defining the model parameters , , and , then plot the model to see the structure of the network alongside the input and output dimensions of each layer. Note that we defined to be 16, which means that each word is transformed into dense vectors living in 16 dimensions. By plotting the model, we can get a better idea of the layers that compose the model. The next model we will build is a simple recurrent neural network. This neural network is going to have an embedding layer, just like the previous model. However, instead of a dense layer, it will have two consecutive layers stacked on top of each other. The layer is essentially the implementation of the model we built earlier. Let’s take a look. We instantiate the model and take plot the network, just as we have done above. The model we built is, as the name shamelessly puts out, pretty simple. There are a lot more advanced recurrent neural networks that have complicated internal cell structures to better emulate human memory, in a sense. The biggest difference between a simple recurrent neural network and an LSTM is that LSTMs have a unique parameter known as the carrier that encodes an additional layer of information about the state of the cell. I might write a separate post devoted to the intricacies of the LSTM, but if you’re an avid reader who’s itching to know more about it right away, I highly recommend this excellent post by Christiopher Olah. For now, let’s just say that LSTMs represent a huge improvement over conventional RNNs, and that we can implement them in by simply calling the layer as shown below: Because LSTM layers take a lot longer to train than others, and because the representational capacity of a single LSTM layer is higher than that of others, I decided to use only one LSTM layer instead of two. Let’s initialize this model to take a better look. The last model we will create is a convnet, which we explored on this previous post on image classification. Convolutional neural networks are great at identifying spatial patterns in data, which is why they also perform reasonably well in natural language processing. Another huge advantage of convents over recurrent networks is that they took a lot lesser time and resources to train. This is why it is often a good idea to build a convent to establish a baseline performance metric. Let’s initialize the model with identical parameters and take a look at its internal structure. Let’s train all four models using the training data. For control our experiment, we will train all four models over the same , , and . There isn’t much exciting here to look at it terms of code; it’s just a matter of patience, waiting for the models to hopefully converge to a global minimum. For future reference, all training history is dumped in the object where corresponds to the model number. After a long time of waiting, the training is finally complete! If you are following this tutorial on your local workstation, please note that the time required for training may vary depending on your hardware configurations or the specification of our instance if you are using a cloud-based platform like AWS. None of our models reached the threshold of ninety percent accuracy, but they all managed to converge to some reasonable number, hovering around the high seventies to low eighties. Let’s test the performance of our models by using the and data, both of which none of our models have seen before. Based on the results, it looks like the LSTM model performed best, beating other models by a small margin. At this point, we cannot conclude as to whether or not this marginal boost in performance is significant. Judging this would not only depend on the context, but also most likely require us to have a larger test dataset that captures the statistics of the population data. This point notwithstanding, it is certainly beneficial to know that LSTM networks are good at detecting sequential patterns in data. Last but not least, let’s visualize the training scheme of all four models to take a identify any possible signs of convergence and overfitting, if any. To do that, we will be using the function shown below. The dense feed-forward network seems to have a very linear pattern. One immediate pattern we see is that the model seems to be overfitting right away, since the testing accuracy decreases with each epoch while the training accuracy increases. This is certainly not a good sign; in the best case scenario, we want to see that training and testing labels moving in the same direction. Perhaps this is the biggest indication that a simple feed forward network is a suboptimal model choice in the context of this problem. The graphs for the model seems a lot better. At the very least, we see the training and test labels moving in unison: the accuracy increases with each epoch, while the loss slowly decreases. However, we do see some overfitting happening at the last two epochs or so. Specifically, note that cross entropy loss for the testing data seems to pick up an incrementing pattern past the seventh epoch. This observation suggests that we need to configure the model differently, presumably by decreasing the number of tunable parameters. Next comes the winner of the day, the LSTM network. An interesting point to note about the learning curve of this model is that the test data accuracy and loss seem to stay roughly stagnant despite the progression of epochs. To better understand this phenomena, we probably have to run more trials with more data over longer iterations than we have done in this tutorial. This point notwithstanding, it is interesting to see how a single layer LSTM network can outperform a stacked RNN network. The last up on this list is the one-dimensional convolutional neural network. The convent produced very remarkable results in this experiment, especially given its extremely short training time. Recurrent neural networks typically take a lot of time to train—even when they are not stacked—because each neuron is defined by a rather complicated operation involving many parameters, such as states, carriage, and so on. Convents, on the other hand, are relatively simpler, and thus take noticeably shorter to train and deploy. This tutorial demonstrates that convents can perform as well as simple recurrent networks to establish a baseline performance metric. In this post, we briefly introduced and explored the concept of recurrent neural networks, how they work, and how to build them using the functional API. Recurrent neural networks are one of the hottest topics in the contemporary deep learning academia because it presents numerous possibilities for applications. Hopefully this post gave you a better understanding of what all the hype is about, why RNNs are effective at what they do, and how they can be used in the context of basic natural language processing. In the next post, we will take a look at another interesting natural language processing task. Peace! My deepest condolences to those affected by the Wuhan corona virus, as well as the families and fans of Kobe Bryant.",1,0,0,0,0,0,0,0
Demystifying Entropy (And More),"The other day, my friend and I were talking about our mutual friend Jeremy. “He’s an oddball,” my friend Sean remarked, to which I agreed. Out of nowhere, Jeremy had just told us that he would not be coming back to Korea for the next three years. “He is just about the most random person I know.” And both of us, being aspiring statistics majors, began wondering: is there a systematic way of measuring randomness? It is from here that we went down the rabbit hole of Google and Wikipedia search. I ended up landing on entropy land, which is going to be the topic for today’s post. It’s a random post on the topic of randomness. To begin our discussion of randomness, let’s take a look at how scientists measure the randomness involved in natural phenomena, such as particle movement. If you are a chemist or physicist, you might be familiar with the concept of entropy, one of the core elements of thermodynamics and a topic that recurs throughout many subfields of natural sciences. Although I’m no science major, one of the few things that I recall from high school chemistry class is the Gibbs free energy equation for calculating the spontaneity of reactions, which went as follows: where the term for entropy, denoted as math variable satisfies the condition that We won’t get into the details of these equations, but an intuition that we can glean from this equation is that the randomness of a particle is determined by the number of potential states that are possible for that given particle. In other words, a gas particle that freely moves across space at ATP is going to be more random than a near-static water particle composing an ice cub. We might take a step further and say that the gas particle carries a larger amount of information than the particle in a solid since more information is required to express its randomness. Entropy in science, denoted above as math variable, provides us with a valuable intuition on the topic of randomness and information. In fact, it is no coincidence that the notion of randomness in information theory, a subfield of math that we are going to be dipping our toes in, borrowed the term “entropy” to express randomness exhibited in data. Just like entropy was used to quantify randomness in the scientific phenomena, the notion of entropy is used in information theory to denote randomness in data. The origin of information entropy can be traced back to Claude Shannon’s paper published in 1948, titled “A Mathematical Theory of Communication.” While working at Bell Labs, Shannon was experimenting with methods to most efficiently encode and transmit data without loss of information. It is in this context that Shannon proposed the notion of entropy, which he roughly defined as the smallest possible size of lossless encoding of a message that can be achieved for transmission. Of course, there is a corresponding mathematical definition for entropy. But before we jump straight into entropy, let’s try to develop some preliminary intuition on the concept of information, which is the building block of entropy. What is information? Warren Weaver, who popularized Shannon’s works and together developed the field of information theory, pointed out that information is not related to what is said, but what could be said. This element of uncertainty involved in one’s degree of freedom is what makes the notion of information inseparable from probability and randomness. As Ian Goodfellow put it in Deep Learning, The basic intuition behind information theory is that learning that an unlikely event has occurred is more informative than learning that a likely event has occurred. In other words, a low probability event expresses a lot of information, while a high probability event expresses low information as its occurrence provides little information of value to the informed. Put differently, rare events require more information to represent than common ones. Consider, for example, how we might represent the amount of information involved in a fair coin toss. We know for a fact that where math variable and math variable denote the events that the coin lands on heads and tails, respectively. How might we be able to express information involved in the event that the coin lands on tails? How about heads? There are many ways to approach this problem, but an easy way would be to use binary numbers. For example, we might ascribe meaning to 0 and 1 such that 0 represents heads and 1 represents tails. Of course, there might be other ways to encode information, such as setting 111 to heads and 000 to tails, but obviously this is wasting information. In other words, it is not the most efficient method of encoding. Even under a single digit binary number scheme, we would be able to decode a series of transmitted information without loss. It is not difficult to see, therefore, that all we need to express the result of a fair coin toss is a single digit of binary numbers 0 and 1. Typically, we use bits to denote the number of digits required to express information in binary numbers. In this case, the information involved in math variable is equal to 1 bit; by symmetry, the same goes for math variable. If bits sounds similar to bytes or gigabytes we use for storage, you’re exactly on the right path. In fact, the relationship between bit and byte is established directly by the fact that where math variable denotes bits and math variable denotes bytes. This is why we use bytes to represent the amount of disk storage in computers, for instance. It is also worth mentioning that the alternative name for bits is Shannons, named eponymously after the mathematician who pioneered the field of information theory, as mentioned above. Now that we have some idea of what information is and how we can quantify it using binary numbers in bits, it’s time to get into the math. Information can be calculated through the formula where math variable is the information need to express the random event math variable, and math variable is the probability that event math variable occurs, i.e. math variable. There are different versions of this formula, such as the one that uses Euler’s constant as the log base instead of 2. Whereas the unit of information as measured through (1) is in bits, that calculated through (2) as shown below is in the unit of nats. For the purposes of this post, we will be using equation (1) instead of two. This is primarily because we will be using the binary number analogy to build an intuition for information computation. Let’s quickly create a visualization that shows the relationship between probability and information in bits. As equation (1) describes this relationship quite concisely, let’s try plotting it on a graph. So that’s how we calculate randomness in a random event—the amount of information that is needed to represent randomness as probability. If you think about it for a second, this is a very intuitive definition of randomness: the more random and infrequent an event is, the more information would be required to represent it. With this in mind, now we move onto the bigger picture: entropy in the context of random variables. In the previous section, we looked at how random events can be represented as information in bits. What’s important here was that we were dealing with isolated random events instead of random variables. For example, in the fair coin toss example, we dealt with information involved with math variable and math variable, not the binomial random variable math variable itself. This is an important distinction to make, because entropy is essentially a probabilistically weighted average of all the random events that a random variable can take. In other words, entropy is defined as the weighted average of information given by each random event: For the continuous case, we would use an integral instead. Say math variable denotes the random variable of interest in a fair coin toss. Then, we are most interested in how much bits, on average, we would need to encode information generated from the distribution of this random variable. Using (3), we can easily answer this question by calculating the follows: This tells us that the entropy involved in a fair coin toss is 1 bit, i.e, on average, we only need a single digit of binary number to encode information given by a fair coin toss. But how might this number change for a biased coin? We would not expect the entropy of the random variable given by the result of a biased coin to be 1. For example, consider a coin that always lands on heads. The entropy of the random variable in this case would be exactly 0 bits, since we don’t need any information to express an event that is certain. Let’s try to figure out this dynamic between success probability of math variable in a coin toss and entropy by creating a plot. The first observation to make is that the graph is symmetrical. This is no surprise, since we would expect the entropy of a random variable involving a coin that lands tails with probability math variable to be equal to that which lands on heads with equal probability math variable, i.e. whether the bias concerns heads or tails should not affect the calculation of entropy. Moreover, we see that the graph peaks when math variable, meaning that a fair coin toss involves the most randomness. In other words, this translates to saying that a skewed distribution is less random and thus more predictable than a symmetric one. This makes sense, since the result of a biased coin is more predictable and less surprising than that of a fair one, with the extreme case being the coin that always lands on one side. Seen in this light, entropy is just the total amount of information content expressed by the distribution of a random variable. Because we were dealing with a very simple example of biased coins, entropy values we calculated did not go past 1 bits, but we can easily imagine situations were it might, such as a dice roll or more complicated real-life examples. In this light, entropy is one metric with which we can quantify randomness, which is the mission we set out to accomplish in this post. But entropy is a lot more than just an interesting concept on randomness. Entropy has wide ranging applications, especially in the field of machine learning and neural networks. Among these, we will be looking at cross entropy and Kullback-Leibler divergence, two derivative concepts of entropy that are arguably most commonly used. Let’s start with the big picture first—when these concepts are used, what is the relationship between the two, why they are important—and move onto the details later. First, we have to know that cross entropy, unlike just entropy, deals with two probability distributions instead of one. Specifically, cross entropy is a way of measuring the pseudo-distance between two probability distributions. In a typical scenario, we might have a true probability distribution math variable that we are trying to model, and our deep learning algorithm might produce some approximate probability distribution math variable. We might evaluate the effectiveness of our model by calculating the distance between math variable and math variable. Seen in this light, cross entropy can be interpreted as a target cost function to be minimized. Here is the equation that explains the relationship between entropy, cross entropy, and KL divergence. where math variable denotes cross entropy; math variable,entropy, and the last term, KL divergence. Now, let’s try to understand what each of them means. KL divergence has many interpretations. One possible definition of KL divergence is that it measures the average number of extra information content required to represent a message with distribution math variable instead of math variable. In Machine Learning: A Probabilistic Perspective, Kevin P. Murphy describes KL divergence as follows: … the KL divergence is the average number of extra bits needed to encode the data, due to the fact that we used distribution math variable to encode the data instead of the true distribution math variable. Put differently, KL divergence is the amount of information that is lost when math variable is used to approximate math variable. Therefore, if math variable and math variable are close, KL divergence would be low, whereas the converse would be true when the two distributions are different. We can also extend this notion a bit farther to apply it in the context of Bayesian inference. Recall that Bayesian inference is the process by which we start from some prior distribution and update our beliefs about the distribution with more data input to derive a posterior. In this context, KL divergence can be viewed as the amount of information gained as we move from the prior math variable to the posterior math variable. Let’s derive the mathematical definition of KL divergence using likelihoods. The derivation process to be introduced is based on this source. We begin with the likelihood ratio: We can consider math variable as representing how probable the sample math variable came from distribution math variable than math variable, given that math variable was sampled from some unknown distribution. If math variable, the more likely it is that the data came from math variable; if math variable, the more probable it is that the sample came from math variable. Say we have multiple independent observations of data. Then, we can use (6) to compute the likelihood ratio for each sample. Calculating the product of these ratios will tell us which distribution is more likely given all available data points. In other words, A technique we saw when we were exploring the topic of likelihood maximization was log likelihood. Log likelihoods are useful because we can reexpress products as sums, using the property of logs. (7) makes sense, but it weighs all likelihood ratios equally. In reality, most samples are not equiprobable; some values are more likely than others, unless in the context of uniform distributions. To account for this, let’s reframe (7) as an expected values calculation, i.e. give different weight to each likelihood ratio depending on the probability of observing that data point. Let’s make (8) look better by unpacking the fraction sitting in the log function as a subtraction of two terms. The final key is to realize the secret that In other words, we have derived the mathematical definition of KL divergence! The mathematical definition of cross entropy can simply be derived by plugging in (10) into (5). This yields Recall that the definition of entropy goes as Plugging in this definition to (11) yields the simplified definition of cross entropy: If KL divergence represents the average amount of additional information needed to represent an event with math variable instead of math variable, cross entropy tells us the average amount of total information needed to represent a stochastic event with math variable instead of math variable. This is why cross entropy is a sum of the entropy of the distribution math variable plus the KL divergence between math variable and math variable. Instead of dwelling in the theoretical realm regurgitating different definitions and interpretations of cross entropy and KL divergence, let’s take a look at a realistic example to gain a better grasp of these concepts. Say we have constructed a neural network to solve a task, such as MNIST hand-written digit classification. Let’s say we have fed our neural network an image corresponding to the number 2. In that case, the true distribution that we are trying to model, represented in vector form, will be as shown below. The statement is there to make sure that the probabilities sum up to 1. Let’s assume that our neural network made the following prediction about image. These two distributions, although similar, are different. But the question is, how different? Creating a visualization might give us some idea about the difference between the two distributions. The two distributions are quite similar, meaning that our neural network did a good job of classifying given data. However, we can get a bit more scientific by calculating the cross entropy to see exactly how well our model performed with the given data. To achieve this, let’s quickly write some functions to calculate KL divergence and cross entropy. We will be reusing the function we defined above. On a trivial note, we prevent Python from running into math domain errors, we add to the provided distribution if the list contains 0. The result is unsurprising. If we recall that the definition of entropy is the amount of information content needed to encode information, we will quickly realize that is a distribution with probability 1, which is why it makes sense that entropy converges to 0. Therefore, in this case, KL divergence equals cross entropy, which computes to approximately 0.415. What actually happened beneath the hood? If we recall the definition of cross entropy, we can easily see that, among the 10 terms, 9 of them were eliminated since math variable given the setup of the distribution . In the end, the only term that mattered was the third term, which was given by Why does this quantity make sense as an error term defining a loss function? In other words, why is cross entropy used as a loss function in classification tasks? To see this, let’s assume that our neural network was perfect in its prediction, or more realistically, trained to excessively overfit given data, i.e, equals . Then, cross entropy would have been calculated as Indeed, we can use our function to verify the coherency of this statement. In other words, when our predicted distribution equals the true distribution we are trying to model, cross entropy becomes 0, as a desirable cost function would behave. This is why crosss entropy is often used in classification models where we have a one-hot encoded vector that represents a true distribution, as exemplified by , and a prediction that models this distribution, denoted as in our example. It is not difficult to see why cross entropy is a useful cost function frequently used in the field of machine learning. Entropy is an interesting concept with which we can quantify randomness in data. This process is no rocket science, but simply a process that involves calculations with probabilities. Although the link may not be immediately apparent, randomness is just another way of expressing probabilities and uncertainty, and it is from this premise that information and entropy take off. Beyond that, however, entropy is now used extensively in the field of machine learning, specifically as a loss function. Although it was not noted explicitly above, cross entropy calculates the same quantity as the logarithmic loss function. Essentially, cross entropy is useful in that it provides us with some intuitive information of how far two distributions are apart. This distance is a metric with which we can evaluate the effectiveness of our model, which also means that the effectiveness of a model will be increased as cross entropy is increasingly minimized. Machine learning is often referred to as a black box that we can simply use without much knowledge on how it works, but I personally find studying these underlying clockwork behind the hood to be much more interesting than blindly applying to to churn out numbers and predictions. I hope you enjoyed reading. Merry Christmas and Happy holidays!",0,0,0,0,1,0,0,0
A PyTorch Primer,"I’ve always been a fan of TensorFlow, specifically , for its simplicity and ease of use in implementing algorithms and building models. Today, I decided to give PyTorch a try. It is my understanding that TensorFlow is more often used in coporate production environments, whereas PyTorch is favored by academics, especially those in the field of NLP. I thought it would be an interesting idea to give it a try, so here is my first go at it. Note that the majority of the code shown here are either borrowed from or are adaptations of those available on the PyTorch website, which is full of rich content and tutorials for beginners. Of course, basic knowledge of DL and Python would be helpful, but otherwise, it is a great place to start. Let’s dive right in! Like TensorFlow, PyTorch is a scientific computing library that makes use of GPU computing power to acceleration calculations. And of course, it can be used to create neural networks. In this section, we will take a look at how automatic differentiation works in PyTorch. Note that differentiation is at the core of backpropagation, which is why demonstrating what might seem like a relatively low-level portion of the API is valuable. Let’s begin our discussion by first importing the PyTorch module. It isn’t difficult to see that is a scientific computing library, much like . For instance, we can easily create a matrice of ones as follows: The is a parameter we pass into the function to tell PyTorch that this is something we want to keep track of later for something like backpropagation using gradient computation. In other words, it “tags” the object for PyTorch. Let’s make up some dummy operations to see how this tagging and gradient calculation works. Note that performs element-wise multiplication, otherwise known as the dot product for vectors and the hadamard product for matrics and tensors. Let’s look at how autograd works. To initiate gradient computation, we need to first call on the final result, in which case . Then, we can simply call to tell PyTorch to calculate the gradient. Note that this works only because we “tagged” with the parameter. If we try to call on any of the other intermediate variables, such as or , PyTorch will complain. Let’s try to understand the result of this computation. Let math variable denote the final tensor. Since we called , and since has a total of four elements, we can write out our dummy calculations mathematically in the following fashion: Using partial differentiation to obtain the gradients, Since math variable, Since math variable is just an arbitrary, non-specific index out of a total of four, we can easily see that the same applies for all other indices, and hence we will end up with a matrix whose all four entries take the value of 4.5, as PyTorch has rightly computed. We can go even a step farther and declare custom operations. For example, here’s a dummy implementation of the ReLU function. Let’s talk about the method first. Note that it takes in two argument parameters: and . As you might have guessed, is simply the value that the function will be provided with. The can simply be thought of as a cache where we can store vectors or matrices to be used during backpropagation. In this case, we store the by calling method. During the backward pass, we compute the gradient. Here, we need to retrieve the variable which was stored in the context. This is because the ReLU function takes the following form: Thus, its derivative is During backpropagation, this means that gradients will flow down to the next layer only for those indices whose input elements to te ReLU function were greater than 0. Thus, we need the input vector for reference purposes, and this is done via stashing it in the variable. We will see how we can incorporate into the model in the next section. In this example, we’ll take a look at an extremely simple model to gain a better understanding of how everything comes into play in a more practical example. This is the method that I’ve mostly been using when implementing simple dense fully-connected models in NumPy. The idea is that we would mathematically derive the formula for the gradients ourselves, then backpropagate these values during the optimization process. Of course, this can be done with PyTorch. To build our simple model, let’s first write out some variables to use, starting with the configuration of our model and its dimensions. We will also need some input and output tensors to be fed into the model for trainining and optimization. Next, here are the weight matrices we will use. For now, we assume a simple two layered dense feed forward network. Last but not least, let’s define a simple squared error loss function to use during the training step. With this entire setup, we can now hash out what the entire training iteration is going to look like. Wrapped in a loop, we perform one forward pass, then perform backpropagation to adjust the weights. Great! We see that the loss drops as more epochs elapse. While there is no problem with this approach, things can get a lot more unwieldy once we start building out more complicated models. In these cases, we will want to use the auto differentiation functionality we reviewed earlier. Let’s see this in action. Also, let’s make this more PyTorch-y by making use of classes. We will revisit why class-based implementations are important in the next section. Notice we didn’t have to explicitly specify the backpropagation formula with matrix derivatives: by simply calling properties for each of the weights matrices, we were able to perform gradient descent. One detail to note is that, unlike in the case above where we had to explicitly call in order to obtain the loss value—which would be of type —we leave the computed loss to remain as a tensor in order to call . We also make sure to reset the gradients per epoch by calling . We can also improve our implementation by making use of the class that we implemented earlier. This is simple as doing This might be a better way to implement the function for reasons of simplicity and readability. Although ing works, it’s more arguably cleaner to write a ReLU this way. Also, this is a dummy example, and we can imagine a lot of situations where we might want to write custom functions to carry out specific tasks. Much like TensorFlow, PyTorch offers to ways of declaring models: function-based and class-based methods. Although I have just started getting into PyTorch, my impression is that the later is more preferred by PyTorch developers, whereas this is not necessarily the case with Keras or . Of course, this is a matter of preference and development setting, so perhaps such first impression generalizations do not carry much weight. Nonetheless, in this section, we will take a look at both ways of building models. Let’s start with the function-based method. The function-based method reminds me a lot of Keras’s sequential method. Let’s remind ourselves of Kera’s basic sequential model API: Now let’s compare this method with PyTorch’s way of declaring sequential models: This model declaration is in fact exactly identical to the simple model we have declared above. You can easily see how similar this code snippet is to the Keras example. The only difference is that the activation function is declared independently of the layer itself in PyTorch, whereas Keras combines them into one via argument. Of course, you don’t have to specify this argument, and we can import the ReLU function from TensorFlow to make it explicit like the PyTorch example. The point, however, is that the sequential model API for both libraries are pretty similar. Another way to build models is by subclassing . The submodule in PyTorch is the one that deals with neural networks; hence the . This subclassing might look as follows: This model is no different from the we defined earlier. The only notable difference is that we didn’t define a separate type function. For the most part, the overall idea boils down to Now let’s take a look at what the training code looks like. Although things might look a bit different, there’s not much going on in this process, other than the fact that some of the functions and logic we wrote before are now abstracted away by PyTorch. For example, we see , which is effectively the mean squared error loss, similar to how we defined above. Another difference we see is , which, as the variable name makes apparent, is the optimizer that we use for backpropagation. In this specific instance, we use SGD. Each backpropagation step is then performed simply via . In this tutorial, we took a very brief look at the PyTorch model. This is by no means a comprehensive guide, and I could not even tell anyone that I “know” how to use PyTorch. Nonetheless, I’m glad that I was able to gain some exposure to the famed PyTorch module. Also, working with Django has somewhat helped me grasp the idea of classes more easily, which certainly helped me take in class-based concepts in PyTorch more easily. I distinctively remember people saying that PyTorch is more object-oriented compared to TensorFlow, and I might express agreement to that statement after having gone through the extreme basics of PyTorch. In the upcoming articles, I hope to use PyTorch to build more realistic models, preferrably in the domain of NLP, as that seems to be where PyTorch’s comparative advantage stands out the most compared to TensorFlow. Of course, this is not to say that I don’t like TensorFlow anymore, or that PyTorch is not an appropriate module to use in non-NLP contexts: I think each of them are powerful libraries of their own that provide a unique set of functionalities for the user. And being bilinguial—or even a polyglot, if you can use things like Caffe perhaps—in the DL module landscape will certainly not hurt at all. I hope you’ve enjoyed this article. Catch you up in the next one!",1,0,0,0,0,1,0,0
